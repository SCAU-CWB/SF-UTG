public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }