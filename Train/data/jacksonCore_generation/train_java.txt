public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testOriginalMesssage() { [EOL]     JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA); [EOL]     String msg = exc.getMessage(); [EOL]     String orig = exc.getOriginalMessage(); [EOL]     assertEquals(\"Foobar\", orig); [EOL]     assertTrue(msg.length() > orig.length()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSingleQuotesDefault() throws Exception { [EOL]     _testSingleQuotesDefault(false); [EOL]     _testSingleQuotesDefault(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals(\"567\", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals(\"123\", out.toString(\"UTF-8\")); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEOFInName() throws Exception { [EOL]     final String JSON = \"{ \\"abcd\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for EOF\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected end-of-input\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEmptyArrayWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     JsonStreamContext ctxt = gen.getOutputContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     gen.writeStartArray(); [EOL]     ctxt = gen.getOutputContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     gen.writeEndArray(); [EOL]     ctxt = gen.getOutputContext(); [EOL]     assertTrue(\"Should be in root, was \" + ctxt.getTypeDesc(), ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     sw = new StringWriter(); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeStartArray(); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     docStr = sw.toString(); [EOL]     jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testMismatchObjectToArray() throws Exception { [EOL]     final String JSON = \"{ ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed OBJECT\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker ']': expected '}'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInterningWithReaders() throws Exception { [EOL]     _testIntern(false, true, \"c\"); [EOL]     _testIntern(false, false, \"d\"); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testRawValue() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeRawValue(\"7\"); [EOL]     gen.writeRawValue(\"[ null ]\"); [EOL]     gen.writeRawValue(\"false\"); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     JsonParser jp = createParserUsingReader(sw.toString()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(7, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCustomRootSeparatorWithFactory() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setRootValueSeparator(\"##\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeNumber(13); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeNull(); [EOL]     gen.close(); [EOL]     assertEquals(\"13##false##null\", sw.toString()); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleInt() throws Exception { [EOL]     int EXP_I = 1234; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_I + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_I, jp.getText()); [EOL]     assertEquals(EXP_I, jp.getIntValue()); [EOL]     assertEquals((long) EXP_I, jp.getLongValue()); [EOL]     assertEquals((double) EXP_I, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testAppendQuoted0_31() { [EOL]     final String[] inputs = { \"\u0000\", \"\u001F\", \"abcd\", \"\u0001ABCD\u0002\", \"WX\u000F\u0010YZ\" }; [EOL]     final String[] expecteds = { \"\\u0000\", \"\\u001F\", \"abcd\", \"\\u0001ABCD\\u0002\", \"WX\\u000F\\u0010YZ\" }; [EOL]     assert inputs.length == expecteds.length; [EOL]     for (int i = 0; i < inputs.length; i++) { [EOL]         final String input = inputs[i]; [EOL]         final String expected = expecteds[i]; [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         CharTypes.appendQuoted(sb, input); [EOL]         final String actual = sb.toString(); [EOL]         assertEquals(expected, actual); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAppendQuoted0_31() { [EOL]     final String[] inputs = { \"\u0000\", \"\u001F\", \"abcd\", \"\u0001ABCD\u0002\", \"WX\u000F\u0010YZ\" }; [EOL]     final String[] expecteds = { \"\\u0000\", \"\\u001F\", \"abcd\", \"\\u0001ABCD\\u0002\", \"WX\\u000F\\u0010YZ\" }; [EOL]     assert inputs.length == expecteds.length; [EOL]     for (int i = 0; i < inputs.length; i++) { [EOL]         final String input = inputs[i]; [EOL]         final String expected = expecteds[i]; [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         CharTypes.appendQuoted(sb, input); [EOL]         final String actual = sb.toString(); [EOL]         assertEquals(expected, actual); [EOL]     } [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldNameQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testFieldNameQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES); [EOL]     _testFieldNameQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES); [EOL]     _testFieldNameQuoting(jf, true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSingleQuotesDefault() throws Exception { [EOL]     _testSingleQuotesDefault(false); [EOL]     _testSingleQuotesDefault(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testOriginalMesssage() { [EOL]     JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA); [EOL]     String msg = exc.getMessage(); [EOL]     String orig = exc.getOriginalMessage(); [EOL]     assertEquals(\"Foobar\", orig); [EOL]     assertTrue(msg.length() > orig.length()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testMismatchObjectToArray() throws Exception { [EOL]     final String JSON = \"{ ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed OBJECT\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker ']': expected '}'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testRawValue() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeRawValue(\"7\"); [EOL]     gen.writeRawValue(\"[ null ]\"); [EOL]     gen.writeRawValue(\"false\"); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     JsonParser jp = createParserUsingReader(sw.toString()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(7, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCustomRootSeparatorWithFactory() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setRootValueSeparator(\"##\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeNumber(13); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeNull(); [EOL]     gen.close(); [EOL]     assertEquals(\"13##false##null\", sw.toString()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSingleQuotesDefault() throws Exception { [EOL]     _testSingleQuotesDefault(false); [EOL]     _testSingleQuotesDefault(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleInt() throws Exception { [EOL]     int EXP_I = 1234; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_I + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_I, jp.getText()); [EOL]     assertEquals(EXP_I, jp.getIntValue()); [EOL]     assertEquals((long) EXP_I, jp.getLongValue()); [EOL]     assertEquals((double) EXP_I, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail(\"Expected error trying to call getBooleanValue on non-boolean value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"not of boolean type\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIntPrinting() throws Exception { [EOL]     assertIntPrint(0); [EOL]     assertIntPrint(-3); [EOL]     assertIntPrint(1234); [EOL]     assertIntPrint(-1234); [EOL]     assertIntPrint(56789); [EOL]     assertIntPrint(-56789); [EOL]     assertIntPrint(999999); [EOL]     assertIntPrint(-999999); [EOL]     assertIntPrint(1000000); [EOL]     assertIntPrint(-1000000); [EOL]     assertIntPrint(10000001); [EOL]     assertIntPrint(-10000001); [EOL]     assertIntPrint(-100000012); [EOL]     assertIntPrint(100000012); [EOL]     assertIntPrint(1999888777); [EOL]     assertIntPrint(-1999888777); [EOL]     assertIntPrint(Integer.MAX_VALUE); [EOL]     assertIntPrint(Integer.MIN_VALUE); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 251000; ++i) { [EOL]         assertIntPrint(rnd.nextInt()); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testNullWrite() throws Exception { [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean pad = (i & 1) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeNull(); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = \"null\"; [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(JsonToken.VALUE_NULL, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals(\"567\", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals(\"123\", out.toString(\"UTF-8\")); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals(\"567\", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals(\"123\", out.toString(\"UTF-8\")); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLocationSerializability() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(\"  { }\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     JsonLocation loc = jp.getCurrentLocation(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream out = new ObjectOutputStream(bytes); [EOL]     out.writeObject(loc); [EOL]     out.close(); [EOL]     byte[] stuff = bytes.toByteArray(); [EOL]     ObjectInputStream obIn = new ObjectInputStream(new ByteArrayInputStream(stuff)); [EOL]     JsonLocation loc2 = (JsonLocation) obIn.readObject(); [EOL]     assertNotNull(loc2); [EOL]     assertEquals(loc.getLineNr(), loc2.getLineNr()); [EOL]     assertEquals(loc.getColumnNr(), loc2.getColumnNr()); [EOL]     jp.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCustomRootSeparatorWithFactory() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setRootValueSeparator(\"##\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeNumber(13); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeNull(); [EOL]     gen.close(); [EOL]     assertEquals(\"13##false##null\", sw.toString()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInterningWithReaders() throws Exception { [EOL]     _testIntern(false, true, \"c\"); [EOL]     _testIntern(false, false, \"d\"); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = \"[ 1, 2, 3, 4 ]\"; [EOL]     byte[] b = JSON.getBytes(\"UTF-8\"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testMisssingColon() throws Exception { [EOL]     final String JSON = \"{ \\"a\\" \\"b\\" }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for missing semicolon\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"was expecting a colon\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleInt() throws Exception { [EOL]     int EXP_I = 1234; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_I + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_I, jp.getText()); [EOL]     assertEquals(EXP_I, jp.getIntValue()); [EOL]     assertEquals((long) EXP_I, jp.getLongValue()); [EOL]     assertEquals((double) EXP_I, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testRawValue() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeRawValue(\"7\"); [EOL]     gen.writeRawValue(\"[ null ]\"); [EOL]     gen.writeRawValue(\"false\"); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     JsonParser jp = createParserUsingReader(sw.toString()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(7, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAutoCloseArraysAndObjects() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     jg.writeStartArray(); [EOL]     jg.close(); [EOL]     assertEquals(\"[]\", sw.toString()); [EOL]     sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.close(); [EOL]     assertEquals(\"{}\", sw.toString()); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testMisssingColon() throws Exception { [EOL]     final String JSON = \"{ \\"a\\" \\"b\\" }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for missing semicolon\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"was expecting a colon\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = \"[ 1, 2, 3, 4 ]\"; [EOL]     byte[] b = JSON.getBytes(\"UTF-8\"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = \"[\" + \"\\"LF=\\n\\"\" + \"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"LF=\n\", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = \"[\\"NULL:\\u0000!\\"]\"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"NULL:\0!\", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader(\"[\\"\\u0123\\"]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\u0123\", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader(\"[\\"\\u0041\\u0043\\"]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"AC\", jp.getText()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = \"[ 1, 2, 3, 4 ]\"; [EOL]     byte[] b = JSON.getBytes(\"UTF-8\"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testFieldNameQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testFieldNameQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES); [EOL]     _testFieldNameQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES); [EOL]     _testFieldNameQuoting(jf, true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testNullWrite() throws Exception { [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean pad = (i & 1) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeNull(); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = \"null\"; [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(JsonToken.VALUE_NULL, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail(\"Expected error trying to call getBooleanValue on non-boolean value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"not of boolean type\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals(\"567\", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals(\"123\", out.toString(\"UTF-8\")); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testNoAutoCloseOutputStream() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET); [EOL]     @SuppressWarnings(\"resource\") [EOL]     MyStream output = new MyStream(); [EOL]     JsonGenerator jg = f.createGenerator(output, JsonEncoding.UTF8); [EOL]     assertFalse(output.isClosed()); [EOL]     jg.writeNumber(39); [EOL]     jg.close(); [EOL]     assertFalse(output.isClosed()); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile(\"pre fix&stuff\", \".txt\"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\")); [EOL]     w.write(\"{ }\"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = \"[ 1, 2, 3, 4 ]\"; [EOL]     byte[] b = JSON.getBytes(\"UTF-8\"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"{  \\"field\\" : true }\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"field\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"{  \\"field\\" : true }\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"field\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEOFInName() throws Exception { [EOL]     final String JSON = \"{ \\"abcd\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for EOF\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected end-of-input\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ ]\"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"{  \\"field\\" : true }\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"field\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings(\"unused\") [EOL] public void testErrors() throws Exception { [EOL]     try { [EOL]         Base64Variant b = new Base64Variant(\"foobar\", \"xyz\", false, '!', 24); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         verifyException(iae, \"length must be exactly\"); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testSingleQuotesDefault() throws Exception { [EOL]     _testSingleQuotesDefault(false); [EOL]     _testSingleQuotesDefault(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = \"<root />\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[true]xyz\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\"xyz\", sw.toString()); [EOL]     jp.close(); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName(\"AAAA\", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals(\"AAAA\", n1.getName()); [EOL]     nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals(\"AAAABBBB\", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalid() throws Exception { [EOL]     String DOC = \"[\\"\\u41=A\\"]\"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail(\"Expected an exception for unclosed ARRAY\"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"for character escape\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWeirdToken() throws Exception { [EOL]     final String JSON = \"[ nil ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for weird token\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unrecognized token\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04\"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSyntheticWithChars() { [EOL]     CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         char[] ch = id.toCharArray(); [EOL]         symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id)); [EOL]     } [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(1401, symbols.collisionCount()); [EOL]     assertEquals(4, symbols.maxCollisionLength()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \"[ 1, 2, 3 ]\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \"UTF-8\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = \"1323372036854775807\"; [EOL]     final String OVERFLOW = \"9999999999999999999\"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testByteSymbolsWithClose() throws Exception { [EOL]     _testWithClose(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testEmptyName() throws Exception { [EOL]     final String DOC = \"{ \\"\\" : \\"\\" }\"; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"\", jp.getText()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = \"[ 1, 2 }\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, \"UTF-8\"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail(\"Expected an exception for incorrectly closed ARRAY\"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, \"Unexpected close marker '}': expected ']'\"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"{  \\"field\\" : true }\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"field\", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testCustomRootSeparatorWithPP() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"{} {} []\", _generateRoot(jf, null)); [EOL]     assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter())); [EOL]     assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\"))); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBase64UsingInputStream() throws Exception { [EOL]     _testBase64Text(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append(\"[\"); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append(\"]\"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIsNextTokenName() throws Exception { [EOL]     _testIsNextTokenName1(false); [EOL]     _testIsNextTokenName1(true); [EOL]     _testIsNextTokenName2(false); [EOL]     _testIsNextTokenName2(true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \"Bit longer text\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = \"HwdJ\"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes(\"UTF-8\"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\"\r\n\", true); [EOL]     _testLinefeeds(\"\r\n\", false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSkipping() throws Exception { [EOL]     String DOC = \"[ 1, 3, [ true, null ], 3, { \\"a\\":\\"b\\" }, [ [ ] ], { } ]\"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail(\"Expected null at end of doc, got \" + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\"[ \\"abc\\" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\"Expected error trying to call getIntValue on non-numeric value\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"can not use numeric value accessors\"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\"\t\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testNoAutoCloseOutputStream() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET); [EOL]     @SuppressWarnings(\"resource\") [EOL]     MyStream output = new MyStream(); [EOL]     JsonGenerator jg = f.createGenerator(output, JsonEncoding.UTF8); [EOL]     assertFalse(output.isClosed()); [EOL]     jg.writeNumber(39); [EOL]     jg.close(); [EOL]     assertFalse(output.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader(\"{ }\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal(\"1E+2\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"1E+2\", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals(\"100\", sw.toString()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidKeywordsStream() throws Exception { [EOL]     _testInvalidKeywords(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"{ \\"a\\":1, \\"b\\":[{ \\"c\\" : null }] }\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"a\\":1,\\"b\\":[{\\"c\\":null}]}\", sw.toString()); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\"[ 1, true ]\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\"[\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testByteSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, true); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.byteSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.byteSymbolCount()); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }
public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\n\"); [EOL]     assertEquals(\"\\n\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \"\u0000\"); [EOL]     assertEquals(\"\\u0000\", sb.toString()); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = \"/* \u00a9 2099 Yoyodyne Inc. */\n [ \\"bar? \u00a9\\" ]\n\"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField(\"str\", null); [EOL]     gen.writeNumberField(\"num\", null); [EOL]     gen.writeObjectField(\"obj\", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"num\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"obj\", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testPackageVersionMatches() { [EOL]     assertEquals(PackageVersion.VERSION, VersionUtil.versionFor(UTF8JsonGenerator.class)); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString(\"id\"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write(\"\\"id\\":2\".getBytes(\"UTF-8\")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testAppending() throws IOException { [EOL]     final String INPUT = \"\\"quo\\ted\\"\"; [EOL]     final String QUOTED = \"\\\\"quo\\\\ted\\\\"\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     assertEquals(sstr.getValue(), INPUT); [EOL]     assertEquals(QUOTED, new String(sstr.asQuotedChars())); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     assertEquals(QUOTED.length(), sstr.writeQuotedUTF8(bytes)); [EOL]     assertEquals(QUOTED, bytes.toString(\"UTF-8\")); [EOL]     bytes.reset(); [EOL]     assertEquals(INPUT.length(), sstr.writeUnquotedUTF8(bytes)); [EOL]     assertEquals(INPUT, bytes.toString(\"UTF-8\")); [EOL]     byte[] buffer = new byte[100]; [EOL]     assertEquals(QUOTED.length(), sstr.appendQuotedUTF8(buffer, 3)); [EOL]     assertEquals(QUOTED, new String(buffer, 3, QUOTED.length())); [EOL]     Arrays.fill(buffer, (byte) 0); [EOL]     assertEquals(INPUT.length(), sstr.appendUnquotedUTF8(buffer, 5)); [EOL]     assertEquals(INPUT, new String(buffer, 5, INPUT.length())); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\")); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\"Expected an exception for mismatched array/object write\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \"Current context not an array\"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader(\"[ \" + EXP_L + \" ]\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals(\"\" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, \"out of range\"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\"\u65e5\u672c\u8a9e\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals(\"567\", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals(\"123\", out.toString(\"UTF-8\")); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = \"{\\"x\\":{\\"a\\":1,\\"b\\":2(2)}(1)}\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\"x\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\"a\", 1); [EOL]         gen.writeNumberField(\"b\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\"long\", 3L); [EOL]     gen.writeNumberField(\"double\", 0.25); [EOL]     gen.writeNumberField(\"float\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\"{\\"long\\":3,\\"double\\":0.25,\\"float\\":-0.25}\", sw.toString().trim()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"\\"text\\non two lines\\" true false 2.0\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"\\"text\\non two lines\\" true false 2.0\", sw.toString()); [EOL] }
public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLargeUnquoted() throws Exception { [EOL]     _testLargeUnquoted(false); [EOL]     _testLargeUnquoted(true); [EOL] }
public void testNonNumericQuoting() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testNonNumericQuoting(jf, true); [EOL]     jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, false); [EOL]     jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL]     _testNonNumericQuoting(jf, true); [EOL] }
public void testEscapeCustomWithReader() throws Exception { [EOL]     _testEscapeCustom(false); [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \"{\\"simple\\":[1,true,{}]}\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5); [EOL]     byte[] second = \"FGHIJ\".getBytes(\"UTF-8\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \"123 [ 1, null, [ false ] ]\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\"123 [1,null,[false]]\", sw.toString()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\"c\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\"abc\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = \"[6,[1,2,9(3)](2)]\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testCtrlChars() throws Exception { [EOL]     char[] input = new char[] { 0, 1, 2, 3, 4 }; [EOL]     char[] quoted = JsonStringEncoder.getInstance().quoteAsString(new String(input)); [EOL]     assertEquals(\"\\u0000\\u0001\\u0002\\u0003\\u0004\", new String(quoted)); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal(\"0.1\"); [EOL]     final String TEXT = \"\\"some\nString!\\"\"; [EOL]     gen.writeNullField(\"null\"); [EOL]     gen.writeBooleanField(\"bt\", true); [EOL]     gen.writeBooleanField(\"bf\", false); [EOL]     gen.writeNumberField(\"int\", -1289); [EOL]     gen.writeNumberField(\"dec\", dec); [EOL]     gen.writeObjectFieldStart(\"ob\"); [EOL]     gen.writeStringField(\"str\", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart(\"arr\"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"null\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bt\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"bf\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"int\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"dec\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"ob\", jp.getText()); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"str\", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(TEXT, getAndVerifyText(jp)); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals(\"arr\", jp.getText()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testAsDouble() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17.25\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(9.0, jp.getValueAsDouble(9.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1., jp.getValueAsDouble()); [EOL]         assertEquals(1., jp.getValueAsDouble(-99.0)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3., jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4.98, jp.getValueAsDouble()); [EOL]         assertEquals(4.98, jp.getValueAsDouble(12.5)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(0.0, jp.getValueAsDouble(27.8)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble()); [EOL]         assertEquals(-17.25, jp.getValueAsDouble(1.9)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(1.25, jp.getValueAsDouble(1.25)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0.0, jp.getValueAsDouble()); [EOL]         assertEquals(7.5, jp.getValueAsDouble(7.5)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = \"[ true, false, null, 1, 0, \\"true\\", \\"false\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\"UTF-8\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \"{ \\"a\\" : 1, \\"x\\" : [ ] }\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull(\"Document \\"\" + bout.toString(\"UTF-8\") + \"\\" yielded no tokens\", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \"X\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \"\" + letter + index; [EOL]                     } else { [EOL]                         name = \"__\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \"AB\u00A0\u1AE9\uFFFC\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\"UTF-8\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile(\"jackson-test\", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw(\"   \"); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
@SuppressWarnings(\"resource\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\" xyz foo\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\" and \\"bar\\"\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\" [whatever].... \"); [EOL]         } else { [EOL]             sb.append(\" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append(\"\r\n\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\"doc\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\"UTF-8\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\"Expected length \" + VALUE.length() + \", got \" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\"Long text differs\"); [EOL]         } [EOL]         assertEquals(\"doc\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { \"a\", \"foobar\", \"p\u00f6ll\u00f6\", \"\\"foo\\"\", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testBooleanWrite() throws Exception { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         boolean state = (i & 1) == 0; [EOL]         boolean pad = (i & 2) == 0; [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]         gen.writeBoolean(state); [EOL]         if (pad) { [EOL]             gen.writeRaw(\" \"); [EOL]         } [EOL]         gen.close(); [EOL]         String docStr = sw.toString(); [EOL]         JsonParser jp = createParserUsingReader(docStr); [EOL]         JsonToken t = jp.nextToken(); [EOL]         String exp = Boolean.valueOf(state).toString(); [EOL]         if (!exp.equals(jp.getText())) { [EOL]             fail(\"Expected '\" + exp + \"', got '\" + jp.getText()); [EOL]         } [EOL]         assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t); [EOL]         assertEquals(null, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = \"[\" + STR + \"]\"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, \"UTF-8\"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\"'); [EOL]         sb2.append(\"\\\\"\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testCharSymbolsWithEOF() throws Exception { [EOL]     MyJsonFactory f = new MyJsonFactory(); [EOL]     JsonParser jp = _getParser(f, JSON, false); [EOL]     while (jp.nextToken() != null) { [EOL]         assertEquals(0, f.charSymbolCount()); [EOL]     } [EOL]     assertEquals(3, f.charSymbolCount()); [EOL]     jp.close(); [EOL]     assertEquals(3, f.charSymbolCount()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\"[\\"1\\",\\"2\\",\\"1.25\\",\\"2.25\\",\\"3001\\",\\"0.5\\",\\"-1\\"]\", _writeNumbers(jf)); [EOL] }
public void testFlushAfterClose() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     w.write('X'); [EOL]     w.close(); [EOL]     assertEquals(1, out.size()); [EOL]     w.flush(); [EOL]     w.close(); [EOL]     w.flush(); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[1234,0.5]\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\"[false,13,-127]\", act); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \"\\"JSON!\\"\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\"JSON\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\"JSON!\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = \"[ 1, -3, 4.98, true, false, null, \\"-17\\", \\"foo\\" ]\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \"UTF-8\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }