{"code": "public void testRootUsingExplicitConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer().withRootName(\\\"wrapper\\\"); [EOL]     String json = writer.writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"wrapper\\\\\":{\\\\\"a\\\\\":3}}\\\", json); [EOL]     ObjectReader reader = mapper.reader(Bean.class).withRootName(\\\"wrapper\\\"); [EOL]     Bean bean = reader.readValue(json); [EOL]     assertNotNull(bean); [EOL]     ObjectMapper wrapping = rootMapper(); [EOL]     json = wrapping.writer().withRootName(\\\"something\\\").writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"something\\\\\":{\\\\\"a\\\\\":3}}\\\", json); [EOL]     json = wrapping.writer().withRootName(\\\"\\\").writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":3}\\\", json); [EOL]     bean = wrapping.reader(Bean.class).withRootName(\\\"\\\").readValue(json); [EOL]     assertNotNull(bean); [EOL] }", "nl": "[LINE] _nodeFactory = src._nodeFactory; [LINE] private DeserializationConfig(DeserializationConfig src, String rootName) { [EOL]     super(src, rootName); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = src._problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] } public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private DeserializationConfig(DeserializationConfig src, SubtypeResolver str); private DeserializationConfig(DeserializationConfig src, int mapperFeatures, int deserFeatures); private DeserializationConfig(DeserializationConfig src, BaseSettings base); private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f); private DeserializationConfig(DeserializationConfig src, LinkedNode<DeserializationProblemHandler> problemHandlers); private DeserializationConfig(DeserializationConfig src, String rootName); private DeserializationConfig(DeserializationConfig src, Class<?> view); protected DeserializationConfig(DeserializationConfig src, Map<ClassKey, Class<?>> mixins); protected BaseSettings getBaseSettings(); public DeserializationConfig with(MapperFeature... features); public DeserializationConfig without(MapperFeature... features); public DeserializationConfig with(ClassIntrospector ci); public DeserializationConfig with(AnnotationIntrospector ai); public DeserializationConfig with(VisibilityChecker<?> vc); public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public DeserializationConfig with(TypeResolverBuilder<?> trb); public DeserializationConfig with(SubtypeResolver str); public DeserializationConfig with(PropertyNamingStrategy pns); public DeserializationConfig withRootName(String rootName); public DeserializationConfig with(TypeFactory tf); public DeserializationConfig with(DateFormat df); public DeserializationConfig with(HandlerInstantiator hi); public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withView(Class<?> view); public DeserializationConfig with(Locale l); public DeserializationConfig with(TimeZone tz); public DeserializationConfig with(Base64Variant base64); private final DeserializationConfig _withBase(BaseSettings newBase); public DeserializationConfig with(JsonNodeFactory f); public DeserializationConfig withHandler(DeserializationProblemHandler h); public DeserializationConfig withNoProblemHandlers(); public DeserializationConfig with(DeserializationFeature feature); public DeserializationConfig with(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withFeatures(DeserializationFeature... features); public DeserializationConfig without(DeserializationFeature feature); public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withoutFeatures(DeserializationFeature... features); public AnnotationIntrospector getAnnotationIntrospector(); public boolean useRootWrapping(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(DeserializationFeature f); public final int getDeserializationFeatures(); public LinkedNode<DeserializationProblemHandler> getProblemHandlers(); public final JsonNodeFactory getNodeFactory(); public T introspect(JavaType type); public T introspectForCreation(JavaType type); public T introspectForBuilder(JavaType type); long serialVersionUID=Optional[-4227480407273773599L]; int _deserFeatures; LinkedNode<DeserializationProblemHandler> _problemHandlers; JsonNodeFactory _nodeFactory"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] if (!jp.isExpectedStartArrayToken()) { [LINE] @Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] } public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator); protected StringCollectionDeserializer(JavaType collectionType, ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser); protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser); public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException; private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt, Collection<String> result, final JsonDeserializer<String> deser) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; JavaType _collectionType; JsonDeserializer<String> _valueDeserializer; ValueInstantiator _valueInstantiator; JsonDeserializer<Object> _delegateDeserializer"}
{"code": "public void testAnnotationsDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     AnnoBean bean = m.readValue(\\\"{ \\\\\"y\\\\\" : 0 }\\\", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     bean = m.readValue(\\\"{ \\\\\"x\\\\\" : 0 }\\\", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL] }", "nl": "[LINE] return null; [LINE] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     return null; [EOL] } public ReferenceProperty(Type t, String n); public Pair(AnnotationIntrospector p, AnnotationIntrospector s); public static ReferenceProperty managed(String name); public static ReferenceProperty back(String name); public Type getType(); public String getName(); public boolean isManagedReference(); public boolean isBackReference(); public static AnnotationIntrospector nopInstance(); public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2); public Collection<AnnotationIntrospector> allIntrospectors(); public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result); public abstract Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Class<?>[] findViews(Annotated a); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated memberOrClass); public Boolean isTypeId(AnnotatedMember member); public PropertyName findWrapperName(Annotated ann); public Object findSerializer(Annotated am); public Object findKeySerializer(Annotated am); public Object findContentSerializer(Annotated am); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated a); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedMethod am); public String findSerializationName(AnnotatedField af); public boolean hasAsValueAnnotation(AnnotatedMethod am); public String findEnumValue(Enum<?> value); public Object findDeserializer(Annotated am); public Object findKeyDeserializer(Annotated am); public Object findContentDeserializer(Annotated am); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a)"}
{"code": "public void testBrokenWithDoubleAnnotations() throws Exception { [EOL]     try { [EOL]         @SuppressWarnings(\\\"unused\\\") [EOL]         Broken b = MAPPER.readValue(\\\"{ \\\\\"a\\\\\" : 3 }\\\", Broken.class); [EOL]         fail(\\\"Should have gotten an exception\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Multiple 'any-setters'\\\"); [EOL]     } [EOL] }", "nl": "[LINE] reportProblem(\\\"Multiple 'any-setters' defined (\\\"+_anySetters.get(0)+\\\" vs \\\" [LINE] public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem(\\\"Multiple 'any-setters' defined (\\\" + _anySetters.get(0) + \\\" vs \\\" + _anySetters.get(1) + \\\")\\\"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testInnerClassWithAnnotationsInCreator() throws Exception { [EOL]     BasicBeanDescription beanDesc; [EOL]     beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Issue701Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL]     beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue701Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL] }", "nl": "[LINE] _creatorProperties.add(prop); [LINE] protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] private boolean doesImplement(Class<?> actualType, String classNameToImplement) [LINE] private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected OptionalHandlerFactory(); public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc); public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; private Object instantiate(String className); private boolean doesImplement(Class<?> actualType, String classNameToImplement); private boolean hasInterface(Class<?> type, String interfaceToImplement); private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix); private boolean hasInterfaceStartingWith(Class<?> type, String prefix); long serialVersionUID=Optional[1]; String PACKAGE_PREFIX_JAVAX_XML=Optional[\\\"javax.xml.\\\"]; String SERIALIZERS_FOR_JAVAX_XML=Optional[\\\"com.fasterxml.jackson.databind.ext.CoreXMLSerializers\\\"]; String DESERIALIZERS_FOR_JAVAX_XML=Optional[\\\"com.fasterxml.jackson.databind.ext.CoreXMLDeserializers\\\"]; String CLASS_NAME_DOM_NODE=Optional[\\\"org.w3c.dom.Node\\\"]; String CLASS_NAME_DOM_DOCUMENT=Optional[\\\"org.w3c.dom.Node\\\"]; String SERIALIZER_FOR_DOM_NODE=Optional[\\\"com.fasterxml.jackson.databind.ext.DOMSerializer\\\"]; String DESERIALIZER_FOR_DOM_DOCUMENT=Optional[\\\"com.fasterxml.jackson.databind.ext.DOMDeserializer$DocumentDeserializer\\\"]; String DESERIALIZER_FOR_DOM_NODE=Optional[\\\"com.fasterxml.jackson.databind.ext.DOMDeserializer$NodeDeserializer\\\"]; OptionalHandlerFactory instance=Optional[new OptionalHandlerFactory()]"}
{"code": "public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\\\"c3VyZS4=\\\", byte[].class); [EOL]     byte[] exp = \\\"sure.\\\".getBytes(\\\"Ascii\\\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }", "nl": "[LINE] if (cdDef != null) { [LINE] private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, \\\"findContentDeserializer\\\", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] } public DeserializerCache();  Object writeReplace(); public int cachedDeserializersCount(); public void flushCachedDeserializers(); public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException; public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type); protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type); protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException; protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException; private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException; private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException; protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException; long serialVersionUID=Optional[1L]; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2)]; HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers=Optional[new HashMap<JavaType, JsonDeserializer<Object>>(8)]"}
{"code": "public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(\\\"[{\\\\\"doggy\\\\\":{\\\\\"name\\\\\":\\\\\"Spot\\\\\",\\\\\"ageInYears\\\\\":3}}]\\\", m.writeValueAsString(new Animal[] { new Dog(\\\"Spot\\\", 3) })); [EOL]     assertEquals(\\\"[{\\\\\"MaineCoon\\\\\":{\\\\\"name\\\\\":\\\\\"Belzebub\\\\\",\\\\\"purrs\\\\\":true}}]\\\", m.writeValueAsString(new Animal[] { new MaineCoon(\\\"Belzebub\\\", true) })); [EOL] }", "nl": "[LINE] public FloatArraySerializer() { [LINE] public FloatArraySerializer() { [EOL]     super(float[].class); [EOL] } protected StdArraySerializers(); protected TypedPrimitiveArraySerializer(Class<T> cls); protected TypedPrimitiveArraySerializer(TypedPrimitiveArraySerializer<T> src, BeanProperty prop, TypeSerializer vts); public BooleanArraySerializer(); public ByteArraySerializer(); public ShortArraySerializer(); public ShortArraySerializer(ShortArraySerializer src, BeanProperty prop, TypeSerializer vts); public CharArraySerializer(); public IntArraySerializer(); public LongArraySerializer(); public LongArraySerializer(LongArraySerializer src, BeanProperty prop, TypeSerializer vts); public FloatArraySerializer(); public FloatArraySerializer(FloatArraySerializer src, BeanProperty prop, TypeSerializer vts); public DoubleArraySerializer(); public static JsonSerializer<?> findStandardImpl(Class<?> cls); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(boolean[] value); public boolean hasSingleElement(boolean[] value); public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public boolean isEmpty(byte[] value); public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(short[] value); public boolean hasSingleElement(short[] value); public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public boolean isEmpty(char[] value); public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(char[] value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(int[] value); public boolean hasSingleElement(int[] value); public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(long[] value); public boolean hasSingleElement(long[] value); public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(float[] value); public boolean hasSingleElement(float[] value); public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(double[] value); public boolean hasSingleElement(double[] value); public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; HashMap<String, JsonSerializer<?>> _arraySerializers=Optional[new HashMap<String, JsonSerializer<?>>()]"}
{"code": "public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes(\\\"<POJO><x>1</x></POJO>\\\")); [EOL]         fail(\\\"Should have failed\\\"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, \\\"Can not detect format from input\\\"); [EOL]     } [EOL] }", "nl": "[LINE] public boolean hasMatch() { return _match != null; } [LINE] public boolean hasMatch() { [EOL]     return _match != null; [EOL] } public DataFormatReaders(ObjectReader... detectors); public DataFormatReaders(Collection<ObjectReader> detectors); private DataFormatReaders(ObjectReader[] detectors, MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead); public AccessorForReader(InputStream in, byte[] buffer); public AccessorForReader(byte[] inputDocument); public AccessorForReader(byte[] inputDocument, int start, int len); protected Match(InputStream in, byte[] buffered, int bufferedStart, int bufferedLength, ObjectReader match, MatchStrength strength); public DataFormatReaders withOptimalMatch(MatchStrength optMatch); public DataFormatReaders withMinimalMatch(MatchStrength minMatch); public DataFormatReaders with(ObjectReader[] readers); public DataFormatReaders withMaxInputLookahead(int lookaheadBytes); public DataFormatReaders with(DeserializationConfig config); public DataFormatReaders withType(JavaType type); public Match findFormat(InputStream in) throws IOException; public Match findFormat(byte[] fullInputData) throws IOException; public Match findFormat(byte[] fullInputData, int offset, int len) throws IOException; public String toString(); private Match _findFormat(AccessorForReader acc) throws IOException; public Match createMatcher(ObjectReader match, MatchStrength matchStrength); public boolean hasMatch(); public MatchStrength getMatchStrength(); public ObjectReader getReader(); public String getMatchedFormatName(); public JsonParser createParserWithMatch() throws IOException; public InputStream getDataStream(); int DEFAULT_MAX_INPUT_LOOKAHEAD=Optional[64]; ObjectReader[] _readers; MatchStrength _optimalMatch; MatchStrength _minimalMatch; int _maxInputLookahead"}
{"code": "public void testLeafMixin() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Object> result; [EOL]     BaseClass bean = new BaseClass(\\\"a1\\\", \\\"b2\\\"); [EOL]     result = writeAndMap(mapper, bean); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\\\"b2\\\", result.get(\\\"b\\\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(BaseClass.class, MixIn.class); [EOL]     result = writeAndMap(mapper, bean); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(\\\"b2\\\", result.get(\\\"b2\\\")); [EOL]     assertEquals(\\\"a1\\\", result.get(\\\"a\\\")); [EOL] }", "nl": "[LINE] Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [LINE] private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations); public AnnotatedClass withAnnotations(AnnotationMap ann); public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public Class<?> getAnnotated(); public int getModifiers(); public String getName(); public A getAnnotation(Class<A> acls); public Type getGenericType(); public Class<?> getRawType(); protected AnnotationMap getAllAnnotations(); public Annotations getAnnotations(); public boolean hasAnnotations(); public AnnotatedConstructor getDefaultConstructor(); public List<AnnotatedConstructor> getConstructors(); public List<AnnotatedMethod> getStaticMethods(); public Iterable<AnnotatedMethod> memberMethods(); public int getMemberMethodCount(); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public int getFieldCount(); public Iterable<AnnotatedField> fields(); private void resolveClassAnnotations(); private void resolveCreators(); private void resolveMemberMethods(); private void resolveFields(); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin); protected void _addConstructorMixIns(Class<?> mixin); protected void _addFactoryMixIns(Class<?> mixin); protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields); protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields); protected AnnotatedMethod _constructMethod(Method m); protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor); protected AnnotatedMethod _constructCreatorMethod(Method m); protected AnnotatedField _constructField(Field f); private AnnotationMap _emptyAnnotationMap(); private AnnotationMap[] _emptyAnnotationMaps(int count); protected boolean _isIncludableMemberMethod(Method m); private boolean _isIncludableField(Field f); protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns); protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns); private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns); protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations); protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations); protected void _addMixUnders(Method src, AnnotatedMethod target); private final boolean _isAnnotationBundle(Annotation ann); public String toString(); AnnotationMap[] NO_ANNOTATION_MAPS=Optional[new AnnotationMap[0]]; Class<?> _class; List<Class<?>> _superTypes; AnnotationIntrospector _annotationIntrospector; MixInResolver _mixInResolver; Class<?> _primaryMixIn; AnnotationMap _classAnnotations; boolean _creatorsResolved=Optional[false]; AnnotatedConstructor _defaultConstructor; List<AnnotatedConstructor> _constructors; List<AnnotatedMethod> _creatorMethods; AnnotatedMethodMap _memberMethods; List<AnnotatedField> _fields"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\\\"num\\\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] copyCurrentStructure(jp); [LINE] @Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add(\\\"xyz\\\"); [EOL]     assertEquals(quote(\\\"xyz\\\"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals(\\\"13\\\", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals(\\\"42\\\", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = \\\"{\\\\\"values\\\\\":\\\\\"foo\\\\\"}\\\"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList(\\\"foo\\\")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add(\\\"foo\\\"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals(\\\"true\\\", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals(\\\"true\\\", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals(\\\"3\\\", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote(\\\"foo\\\"), writer.writeValueAsString(new String[] { \\\"foo\\\" })); [EOL] }", "nl": "[LINE] return; [LINE] @Override [EOL] public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] } protected StringCollectionSerializer(); protected StringCollectionSerializer(JsonSerializer<?> ser); protected JsonNode contentSchema(); protected void acceptContentVisitor(JsonArrayFormatVisitor visitor) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private final void _serializeUnwrapped(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private void serializeUsingCustom(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; StringCollectionSerializer instance=Optional[new StringCollectionSerializer()]; JsonSerializer<String> _serializer"}
{"code": "public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"abc:\\\")); [EOL]     MyMap map = mapper.readValue(\\\"{\\\\\"a\\\\\":\\\\\"b\\\\\"}\\\", MyMap.class); [EOL]     assertEquals(\\\"{\\\\\"KEY\\\\\":\\\\\"b\\\\\"}\\\", mapper.writeValueAsString(map)); [EOL] }", "nl": "[LINE] if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [LINE] @Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned key deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\\\"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<KeyDeserializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] } protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory); public Impl(DeserializerFactory df); protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected Impl(Impl src, DeserializerFactory factory); public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract DefaultDeserializationContext with(DeserializerFactory factory); public abstract DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext with(DeserializerFactory factory); long serialVersionUID=Optional[1L]; LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount]; [LINE] protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) { [EOL]     List<BeanPropertyWriter> props = builder.getProperties(); [EOL]     boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL]     final int propCount = props.size(); [EOL]     int viewsFound = 0; [EOL]     BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount]; [EOL]     for (int i = 0; i < propCount; ++i) { [EOL]         BeanPropertyWriter bpw = props.get(i); [EOL]         Class<?>[] views = bpw.getViews(); [EOL]         if (views == null) { [EOL]             if (includeByDefault) { [EOL]                 filtered[i] = bpw; [EOL]             } [EOL]         } else { [EOL]             ++viewsFound; [EOL]             filtered[i] = constructFilteredBeanWriter(bpw, views); [EOL]         } [EOL]     } [EOL]     if (includeByDefault && viewsFound == 0) { [EOL]         return; [EOL]     } [EOL]     builder.setFilteredProperties(filtered); [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get(\\\"value\\\"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get(\\\"x\\\")); [EOL] }", "nl": "[LINE] Object value1 = deserialize(jp, ctxt); [LINE] protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] } public UntypedObjectDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Object[] NO_OBJECTS=Optional[new Object[0]]; UntypedObjectDeserializer instance=Optional[new UntypedObjectDeserializer()]"}
{"code": "public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\\\"a\\\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":{\\\\\"a\\\\\":3}}\\\", listJson); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] } protected SimpleType(Class<?> cls); protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic); public static SimpleType constructUnsafe(Class<?> raw); protected JavaType _narrow(Class<?> subclass); public JavaType narrowContentsBy(Class<?> subclass); public JavaType widenContentsBy(Class<?> subclass); public static SimpleType construct(Class<?> cls); public SimpleType withTypeHandler(Object h); public JavaType withContentTypeHandler(Object h); public SimpleType withValueHandler(Object h); public SimpleType withContentValueHandler(Object h); public SimpleType withStaticTyping(); protected String buildCanonicalName(); public boolean isContainerType(); public int containedTypeCount(); public JavaType containedType(int index); public String containedTypeName(int index); public StringBuilder getErasedSignature(StringBuilder sb); public StringBuilder getGenericSignature(StringBuilder sb); public String toString(); public boolean equals(Object o); long serialVersionUID=Optional[-800374828948534376L]; JavaType[] _typeParameters; String[] _typeNames"}
{"code": "public void testCharArrays() throws IOException { [EOL]     char[] chars = new char[] { 'a', 'b', 'c' }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(quote(\\\"abc\\\"), m.writeValueAsString(chars)); [EOL]     m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true); [EOL]     assertEquals(\\\"[\\\\\"a\\\\\",\\\\\"b\\\\\",\\\\\"c\\\\\"]\\\", m.writeValueAsString(chars)); [EOL] }", "nl": "[LINE] for (int i = 0, len = value.length; i < len; ++i) { [LINE] private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeString(value, i, 1); [EOL]     } [EOL] } protected StdArraySerializers(); protected TypedPrimitiveArraySerializer(Class<T> cls); protected TypedPrimitiveArraySerializer(TypedPrimitiveArraySerializer<T> src, BeanProperty prop, TypeSerializer vts); public BooleanArraySerializer(); public ByteArraySerializer(); public ShortArraySerializer(); public ShortArraySerializer(ShortArraySerializer src, BeanProperty prop, TypeSerializer vts); public CharArraySerializer(); public IntArraySerializer(); public LongArraySerializer(); public LongArraySerializer(LongArraySerializer src, BeanProperty prop, TypeSerializer vts); public FloatArraySerializer(); public FloatArraySerializer(FloatArraySerializer src, BeanProperty prop, TypeSerializer vts); public DoubleArraySerializer(); public static JsonSerializer<?> findStandardImpl(Class<?> cls); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(boolean[] value); public boolean hasSingleElement(boolean[] value); public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public boolean isEmpty(byte[] value); public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(short[] value); public boolean hasSingleElement(short[] value); public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public boolean isEmpty(char[] value); public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(char[] value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(int[] value); public boolean hasSingleElement(int[] value); public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(long[] value); public boolean hasSingleElement(long[] value); public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(float[] value); public boolean hasSingleElement(float[] value); public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(double[] value); public boolean hasSingleElement(double[] value); public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; HashMap<String, JsonSerializer<?>> _arraySerializers=Optional[new HashMap<String, JsonSerializer<?>>()]"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] String name = null; [LINE] protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [LINE] protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\\\"num\\\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] break; [LINE] public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { [EOL]     Segment segment = _first; [EOL]     int ptr = -1; [EOL]     while (true) { [EOL]         if (++ptr >= Segment.TOKENS_PER_SEGMENT) { [EOL]             ptr = 0; [EOL]             segment = segment.next(); [EOL]             if (segment == null) [EOL]                 break; [EOL]         } [EOL]         JsonToken t = segment.type(ptr); [EOL]         if (t == null) [EOL]             break; [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 jgen.writeStartObject(); [EOL]                 break; [EOL]             case END_OBJECT: [EOL]                 jgen.writeEndObject(); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 jgen.writeStartArray(); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 jgen.writeEndArray(); [EOL]                 break; [EOL]             case FIELD_NAME: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeFieldName((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeFieldName((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeString((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeString((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_INT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Integer) { [EOL]                         jgen.writeNumber((Integer) n); [EOL]                     } else if (n instanceof BigInteger) { [EOL]                         jgen.writeNumber((BigInteger) n); [EOL]                     } else if (n instanceof Long) { [EOL]                         jgen.writeNumber((Long) n); [EOL]                     } else if (n instanceof Short) { [EOL]                         jgen.writeNumber((Short) n); [EOL]                     } else { [EOL]                         jgen.writeNumber(((Number) n).intValue()); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Double) { [EOL]                         jgen.writeNumber(((Double) n).doubleValue()); [EOL]                     } else if (n instanceof BigDecimal) { [EOL]                         jgen.writeNumber((BigDecimal) n); [EOL]                     } else if (n instanceof Float) { [EOL]                         jgen.writeNumber(((Float) n).floatValue()); [EOL]                     } else if (n == null) { [EOL]                         jgen.writeNull(); [EOL]                     } else if (n instanceof String) { [EOL]                         jgen.writeNumber((String) n); [EOL]                     } else { [EOL]                         throw new JsonGenerationException(\\\"Unrecognized value type for VALUE_NUMBER_FLOAT: \\\" + n.getClass().getName() + \\\", can not serialize\\\"); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_TRUE: [EOL]                 jgen.writeBoolean(true); [EOL]                 break; [EOL]             case VALUE_FALSE: [EOL]                 jgen.writeBoolean(false); [EOL]                 break; [EOL]             case VALUE_NULL: [EOL]                 jgen.writeNull(); [EOL]                 break; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 jgen.writeObject(segment.get(ptr)); [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException(\\\"Internal error: should never end up through this code path\\\"); [EOL]         } [EOL]     } [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] char lower = Character.toLowerCase(upper); [LINE] protected static String manglePropertyName(String basename) { [EOL]     int len = basename.length(); [EOL]     if (len == 0) { [EOL]         return null; [EOL]     } [EOL]     StringBuilder sb = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char upper = basename.charAt(i); [EOL]         char lower = Character.toLowerCase(upper); [EOL]         if (upper == lower) { [EOL]             break; [EOL]         } [EOL]         if (sb == null) { [EOL]             sb = new StringBuilder(basename); [EOL]         } [EOL]         sb.setCharAt(i, lower); [EOL]     } [EOL]     return (sb == null) ? basename : sb.toString(); [EOL] } public static String okNameForGetter(AnnotatedMethod am); public static String okNameForRegularGetter(AnnotatedMethod am, String name); public static String okNameForIsGetter(AnnotatedMethod am, String name); public static String okNameForSetter(AnnotatedMethod am); public static String okNameForMutator(AnnotatedMethod am, String prefix); protected static boolean isCglibGetCallbacks(AnnotatedMethod am); protected static boolean isGroovyMetaClassSetter(AnnotatedMethod am); protected static boolean isGroovyMetaClassGetter(AnnotatedMethod am); protected static String manglePropertyName(String basename)"}
{"code": "public void testSuperInterfaces() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { BaseInt.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }", "nl": "[LINE] return; [LINE] private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] } private EnumTypeLocator(); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result); private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself); public static String canBeABeanType(Class<?> type); public static String isLocalType(Class<?> type, boolean allowNonStatic); public static Class<?> getOuterClass(Class<?> type); public static boolean isProxyType(Class<?> type); public static boolean isConcrete(Class<?> type); public static boolean isConcrete(Member member); public static boolean isCollectionMapOrArray(Class<?> type); public static String getClassDescription(Object classOrInstance); public static Class<?> findClass(String className) throws ClassNotFoundException; public static boolean hasGetterSignature(Method m); public static Throwable getRootCause(Throwable t); public static void throwRootCause(Throwable t) throws Exception; public static void throwAsIAE(Throwable t); public static void throwAsIAE(Throwable t, String msg); public static void unwrapAndThrowAsIAE(Throwable t); public static void unwrapAndThrowAsIAE(Throwable t, String msg); public static T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Object defaultValue(Class<?> cls); public static Class<?> wrapperType(Class<?> primitiveType); public static void checkAndFixAccess(Member member); public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s); public static Class<? extends Enum<?>> findEnumType(EnumMap<?, ?> m); public static Class<? extends Enum<?>> findEnumType(Enum<?> en); public static Class<? extends Enum<?>> findEnumType(Class<?> cls); public static boolean isJacksonStdImpl(Object impl); public static boolean isJacksonStdImpl(Class<?> implClass); public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set); public Class<? extends Enum<?>> enumTypeFor(EnumMap<?, ?> set); private Object get(Object bean, Field field); private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, \\\"maybe\\\"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals(\\\"maybe\\\", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }", "nl": "[LINE] sb.append('<'); [LINE] @Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_keyType != null) { [EOL]         sb.append('<'); [EOL]         sb.append(_keyType.toCanonical()); [EOL]         sb.append(','); [EOL]         sb.append(_valueType.toCanonical()); [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] } protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic); public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT); protected JavaType _narrow(Class<?> subclass); public JavaType narrowContentsBy(Class<?> contentClass); public JavaType widenContentsBy(Class<?> contentClass); public JavaType narrowKey(Class<?> keySubclass); public JavaType widenKey(Class<?> keySubclass); public MapLikeType withTypeHandler(Object h); public MapLikeType withContentTypeHandler(Object h); public MapLikeType withValueHandler(Object h); public MapLikeType withContentValueHandler(Object h); public MapLikeType withStaticTyping(); protected String buildCanonicalName(); public boolean isContainerType(); public boolean isMapLikeType(); public JavaType getKeyType(); public JavaType getContentType(); public int containedTypeCount(); public JavaType containedType(int index); public String containedTypeName(int index); public StringBuilder getErasedSignature(StringBuilder sb); public StringBuilder getGenericSignature(StringBuilder sb); public MapLikeType withKeyTypeHandler(Object h); public MapLikeType withKeyValueHandler(Object h); public boolean isTrueMapType(); public String toString(); public boolean equals(Object o); long serialVersionUID=Optional[416067702302823522L]; JavaType _keyType; JavaType _valueType"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] int len = _argTypes.length; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public MemberKey(Method m); public MemberKey(Constructor<?> ctor); public MemberKey(String name, Class<?>[] argTypes); public String toString(); public int hashCode(); public boolean equals(Object o); Class<?>[] NO_CLASSES=Optional[new Class<?>[0]]; String _name; Class<?>[] _argTypes"}
{"code": "public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, \\\"stuffValue\\\").addValue(\\\"myId\\\", \\\"xyz\\\").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue(\\\"{\\\\\"value\\\\\":3}\\\", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals(\\\"stuffValue\\\", bean.stuff); [EOL]     assertEquals(\\\"xyz\\\", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }", "nl": "[LINE] for (ValueInjector injector : _injectables) { [LINE] protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (ValueInjector injector : _injectables) { [EOL]         injector.inject(ctxt, bean); [EOL]     } [EOL] } protected BeanDeserializerBase(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews); protected BeanDeserializerBase(BeanDeserializerBase src); protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown); protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper); public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir); public BeanDeserializerBase(BeanDeserializerBase src, HashSet<String> ignorableProps); public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir); public abstract BeanDeserializerBase withIgnorableProperties(HashSet<String> ignorableProps); protected abstract BeanDeserializerBase asArrayDeserializer(); public void resolve(DeserializationContext ctxt) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, SettableBeanProperty prop) throws JsonMappingException; public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop); protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop); protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop); public boolean isCachable(); public ObjectIdReader getObjectIdReader(); public boolean hasProperty(String propertyName); public boolean hasViews(); public int getPropertyCount(); public Collection<Object> getKnownPropertyNames(); public final Class<?> getBeanClass(); public JavaType getValueType(); public Iterator<SettableBeanProperty> properties(); public Iterator<SettableBeanProperty> creatorProperties(); public SettableBeanProperty findProperty(String propertyName); public SettableBeanProperty findBackReference(String logicalName); public ValueInstantiator getValueInstantiator(); public void replaceProperty(SettableBeanProperty original, SettableBeanProperty replacement); public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException; protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt, Object bean, String propName) throws IOException, JsonProcessingException; protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException; public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException; protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt) throws IOException; long serialVersionUID=Optional[-2038793552422727904L]; Annotations _classAnnotations; JavaType _beanType; JsonFormat.Shape _serializationShape; ValueInstantiator _valueInstantiator; JsonDeserializer<Object> _delegateDeserializer; PropertyBasedCreator _propertyBasedCreator; boolean _nonStandardCreation; boolean _vanillaProcessing; BeanPropertyMap _beanProperties; ValueInjector[] _injectables; SettableAnyProperty _anySetter; HashSet<String> _ignorableProps; boolean _ignoreAllUnknown; boolean _needViewProcesing; Map<String, SettableBeanProperty> _backRefs; HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers; UnwrappedPropertyHandler _unwrappedPropertyHandler; ExternalTypeHandler _externalTypeIdHandler; ObjectIdReader _objectIdReader"}
{"code": "public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type) { [EOL]         return _serializer; [EOL]     } [EOL]     return null; [EOL] } public SerializerAndMapResult(JsonSerializer<Object> serializer, PropertySerializerMap map); public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer); public Single(Class<?> type, JsonSerializer<Object> serializer); public Double(Class<?> type1, JsonSerializer<Object> serializer1, Class<?> type2, JsonSerializer<Object> serializer2); public Multi(TypeAndSerializer[] entries); public abstract JsonSerializer<Object> serializerFor(Class<?> type); public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public static PropertySerializerMap emptyMap(); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)"}
{"code": "public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"abc:\\\")); [EOL]     MyMap map = mapper.readValue(\\\"{\\\\\"a\\\\\":\\\\\"b\\\\\"}\\\", MyMap.class); [EOL]     assertEquals(\\\"{\\\\\"KEY\\\\\":\\\\\"b\\\\\"}\\\", mapper.writeValueAsString(map)); [EOL] }", "nl": "[LINE] HandlerInstantiator hi = _config.getHandlerInstantiator(); [LINE] @Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned key deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\\\"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<KeyDeserializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] } protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory); public Impl(DeserializerFactory df); protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected Impl(Impl src, DeserializerFactory factory); public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract DefaultDeserializationContext with(DeserializerFactory factory); public abstract DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext with(DeserializerFactory factory); long serialVersionUID=Optional[1L]; LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, [LINE] protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl); protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property); public abstract TypeDeserializer forProperty(BeanProperty prop); public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName(); public final String getPropertyName(); public TypeIdResolver getTypeIdResolver(); public Class<?> getDefaultImpl(); public String toString(); protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException; protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[278445030337366675L]; TypeIdResolver _idResolver; JavaType _baseType; BeanProperty _property; JavaType _defaultImpl; String _typePropertyName; boolean _typeIdVisible; HashMap<String, JsonDeserializer<Object>> _deserializers; JsonDeserializer<Object> _defaultImplDeserializer"}
{"code": "public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\\\"test\\\", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer(\\\"prefix\\\")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put(\\\"a\\\", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals(\\\"{\\\\\"prefix:a\\\\\":3}\\\", json); [EOL] }", "nl": "[LINE] _keySerializers.addSerializer(type, ser); [LINE] public <T> SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     if (_keySerializers == null) { [EOL]         _keySerializers = new SimpleSerializers(); [EOL]     } [EOL]     _keySerializers.addSerializer(type, ser); [EOL]     return this; [EOL] } public SimpleModule(); public SimpleModule(String name); public SimpleModule(Version version); public SimpleModule(String name, Version version); public SimpleModule(String name, Version version, Map<Class<?>, JsonDeserializer<?>> deserializers); public SimpleModule(String name, Version version, List<JsonSerializer<?>> serializers); public SimpleModule(String name, Version version, Map<Class<?>, JsonDeserializer<?>> deserializers, List<JsonSerializer<?>> serializers); public void setSerializers(SimpleSerializers s); public void setDeserializers(SimpleDeserializers d); public void setKeySerializers(SimpleSerializers ks); public void setKeyDeserializers(SimpleKeyDeserializers kd); public void setAbstractTypes(SimpleAbstractTypeResolver atr); public void setValueInstantiators(SimpleValueInstantiators svi); public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod); public SimpleModule setSerializerModifier(BeanSerializerModifier mod); public SimpleModule addSerializer(JsonSerializer<?> ser); public SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser); public SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser); public SimpleModule addDeserializer(Class<T> type, JsonDeserializer<? extends T> deser); public SimpleModule addKeyDeserializer(Class<?> type, KeyDeserializer deser); public SimpleModule addAbstractTypeMapping(Class<T> superType, Class<? extends T> subType); public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst); public SimpleModule registerSubtypes(Class<?>... subtypes); public SimpleModule registerSubtypes(NamedType... subtypes); public SimpleModule setMixInAnnotation(Class<?> targetType, Class<?> mixinClass); public String getModuleName(); public void setupModule(SetupContext context); public Version version(); long serialVersionUID=Optional[3132264350026957446L]; String _name; Version _version; SimpleSerializers _serializers=Optional[null]; SimpleDeserializers _deserializers=Optional[null]; SimpleSerializers _keySerializers=Optional[null]; SimpleKeyDeserializers _keyDeserializers=Optional[null]; SimpleAbstractTypeResolver _abstractTypes=Optional[null]; SimpleValueInstantiators _valueInstantiators=Optional[null]; BeanDeserializerModifier _deserializerModifier=Optional[null]; BeanSerializerModifier _serializerModifier=Optional[null]; HashMap<Class<?>, Class<?>> _mixins=Optional[null]; LinkedHashSet<NamedType> _subtypes=Optional[null]"}
{"code": "public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\\\"\\\\\"value1\\\\\"\\\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\\\"value1\\\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }", "nl": "[LINE] JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [LINE] @Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [LINE] @Override [EOL] public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) { [EOL]     if (_annotationIntrospector != null) { [EOL]         JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [EOL]         if (v != null) { [EOL]             return v; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] } protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props); protected BasicBeanDescription(POJOPropertiesCollector coll); public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll); public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll); public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac); public boolean removeProperty(String propName); public AnnotatedClass getClassInfo(); public ObjectIdInfo getObjectIdInfo(); public List<BeanPropertyDefinition> findProperties(); public AnnotatedMethod findJsonValueMethod(); public Set<String> getIgnoredPropertyNames(); public boolean hasKnownClassAnnotations(); public Annotations getClassAnnotations(); public TypeBindings bindingsForBeanType(); public JavaType resolveType(java.lang.reflect.Type jdkType); public AnnotatedConstructor findDefaultConstructor(); public AnnotatedMethod findAnySetter() throws IllegalArgumentException; public Map<Object, AnnotatedMember> findInjectables(); public List<AnnotatedConstructor> getConstructors(); public Object instantiateBean(boolean fixAccess); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue); public Converter<Object, Object> findSerializationConverter(); public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue); public AnnotatedMember findAnyGetter() throws IllegalArgumentException; public Map<String, AnnotatedMember> findBackReferenceProperties(); public List<AnnotatedMethod> getFactoryMethods(); public Constructor<?> findSingleArgConstructor(Class<?>... argTypes); public Method findFactoryMethod(Class<?>... expArgTypes); protected boolean isFactoryMethod(AnnotatedMethod am); public List<String> findCreatorPropertyNames(); public Class<?> findPOJOBuilder(); public JsonPOJOBuilder.Value findPOJOBuilderConfig(); public Converter<Object, Object> findDeserializationConverter(); public LinkedHashMap<String, AnnotatedField> _findPropertyFields(Collection<String> ignoredProperties, boolean forSerialization); public Converter<Object, Object> _createConverter(Object converterDef); MapperConfig<?> _config; AnnotationIntrospector _annotationIntrospector; AnnotatedClass _classInfo; TypeBindings _bindings; List<BeanPropertyDefinition> _properties; ObjectIdInfo _objectIdInfo; AnnotatedMethod _anySetterMethod; Map<Object, AnnotatedMember> _injectables; Set<String> _ignoredPropertyNames; AnnotatedMethod _jsonValueMethod; AnnotatedMember _anyGetter"}
{"code": "public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"xyz:\\\")); [EOL]     assertEquals(quote(\\\"xyz:456\\\"), mapper.writeValueAsString(new MyBean(\\\"456\\\"))); [EOL] }", "nl": "[LINE] return (_base == newBase) ? this : new DeserializationConfig(this, newBase); [LINE] private final DeserializationConfig _withBase(BaseSettings newBase) { [EOL]     return (_base == newBase) ? this : new DeserializationConfig(this, newBase); [EOL] } public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private DeserializationConfig(DeserializationConfig src, SubtypeResolver str); private DeserializationConfig(DeserializationConfig src, int mapperFeatures, int deserFeatures); private DeserializationConfig(DeserializationConfig src, BaseSettings base); private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f); private DeserializationConfig(DeserializationConfig src, LinkedNode<DeserializationProblemHandler> problemHandlers); private DeserializationConfig(DeserializationConfig src, String rootName); private DeserializationConfig(DeserializationConfig src, Class<?> view); protected DeserializationConfig(DeserializationConfig src, Map<ClassKey, Class<?>> mixins); protected BaseSettings getBaseSettings(); public DeserializationConfig with(MapperFeature... features); public DeserializationConfig without(MapperFeature... features); public DeserializationConfig with(ClassIntrospector ci); public DeserializationConfig with(AnnotationIntrospector ai); public DeserializationConfig with(VisibilityChecker<?> vc); public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public DeserializationConfig with(TypeResolverBuilder<?> trb); public DeserializationConfig with(SubtypeResolver str); public DeserializationConfig with(PropertyNamingStrategy pns); public DeserializationConfig withRootName(String rootName); public DeserializationConfig with(TypeFactory tf); public DeserializationConfig with(DateFormat df); public DeserializationConfig with(HandlerInstantiator hi); public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withView(Class<?> view); public DeserializationConfig with(Locale l); public DeserializationConfig with(TimeZone tz); public DeserializationConfig with(Base64Variant base64); private final DeserializationConfig _withBase(BaseSettings newBase); public DeserializationConfig with(JsonNodeFactory f); public DeserializationConfig withHandler(DeserializationProblemHandler h); public DeserializationConfig withNoProblemHandlers(); public DeserializationConfig with(DeserializationFeature feature); public DeserializationConfig with(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withFeatures(DeserializationFeature... features); public DeserializationConfig without(DeserializationFeature feature); public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withoutFeatures(DeserializationFeature... features); public AnnotationIntrospector getAnnotationIntrospector(); public boolean useRootWrapping(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(DeserializationFeature f); public final int getDeserializationFeatures(); public LinkedNode<DeserializationProblemHandler> getProblemHandlers(); public final JsonNodeFactory getNodeFactory(); public T introspect(JavaType type); public T introspectForCreation(JavaType type); public T introspectForBuilder(JavaType type); long serialVersionUID=Optional[-4227480407273773599L]; int _deserFeatures; LinkedNode<DeserializationProblemHandler> _problemHandlers; JsonNodeFactory _nodeFactory"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] renamed = findRenamed(_getters, renamed); [LINE] public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] } public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector, boolean forSerialization); public POJOPropertyBuilder(POJOPropertyBuilder src, String newName); public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored); public POJOPropertyBuilder withName(String newName); public int compareTo(POJOPropertyBuilder other); public String getName(); public String getInternalName(); public PropertyName getWrapperName(); public boolean isExplicitlyIncluded(); public boolean hasGetter(); public boolean hasSetter(); public boolean hasField(); public boolean hasConstructorParameter(); public boolean couldSerialize(); public AnnotatedMethod getGetter(); public AnnotatedMethod getSetter(); public AnnotatedField getField(); public AnnotatedParameter getConstructorParameter(); public AnnotatedMember getAccessor(); public AnnotatedMember getMutator(); public AnnotatedMember getPrimaryMember(); public Class<?>[] withMember(AnnotatedMember member); public Class<?>[] findViews(); public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member); public AnnotationIntrospector.ReferenceProperty findReferenceType(); public Boolean withMember(AnnotatedMember member); public boolean isTypeId(); public Boolean withMember(AnnotatedMember member); public boolean isRequired(); public ObjectIdInfo withMember(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(); public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored); public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored); public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addAll(POJOPropertyBuilder src); private static Linked<T> merge(Linked<T> chain1, Linked<T> chain2); public void removeIgnored(); public void removeNonVisible(); public void removeNonVisible(boolean force); public void trimByVisibility(); public void mergeAnnotations(boolean forSerialization); private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes); private Linked<T> _removeIgnored(Linked<T> node); private Linked<T> _removeNonVisible(Linked<T> node); private Linked<T> _trimByVisibility(Linked<T> node); private boolean _anyExplicitNames(Linked<T> n); public boolean anyVisible(); private boolean _anyVisible(Linked<T> n); public boolean anyIgnorals(); private boolean _anyIgnorals(Linked<T> n); public String findNewName(); private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed); public String toString(); protected T fromMemberAnnotations(WithMember<T> func); public T withMember(AnnotatedMember member); public Linked<T> withValue(T newValue); public Linked<T> withNext(Linked<T> newNext); public Linked<T> withoutIgnored(); public Linked<T> withoutNonVisible(); private Linked<T> append(Linked<T> appendable); public Linked<T> trimByVisibility(); public String toString(); boolean _forSerialization; AnnotationIntrospector _annotationIntrospector; String _name; String _internalName; Linked<AnnotatedField> _fields; Linked<AnnotatedParameter> _ctorParameters; Linked<AnnotatedMethod> _getters; Linked<AnnotatedMethod> _setters"}
{"code": "public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set(\\\"x\\\", TextNode.valueOf(\\\"Test\\\")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set(\\\"x\\\", TextNode.valueOf(\\\"Test\\\")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }", "nl": "[LINE] _children.put(fieldName, value); [LINE] public JsonNode set(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _children.put(fieldName, value); [EOL]     return this; [EOL] } public ObjectNode(JsonNodeFactory nc); public ObjectNode deepCopy(); public JsonNodeType getNodeType(); public JsonToken asToken(); public int size(); public Iterator<JsonNode> elements(); public JsonNode get(int index); public JsonNode get(String fieldName); public Iterator<String> fieldNames(); public JsonNode path(int index); public JsonNode path(String fieldName); public Iterator<Map.Entry<String, JsonNode>> fields(); public ObjectNode with(String propertyName); public ArrayNode withArray(String propertyName); public JsonNode findValue(String fieldName); public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar); public List<String> findValuesAsText(String fieldName, List<String> foundSoFar); public ObjectNode findParent(String fieldName); public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar); public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException; public JsonNode set(String fieldName, JsonNode value); public JsonNode setAll(Map<String, JsonNode> properties); public JsonNode setAll(ObjectNode other); public JsonNode replace(String fieldName, JsonNode value); public JsonNode without(String fieldName); public ObjectNode without(Collection<String> fieldNames); public JsonNode put(String fieldName, JsonNode value); public JsonNode remove(String fieldName); public ObjectNode remove(Collection<String> fieldNames); public ObjectNode removeAll(); public JsonNode putAll(Map<String, JsonNode> properties); public JsonNode putAll(ObjectNode other); public ObjectNode retain(Collection<String> fieldNames); public ObjectNode retain(String... fieldNames); public ArrayNode putArray(String fieldName); public ObjectNode putObject(String fieldName); public ObjectNode putPOJO(String fieldName, Object pojo); public ObjectNode putNull(String fieldName); public ObjectNode put(String fieldName, short v); public ObjectNode put(String fieldName, Short value); public ObjectNode put(String fieldName, int v); public ObjectNode put(String fieldName, Integer value); public ObjectNode put(String fieldName, long v); public ObjectNode put(String fieldName, Long value); public ObjectNode put(String fieldName, float v); public ObjectNode put(String fieldName, Float value); public ObjectNode put(String fieldName, double v); public ObjectNode put(String fieldName, Double value); public ObjectNode put(String fieldName, BigDecimal v); public ObjectNode put(String fieldName, String v); public ObjectNode put(String fieldName, boolean v); public ObjectNode put(String fieldName, Boolean value); public ObjectNode put(String fieldName, byte[] v); public boolean equals(Object o); public int hashCode(); public String toString(); Map<String, JsonNode> _children=Optional[new LinkedHashMap<String, JsonNode>()]"}
{"code": "public void testIssue811() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL]     om.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL]     om.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL]     om.setVisibility(PropertyAccessor.FIELD, Visibility.ANY); [EOL]     om.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     om.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, \\\"@class\\\"); [EOL]     Process p = new Process(); [EOL]     Scope s = new Scope(p, null); [EOL]     FaultHandler fh = new FaultHandler(p); [EOL]     Catch c = new Catch(p, s); [EOL]     fh.catchBlocks.add(c); [EOL]     s.faultHandlers.add(fh); [EOL]     String json = om.writeValueAsString(p); [EOL]     Process restored = om.readValue(json, Process.class); [EOL]     assertNotNull(restored); [EOL]     assertEquals(0, p.id); [EOL]     assertEquals(3, p.children.size()); [EOL]     assertSame(p, p.children.get(0).owner); [EOL]     assertSame(p, p.children.get(1).owner); [EOL]     assertSame(p, p.children.get(2).owner); [EOL] }", "nl": "[LINE] public PropertyBasedObjectIdGenerator(Class<?> scope) { [LINE] public PropertyBasedObjectIdGenerator(Class<?> scope) { [EOL]     super(scope); [EOL] } public PropertyBasedObjectIdGenerator(Class<?> scope); public Object generateId(Object forPojo); public ObjectIdGenerator<Object> forScope(Class<?> scope); public ObjectIdGenerator<Object> newForSerialization(Object context); public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key); long serialVersionUID=Optional[1L]"}
{"code": "public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals(\\\"{\\\\\"values\\\\\":[[7,8],[8,7]]}\\\", json); [EOL] }", "nl": "[LINE] return (Converter<Object,Object>) conv; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException(\\\"AnnotationIntrospector returned Converter definition of type \\\" + converterDef.getClass().getName() + \\\"; expected type Converter or Class<Converter> instead\\\"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + converterClass.getName() + \\\"; expected Class<Converter>\\\"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] } public abstract MapperConfig<?> getConfig(); public abstract AnnotationIntrospector getAnnotationIntrospector(); public final boolean isEnabled(MapperFeature feature); public final boolean canOverrideAccessModifiers(); public abstract Class<?> getActiveView(); public JavaType constructType(Type type); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException; public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException"}
{"code": "public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree(\\\"null\\\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree(\\\"null\\\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree(\\\"{\\\\\"x\\\\\":null}\\\"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get(\\\"x\\\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }", "nl": "[LINE] result = _findRootDeserializer(ctxt, valueType).getNullValue(); [LINE] protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] for (SettableBeanProperty cp : creatorProps) { [LINE] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     boolean ignoreAny = false; [EOL]     { [EOL]         Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL]         if (B != null) { [EOL]             ignoreAny = B.booleanValue(); [EOL]             builder.setIgnoreUnknownProperties(ignoreAny); [EOL]         } [EOL]     } [EOL]     Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]     for (String propName : ignored) { [EOL]         builder.addIgnorable(propName); [EOL]     } [EOL]     AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL]     if (anySetter != null) { [EOL]         builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL]     } [EOL]     if (anySetter == null) { [EOL]         Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL]         if (ignored2 != null) { [EOL]             for (String propName : ignored2) { [EOL]                 builder.addIgnorable(propName); [EOL]             } [EOL]         } [EOL]     } [EOL]     final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL]     List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL]         } [EOL]     } [EOL]     for (BeanPropertyDefinition propDef : propDefs) { [EOL]         SettableBeanProperty prop = null; [EOL]         if (propDef.hasConstructorParameter()) { [EOL]             final String name = propDef.getName(); [EOL]             if (creatorProps != null) { [EOL]                 for (SettableBeanProperty cp : creatorProps) { [EOL]                     if (name.equals(cp.getName())) { [EOL]                         prop = cp; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (prop == null) { [EOL]                 throw ctxt.mappingException(\\\"Could not find creator property with name '\\\" + name + \\\"' (in class \\\" + beanDesc.getBeanClass().getName() + \\\")\\\"); [EOL]             } [EOL]             builder.addCreatorProperty(prop); [EOL]             continue; [EOL]         } [EOL]         if (propDef.hasSetter()) { [EOL]             Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (propDef.hasField()) { [EOL]             Type propertyType = propDef.getField().getGenericType(); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL]             AnnotatedMethod getter = propDef.getGetter(); [EOL]             Class<?> rawPropertyType = getter.getRawType(); [EOL]             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL]                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL]             } [EOL]         } [EOL]         if (prop != null) { [EOL]             Class<?>[] views = propDef.findViews(); [EOL]             if (views == null) { [EOL]                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL]                     views = NO_VIEWS; [EOL]                 } [EOL]             } [EOL]             prop.setViews(views); [EOL]             builder.addProperty(prop); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }]; Class<?>[] NO_VIEWS=Optional[new Class<?>[0]]; BeanDeserializerFactory instance=Optional[new BeanDeserializerFactory(new DeserializerFactoryConfig())]"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] if (deserDef == null) { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\\\"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<JsonDeserializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] } protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory); public Impl(DeserializerFactory df); protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected Impl(Impl src, DeserializerFactory factory); public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract DefaultDeserializationContext with(DeserializerFactory factory); public abstract DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext with(DeserializerFactory factory); long serialVersionUID=Optional[1L]; LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [LINE] public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] } public SerializerProvider(); protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f); public void setDefaultKeySerializer(JsonSerializer<Object> ks); public void setNullValueSerializer(JsonSerializer<Object> nvs); public void setNullKeySerializer(JsonSerializer<Object> nks); public final SerializationConfig getConfig(); public final AnnotationIntrospector getAnnotationIntrospector(); public final TypeFactory getTypeFactory(); public final Class<?> getActiveView(); public final Class<?> getSerializationView(); public final boolean isEnabled(SerializationFeature feature); public final FilterProvider getFilterProvider(); public Locale getLocale(); public TimeZone getTimeZone(); public abstract WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> getDefaultNullKeySerializer(); public JsonSerializer<Object> getDefaultNullValueSerializer(); public JsonSerializer<Object> findNullKeySerializer(JavaType serializationType, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType); public abstract JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public final void defaultSerializeValue(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public final void defaultSerializeField(String fieldName, Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public final void defaultSerializeDateValue(long timestamp, JsonGenerator jgen) throws IOException, JsonProcessingException; public final void defaultSerializeDateValue(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException; public void defaultSerializeDateKey(long timestamp, JsonGenerator jgen) throws IOException, JsonProcessingException; public void defaultSerializeDateKey(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException; public final void defaultSerializeNull(JsonGenerator jgen) throws IOException, JsonProcessingException; protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException, JsonProcessingException; protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException; protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> type) throws JsonMappingException; protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException; protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException; protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException; protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException; protected final DateFormat _dateFormat(); JavaType TYPE_OBJECT=Optional[TypeFactory.defaultInstance().uncheckedSimpleType(Object.class)]; boolean CACHE_UNKNOWN_MAPPINGS=Optional[false]; JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER=Optional[new FailingSerializer(\\\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\\\")]; JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER=Optional[new UnknownSerializer()]; SerializationConfig _config; Class<?> _serializationView; SerializerFactory _serializerFactory; SerializerCache _serializerCache; RootNameLookup _rootNames; JsonSerializer<Object> _unknownTypeSerializer=Optional[DEFAULT_UNKNOWN_SERIALIZER]; JsonSerializer<Object> _keySerializer; JsonSerializer<Object> _nullValueSerializer=Optional[NullSerializer.instance]; JsonSerializer<Object> _nullKeySerializer=Optional[DEFAULT_NULL_KEY_SERIALIZER]; ReadOnlyClassToSerializerMap _knownSerializers; DateFormat _dateFormat"}
{"code": "public void testSpecialMap() throws IOException { [EOL]     final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class); [EOL]     _doTestUntyped(map); [EOL] }", "nl": "[LINE] return mapArray(jp, ctxt); [LINE] @Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] } public UntypedObjectDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Object[] NO_OBJECTS=Optional[new Object[0]]; UntypedObjectDeserializer instance=Optional[new UntypedObjectDeserializer()]"}
{"code": "public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\\\"{\\\\\"enumA\\\\\":\\\\\"value\\\\\"}\\\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\\\"value\\\", value.get(EnumWithCreator.A)); [EOL] }", "nl": "[LINE] super(er.getEnumClass()); [LINE] protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) { [EOL]     super(er.getEnumClass()); [EOL]     _resolver = er; [EOL]     _factory = factory; [EOL] } protected StdKeyDeserializer(Class<?> cls); private StringKD(Class<?> nominalType);  BoolKD();  ByteKD();  ShortKD();  CharKD();  IntKD();  LongKD();  DoubleKD();  FloatKD();  LocaleKD(); protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser); protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory); public StringCtorKeyDeserializer(Constructor<?> ctor); public StringFactoryKeyDeserializer(Method fm); protected DateKD(); protected CalendarKD(); protected UuidKD(); public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Class<?> getKeyClass(); protected abstract Object _parse(String key, DeserializationContext ctxt) throws Exception; protected int _parseInt(String key) throws IllegalArgumentException; protected long _parseLong(String key) throws IllegalArgumentException; protected double _parseDouble(String key) throws IllegalArgumentException; public static StringKD forType(Class<?> nominalType); public String _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Boolean _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Byte _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Short _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Character _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Integer _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Long _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Double _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Float _parse(String key, DeserializationContext ctxt) throws JsonMappingException; protected Locale _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Class<?> getKeyClass(); public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException; public Object _parse(String key, DeserializationContext ctxt) throws Exception; public Object _parse(String key, DeserializationContext ctxt) throws Exception; public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException; public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException; public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException; long serialVersionUID=Optional[1L]; Class<?> _keyClass"}
{"code": "public void testRootViaMapper() throws Exception { [EOL]     ObjectMapper mapper = rootMapper(); [EOL]     String json = mapper.writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"rudy\\\\\":{\\\\\"a\\\\\":3}}\\\", json); [EOL]     Bean bean = mapper.readValue(json, Bean.class); [EOL]     assertNotNull(bean); [EOL]     json = mapper.writeValueAsString(new RootBeanWithEmpty()); [EOL]     assertEquals(\\\"{\\\\\"RootBeanWithEmpty\\\\\":{\\\\\"a\\\\\":2}}\\\", json); [EOL]     RootBeanWithEmpty bean2 = mapper.readValue(json, RootBeanWithEmpty.class); [EOL]     assertNotNull(bean2); [EOL]     assertEquals(2, bean2.a); [EOL] }", "nl": "[LINE] if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [LINE] protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, \\\"Current token not START_OBJECT (needed to unwrap root name '\\\" + expName + \\\"'), but \\\" + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, \\\"Current token not FIELD_NAME (to contain expected root name '\\\" + expName + \\\"'), but \\\" + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, \\\"Root name '\\\" + actualName + \\\"' does not match expected ('\\\" + expName + \\\"') for type \\\" + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, \\\"Current token not END_OBJECT (to match wrapper object with root name '\\\" + expName + \\\"'), but \\\" + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testIssue476() throws Exception { [EOL]     final String JSON = \\\"{\\\\\"value1\\\\\" : {\\\\\"name\\\\\" : \\\\\"fruit\\\\\", \\\\\"value\\\\\" : \\\\\"apple\\\\\"}, \\\\\"value2\\\\\" : {\\\\\"name\\\\\" : \\\\\"color\\\\\", \\\\\"value\\\\\" : \\\\\"red\\\\\"}}\\\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new Issue476Module()); [EOL]     mapper.readValue(JSON, Issue476Bean.class); [EOL]     assertEquals(2, Issue476Deserializer.propCount); [EOL] }", "nl": "[LINE] return deserializer; [LINE] public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer<?> deserializer) { [EOL]     return deserializer; [EOL] } public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> propDefs); public BeanDeserializerBuilder updateBuilder(DeserializationConfig config, BeanDescription beanDesc, BeanDeserializerBuilder builder); public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyArrayDeserializer(DeserializationConfig config, ArrayType valueType, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyCollectionDeserializer(DeserializationConfig config, CollectionType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyCollectionLikeDeserializer(DeserializationConfig config, CollectionLikeType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyMapDeserializer(DeserializationConfig config, MapType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyMapLikeDeserializer(DeserializationConfig config, MapLikeType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config, JavaType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer); public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config, JavaType type, KeyDeserializer deserializer)"}
{"code": "public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>(\\\"valueX\\\"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = \\\"xxxxxx\\\"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }", "nl": "[LINE] public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) { [LINE] public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) { [EOL]     return (_serializationInclusion == incl) ? this : new SerializationConfig(this, incl); [EOL] } public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private SerializationConfig(SerializationConfig src, SubtypeResolver str); private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures); private SerializationConfig(SerializationConfig src, BaseSettings base); private SerializationConfig(SerializationConfig src, FilterProvider filters); private SerializationConfig(SerializationConfig src, Class<?> view); private SerializationConfig(SerializationConfig src, JsonInclude.Include incl); private SerializationConfig(SerializationConfig src, String rootName); protected SerializationConfig(SerializationConfig src, Map<ClassKey, Class<?>> mixins); public SerializationConfig with(MapperFeature... features); public SerializationConfig without(MapperFeature... features); public SerializationConfig with(AnnotationIntrospector ai); public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig with(ClassIntrospector ci); public SerializationConfig with(DateFormat df); public SerializationConfig with(HandlerInstantiator hi); public SerializationConfig with(PropertyNamingStrategy pns); public SerializationConfig withRootName(String rootName); public SerializationConfig with(SubtypeResolver str); public SerializationConfig with(TypeFactory tf); public SerializationConfig with(TypeResolverBuilder<?> trb); public SerializationConfig withView(Class<?> view); public SerializationConfig with(VisibilityChecker<?> vc); public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SerializationConfig with(Locale l); public SerializationConfig with(TimeZone tz); public SerializationConfig with(Base64Variant base64); private final SerializationConfig _withBase(BaseSettings newBase); public SerializationConfig with(SerializationFeature feature); public SerializationConfig with(SerializationFeature first, SerializationFeature... features); public SerializationConfig withFeatures(SerializationFeature... features); public SerializationConfig without(SerializationFeature feature); public SerializationConfig without(SerializationFeature first, SerializationFeature... features); public SerializationConfig withoutFeatures(SerializationFeature... features); public SerializationConfig withFilters(FilterProvider filterProvider); public SerializationConfig withSerializationInclusion(JsonInclude.Include incl); public boolean useRootWrapping(); public AnnotationIntrospector getAnnotationIntrospector(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(SerializationFeature f); public final int getSerializationFeatures(); public JsonInclude.Include getSerializationInclusion(); public FilterProvider getFilterProvider(); public T introspect(JavaType type); public String toString(); long serialVersionUID=Optional[8849092838541724233L]; int _serFeatures; JsonInclude.Include _serializationInclusion=Optional[null]; FilterProvider _filterProvider"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] _acceptString = cls.isAssignableFrom(String.class); [LINE] public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps) { [EOL]     _baseType = beanDesc.getType(); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _backRefProperties = backRefProps; [EOL]     Class<?> cls = _baseType.getRawClass(); [EOL]     _acceptString = cls.isAssignableFrom(String.class); [EOL]     _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class); [EOL]     _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class); [EOL]     _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class); [EOL] } public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps); public boolean isCachable(); public ObjectIdReader getObjectIdReader(); public SettableBeanProperty findBackReference(String logicalName); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[-3010349050434697698L]; JavaType _baseType; ObjectIdReader _objectIdReader; Map<String, SettableBeanProperty> _backRefProperties; boolean _acceptString; boolean _acceptBoolean; boolean _acceptInt; boolean _acceptDouble"}
{"code": "public void testIssue709() throws Exception { [EOL]     byte[] inputData = new byte[] { 1, 2, 3 }; [EOL]     ObjectNode node = MAPPER.createObjectNode(); [EOL]     node.put(\\\"data\\\", inputData); [EOL]     Issue709Bean result = MAPPER.treeToValue(node, Issue709Bean.class); [EOL]     String json = MAPPER.writeValueAsString(node); [EOL]     Issue709Bean resultFromString = MAPPER.readValue(json, Issue709Bean.class); [EOL]     Issue709Bean resultFromConvert = MAPPER.convertValue(node, Issue709Bean.class); [EOL]     Assert.assertArrayEquals(inputData, resultFromString.data); [EOL]     Assert.assertArrayEquals(inputData, resultFromConvert.data); [EOL]     Assert.assertArrayEquals(inputData, result.data); [EOL] }", "nl": "[LINE] _children.put(fieldName, binaryNode(v)); [LINE] public ObjectNode put(String fieldName, byte[] v) { [EOL]     if (v == null) { [EOL]         _children.put(fieldName, nullNode()); [EOL]     } else { [EOL]         _children.put(fieldName, binaryNode(v)); [EOL]     } [EOL]     return this; [EOL] } public ObjectNode(JsonNodeFactory nc); public ObjectNode deepCopy(); public JsonNodeType getNodeType(); public JsonToken asToken(); public int size(); public Iterator<JsonNode> elements(); public JsonNode get(int index); public JsonNode get(String fieldName); public Iterator<String> fieldNames(); public JsonNode path(int index); public JsonNode path(String fieldName); public Iterator<Map.Entry<String, JsonNode>> fields(); public ObjectNode with(String propertyName); public ArrayNode withArray(String propertyName); public JsonNode findValue(String fieldName); public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar); public List<String> findValuesAsText(String fieldName, List<String> foundSoFar); public ObjectNode findParent(String fieldName); public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar); public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException; public JsonNode set(String fieldName, JsonNode value); public JsonNode setAll(Map<String, JsonNode> properties); public JsonNode setAll(ObjectNode other); public JsonNode replace(String fieldName, JsonNode value); public JsonNode without(String fieldName); public ObjectNode without(Collection<String> fieldNames); public JsonNode put(String fieldName, JsonNode value); public JsonNode remove(String fieldName); public ObjectNode remove(Collection<String> fieldNames); public ObjectNode removeAll(); public JsonNode putAll(Map<String, JsonNode> properties); public JsonNode putAll(ObjectNode other); public ObjectNode retain(Collection<String> fieldNames); public ObjectNode retain(String... fieldNames); public ArrayNode putArray(String fieldName); public ObjectNode putObject(String fieldName); public ObjectNode putPOJO(String fieldName, Object pojo); public ObjectNode putNull(String fieldName); public ObjectNode put(String fieldName, short v); public ObjectNode put(String fieldName, Short value); public ObjectNode put(String fieldName, int v); public ObjectNode put(String fieldName, Integer value); public ObjectNode put(String fieldName, long v); public ObjectNode put(String fieldName, Long value); public ObjectNode put(String fieldName, float v); public ObjectNode put(String fieldName, Float value); public ObjectNode put(String fieldName, double v); public ObjectNode put(String fieldName, Double value); public ObjectNode put(String fieldName, BigDecimal v); public ObjectNode put(String fieldName, String v); public ObjectNode put(String fieldName, boolean v); public ObjectNode put(String fieldName, Boolean value); public ObjectNode put(String fieldName, byte[] v); public boolean equals(Object o); public int hashCode(); public String toString(); Map<String, JsonNode> _children=Optional[new LinkedHashMap<String, JsonNode>()]"}
{"code": "public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue(\\\"[-37]\\\", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }", "nl": "[LINE] for (TypeModifier mod : _modifiers) { [LINE] protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException(\\\"Unrecognized Type: \\\" + ((type == null) ? \\\"[null]\\\" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }", "nl": "[LINE] case VALUE_STRING: [LINE] @Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException(\\\"Internal error: should never end up through this code path\\\"); [EOL]     } [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSimpleArrayMethod() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     MethodWrapperBeanArray array = new MethodWrapperBeanArray(new MethodWrapperBean[] { new MethodWrapperBean(new StringWrapper(\\\"A\\\")) }); [EOL]     String json = mapper.writeValueAsString(array); [EOL]     MethodWrapperBeanArray result = mapper.readValue(json, MethodWrapperBeanArray.class); [EOL]     assertNotNull(result); [EOL]     MethodWrapperBean[] beans = result.beans; [EOL]     assertEquals(1, beans.length); [EOL]     MethodWrapperBean bean = beans[0]; [EOL]     assertEquals(StringWrapper.class, bean.value.getClass()); [EOL]     assertEquals(((StringWrapper) bean.value).str, \\\"A\\\"); [EOL] }", "nl": "[LINE] if (o == null) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } protected SimpleType(Class<?> cls); protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic); public static SimpleType constructUnsafe(Class<?> raw); protected JavaType _narrow(Class<?> subclass); public JavaType narrowContentsBy(Class<?> subclass); public JavaType widenContentsBy(Class<?> subclass); public static SimpleType construct(Class<?> cls); public SimpleType withTypeHandler(Object h); public JavaType withContentTypeHandler(Object h); public SimpleType withValueHandler(Object h); public SimpleType withContentValueHandler(Object h); public SimpleType withStaticTyping(); protected String buildCanonicalName(); public boolean isContainerType(); public int containedTypeCount(); public JavaType containedType(int index); public String containedTypeName(int index); public StringBuilder getErasedSignature(StringBuilder sb); public StringBuilder getGenericSignature(StringBuilder sb); public String toString(); public boolean equals(Object o); long serialVersionUID=Optional[-800374828948534376L]; JavaType[] _typeParameters; String[] _typeNames"}
{"code": "public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals(\\\"{\\\\\"1970-01-01T00:00:00.000+0000\\\\\":1}\\\", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals(\\\"{\\\\\"0\\\\\":1}\\\", mapper.writeValueAsString(map)); [EOL] }", "nl": "[LINE] provider.defaultSerializeDateKey((Date) value, jgen); [LINE] @Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof Date) { [EOL]         provider.defaultSerializeDateKey((Date) value, jgen); [EOL]     } else { [EOL]         jgen.writeFieldName(value.toString()); [EOL]     } [EOL] } public StdKeySerializer(); public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; StdKeySerializer instace=Optional[new StdKeySerializer()]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] return super.getAnnotationIntrospector(); [LINE] @Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return AnnotationIntrospector.nopInstance(); [EOL] } public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private SerializationConfig(SerializationConfig src, SubtypeResolver str); private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures); private SerializationConfig(SerializationConfig src, BaseSettings base); private SerializationConfig(SerializationConfig src, FilterProvider filters); private SerializationConfig(SerializationConfig src, Class<?> view); private SerializationConfig(SerializationConfig src, JsonInclude.Include incl); private SerializationConfig(SerializationConfig src, String rootName); protected SerializationConfig(SerializationConfig src, Map<ClassKey, Class<?>> mixins); public SerializationConfig with(MapperFeature... features); public SerializationConfig without(MapperFeature... features); public SerializationConfig with(AnnotationIntrospector ai); public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig with(ClassIntrospector ci); public SerializationConfig with(DateFormat df); public SerializationConfig with(HandlerInstantiator hi); public SerializationConfig with(PropertyNamingStrategy pns); public SerializationConfig withRootName(String rootName); public SerializationConfig with(SubtypeResolver str); public SerializationConfig with(TypeFactory tf); public SerializationConfig with(TypeResolverBuilder<?> trb); public SerializationConfig withView(Class<?> view); public SerializationConfig with(VisibilityChecker<?> vc); public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SerializationConfig with(Locale l); public SerializationConfig with(TimeZone tz); public SerializationConfig with(Base64Variant base64); private final SerializationConfig _withBase(BaseSettings newBase); public SerializationConfig with(SerializationFeature feature); public SerializationConfig with(SerializationFeature first, SerializationFeature... features); public SerializationConfig withFeatures(SerializationFeature... features); public SerializationConfig without(SerializationFeature feature); public SerializationConfig without(SerializationFeature first, SerializationFeature... features); public SerializationConfig withoutFeatures(SerializationFeature... features); public SerializationConfig withFilters(FilterProvider filterProvider); public SerializationConfig withSerializationInclusion(JsonInclude.Include incl); public boolean useRootWrapping(); public AnnotationIntrospector getAnnotationIntrospector(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(SerializationFeature f); public final int getSerializationFeatures(); public JsonInclude.Include getSerializationInclusion(); public FilterProvider getFilterProvider(); public T introspect(JavaType type); public String toString(); long serialVersionUID=Optional[8849092838541724233L]; int _serFeatures; JsonInclude.Include _serializationInclusion=Optional[null]; FilterProvider _filterProvider"}
{"code": "public void testOverflows() { [EOL]     try { [EOL]         mapper.convertValue(new int[] { 1000 }, byte[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG_BYTE); [EOL]     } [EOL]     try { [EOL]         mapper.convertValue(new int[] { -99999 }, short[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL]     try { [EOL]         mapper.convertValue(new long[] { Long.MAX_VALUE }, int[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL]     BigInteger biggie = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     biggie.add(BigInteger.ONE); [EOL]     List<BigInteger> l = new ArrayList<BigInteger>(); [EOL]     l.add(biggie); [EOL]     try { [EOL]         mapper.convertValue(l, int[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL] }", "nl": "[LINE] if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [LINE] protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, \\\"overflow, value can not be represented as 16-bit value\\\"); [EOL]     } [EOL]     return (short) value; [EOL] } protected StdDeserializer(Class<?> vc); protected StdDeserializer(JavaType valueType); public Class<?> getValueClass(); public JavaType getValueType(); protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer); protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected static final double parseDouble(String numStr) throws NumberFormatException; protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException; protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException; protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Class<?> _valueClass"}
{"code": "public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }", "nl": "[LINE] if (ref != null) { [LINE] @Override [EOL] public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { [EOL]     JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class); [EOL]     if (ref != null) { [EOL]         objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); [EOL]     } [EOL]     return objectIdInfo; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] for (Class<?> cls : _superTypes) { [LINE] private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] } private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations); public AnnotatedClass withAnnotations(AnnotationMap ann); public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public Class<?> getAnnotated(); public int getModifiers(); public String getName(); public A getAnnotation(Class<A> acls); public Type getGenericType(); public Class<?> getRawType(); protected AnnotationMap getAllAnnotations(); public Annotations getAnnotations(); public boolean hasAnnotations(); public AnnotatedConstructor getDefaultConstructor(); public List<AnnotatedConstructor> getConstructors(); public List<AnnotatedMethod> getStaticMethods(); public Iterable<AnnotatedMethod> memberMethods(); public int getMemberMethodCount(); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public int getFieldCount(); public Iterable<AnnotatedField> fields(); private void resolveClassAnnotations(); private void resolveCreators(); private void resolveMemberMethods(); private void resolveFields(); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin); protected void _addConstructorMixIns(Class<?> mixin); protected void _addFactoryMixIns(Class<?> mixin); protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields); protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields); protected AnnotatedMethod _constructMethod(Method m); protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor); protected AnnotatedMethod _constructCreatorMethod(Method m); protected AnnotatedField _constructField(Field f); private AnnotationMap _emptyAnnotationMap(); private AnnotationMap[] _emptyAnnotationMaps(int count); protected boolean _isIncludableMemberMethod(Method m); private boolean _isIncludableField(Field f); protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns); protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns); private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns); protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations); protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations); protected void _addMixUnders(Method src, AnnotatedMethod target); private final boolean _isAnnotationBundle(Annotation ann); public String toString(); AnnotationMap[] NO_ANNOTATION_MAPS=Optional[new AnnotationMap[0]]; Class<?> _class; List<Class<?>> _superTypes; AnnotationIntrospector _annotationIntrospector; MixInResolver _mixInResolver; Class<?> _primaryMixIn; AnnotationMap _classAnnotations; boolean _creatorsResolved=Optional[false]; AnnotatedConstructor _defaultConstructor; List<AnnotatedConstructor> _constructors; List<AnnotatedMethod> _creatorMethods; AnnotatedMethodMap _memberMethods; List<AnnotatedField> _fields"}
{"code": "public void testJackson428() throws Exception { [EOL]     ObjectMapper serMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true)); [EOL]     serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     serMapper.setDefaultTyping(serializerTyper); [EOL]     MapHolder holder = new MapHolder(); [EOL]     holder.map = new HashMap<MapKey, List<Object>>(); [EOL]     List<Object> ints = new ArrayList<Object>(); [EOL]     ints.add(Integer.valueOf(3)); [EOL]     holder.map.put(new MapKey(\\\"key\\\"), ints); [EOL]     String json = serMapper.writeValueAsString(holder); [EOL]     ObjectMapper deserMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false)); [EOL]     deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     deserMapper.setDefaultTyping(deserializerTyper); [EOL]     MapHolder result = deserMapper.readValue(json, MapHolder.class); [EOL]     assertNotNull(result); [EOL]     Map<?, ?> map = result.map; [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(MapKey.class, key.getClass()); [EOL]     Object value = entry.getValue(); [EOL]     assertTrue(value instanceof List<?>); [EOL]     List<?> list = (List<?>) value; [EOL]     assertEquals(1, list.size()); [EOL]     assertEquals(Integer.class, list.get(0).getClass()); [EOL]     assertEquals(Integer.valueOf(3), list.get(0)); [EOL] }", "nl": "[LINE] return new MapSerializer(this, vts); [LINE] @Override [EOL] public MapSerializer _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new MapSerializer(this, vts); [EOL] } protected MapSerializer(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer); protected MapSerializer(MapSerializer src, BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); protected MapSerializer(MapSerializer src, TypeSerializer vts); public MapSerializer _withValueTypeSerializer(TypeSerializer vts); public MapSerializer withResolved(BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer); private static HashSet<String> toSet(String[] ignoredEntries); public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(Map<?, ?> value); public boolean hasSingleElement(Map<?, ?> value); public JsonSerializer<?> getKeySerializer(); public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; protected void serializeTypedFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, JavaType type, SerializerProvider provider) throws JsonMappingException; protected Map<?, ?> _orderEntries(Map<?, ?> input); JavaType UNSPECIFIED_TYPE=Optional[TypeFactory.unknownType()]; BeanProperty _property; HashSet<String> _ignoredEntries; boolean _valueTypeIsStatic; JavaType _keyType; JavaType _valueType; JsonSerializer<Object> _keySerializer; JsonSerializer<Object> _valueSerializer; TypeSerializer _valueTypeSerializer; PropertySerializerMap _dynamicValueSerializers"}
{"code": "public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode(\\\"root\\\"); [EOL]     FullTreeNode child1 = new FullTreeNode(\\\"kid1\\\"); [EOL]     FullTreeNode child2 = new FullTreeNode(\\\"kid2\\\"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals(\\\"root\\\", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals(\\\"kid1\\\", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals(\\\"kid2\\\", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }", "nl": "[LINE] _field.set(instance, value); [LINE] @Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL]     return instance; [EOL] } public FieldProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field); protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser); protected FieldProperty(FieldProperty src, String newName); protected FieldProperty(FieldProperty src, Field f); public FieldProperty withName(String newName); public FieldProperty withValueDeserializer(JsonDeserializer<?> deser); public A getAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public final void set(Object instance, Object value) throws IOException; public Object setAndReturn(Object instance, Object value) throws IOException;  Object readResolve(); long serialVersionUID=Optional[1L]; AnnotatedField _annotated; Field _field"}
{"code": "public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll(\\\"\\\\\"\\\", \\\"'\\\"); [EOL]     assertEquals(\\\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\\\", json); [EOL] }", "nl": "[LINE] if (!(schemaNode instanceof ObjectNode)) { [LINE] @SuppressWarnings(\\\"deprecation\\\") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException(\\\"A class must be provided\\\"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException(\\\"Class \\\" + type.getName() + \\\" would not be serialized as a JSON object and therefore has no schema\\\"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] } protected DefaultSerializerProvider(); protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f); public Impl(); protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f); public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException; public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType) throws IOException, JsonGenerationException; public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public boolean hasSerializerFor(Class<?> cls); public int cachedSerializersCount(); public void flushCachedSerializers(); public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public Impl createInstance(SerializationConfig config, SerializerFactory jsf); long serialVersionUID=Optional[1L]; IdentityHashMap<Object, WritableObjectId> _seenObjectIds; ArrayList<ObjectIdGenerator<?>> _objectIdGenerators"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] public StdSubtypeResolver() { } [LINE] public StdSubtypeResolver() { [EOL] } public StdSubtypeResolver(); public void registerSubtypes(NamedType... types); public void registerSubtypes(Class<?>... classes); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai); protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes); long serialVersionUID=Optional[1L]; LinkedHashSet<NamedType> _registeredSubtypes"}
{"code": "public void testJackson428() throws Exception { [EOL]     ObjectMapper serMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true)); [EOL]     serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     serMapper.setDefaultTyping(serializerTyper); [EOL]     MapHolder holder = new MapHolder(); [EOL]     holder.map = new HashMap<MapKey, List<Object>>(); [EOL]     List<Object> ints = new ArrayList<Object>(); [EOL]     ints.add(Integer.valueOf(3)); [EOL]     holder.map.put(new MapKey(\\\"key\\\"), ints); [EOL]     String json = serMapper.writeValueAsString(holder); [EOL]     ObjectMapper deserMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false)); [EOL]     deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     deserMapper.setDefaultTyping(deserializerTyper); [EOL]     MapHolder result = deserMapper.readValue(json, MapHolder.class); [EOL]     assertNotNull(result); [EOL]     Map<?, ?> map = result.map; [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(MapKey.class, key.getClass()); [EOL]     Object value = entry.getValue(); [EOL]     assertTrue(value instanceof List<?>); [EOL]     List<?> list = (List<?>) value; [EOL]     assertEquals(1, list.size()); [EOL]     assertEquals(Integer.class, list.get(0).getClass()); [EOL]     assertEquals(Integer.valueOf(3), list.get(0)); [EOL] }", "nl": "[LINE] protected MapSerializer(MapSerializer src, TypeSerializer vts) [LINE] protected MapSerializer(MapSerializer src, TypeSerializer vts) { [EOL]     super(Map.class, false); [EOL]     _ignoredEntries = src._ignoredEntries; [EOL]     _keyType = src._keyType; [EOL]     _valueType = src._valueType; [EOL]     _valueTypeIsStatic = src._valueTypeIsStatic; [EOL]     _valueTypeSerializer = vts; [EOL]     _keySerializer = src._keySerializer; [EOL]     _valueSerializer = src._valueSerializer; [EOL]     _dynamicValueSerializers = src._dynamicValueSerializers; [EOL]     _property = src._property; [EOL] } protected MapSerializer(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer); protected MapSerializer(MapSerializer src, BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); protected MapSerializer(MapSerializer src, TypeSerializer vts); public MapSerializer _withValueTypeSerializer(TypeSerializer vts); public MapSerializer withResolved(BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer); private static HashSet<String> toSet(String[] ignoredEntries); public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(Map<?, ?> value); public boolean hasSingleElement(Map<?, ?> value); public JsonSerializer<?> getKeySerializer(); public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; protected void serializeTypedFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, JavaType type, SerializerProvider provider) throws JsonMappingException; protected Map<?, ?> _orderEntries(Map<?, ?> input); JavaType UNSPECIFIED_TYPE=Optional[TypeFactory.unknownType()]; BeanProperty _property; HashSet<String> _ignoredEntries; boolean _valueTypeIsStatic; JavaType _keyType; JavaType _valueType; JsonSerializer<Object> _keySerializer; JsonSerializer<Object> _valueSerializer; TypeSerializer _valueTypeSerializer; PropertySerializerMap _dynamicValueSerializers"}
{"code": "public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue(\\\"[\\\\\"a\\\\\", \\\\\"b\\\\\"]\\\"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList(\\\"a\\\", \\\"b\\\"), ((MyInter) inter).blah); [EOL] }", "nl": "[LINE] if (_defaultImplDeserializer == null) { [LINE] protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] } protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl); protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property); public abstract TypeDeserializer forProperty(BeanProperty prop); public abstract JsonTypeInfo.As getTypeInclusion(); public String baseTypeName(); public final String getPropertyName(); public TypeIdResolver getTypeIdResolver(); public Class<?> getDefaultImpl(); public String toString(); protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException; protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[278445030337366675L]; TypeIdResolver _idResolver; JavaType _baseType; BeanProperty _property; JavaType _defaultImpl; String _typePropertyName; boolean _typeIdVisible; HashMap<String, JsonDeserializer<Object>> _deserializers; JsonDeserializer<Object> _defaultImplDeserializer"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] return value; [LINE] private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings(\\\"resource\\\") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \\\"expected closing END_ARRAY after type information and deserialized value\\\"); [EOL]     } [EOL]     return value; [EOL] } public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl); public AsArrayTypeDeserializer(AsArrayTypeDeserializer src, BeanProperty property); public TypeDeserializer forProperty(BeanProperty prop); public As getTypeInclusion(); public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[5345570420394408290L]"}
{"code": "public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals(\\\"[1,null,3]\\\", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue(\\\"[1,2,3]\\\"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }", "nl": "[LINE] protected SingleView(BeanPropertyWriter delegate, Class<?> view) [LINE] protected SingleView(BeanPropertyWriter delegate, Class<?> view) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _view = view; [EOL] } protected SingleView(BeanPropertyWriter delegate, Class<?> view); protected MultiView(BeanPropertyWriter delegate, Class<?>[] views); public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn); public SingleView rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public MultiView rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertEquals(\\\"2\\\", map.get(\\\"b\\\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertNull(map.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] return _array[_index++]; [LINE] @Override [EOL] public T next() { [EOL]     if (_index >= _array.length) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return _array[_index++]; [EOL] } public ArrayBuilders(); public BooleanBuilder(); public ByteBuilder(); public ShortBuilder(); public IntBuilder(); public LongBuilder(); public FloatBuilder(); public DoubleBuilder(); public ArrayIterator(T[] array); public BooleanBuilder getBooleanBuilder(); public ByteBuilder getByteBuilder(); public ShortBuilder getShortBuilder(); public IntBuilder getIntBuilder(); public LongBuilder getLongBuilder(); public FloatBuilder getFloatBuilder(); public DoubleBuilder getDoubleBuilder(); public final boolean[] _constructArray(int len); public final byte[] _constructArray(int len); public final short[] _constructArray(int len); public final int[] _constructArray(int len); public final long[] _constructArray(int len); public final float[] _constructArray(int len); public final double[] _constructArray(int len); public boolean equals(Object other); public static Object getArrayComparator(final Object defaultValue); public static HashSet<T> arrayToSet(T[] elements); public static ArrayList<T> arrayToList(T[] elements); public static HashSet<T> setAndArray(Set<T> set, T[] elements); public static List<T> addToList(List<T> list, T element); public static T[] insertInList(T[] array, T element); public static T[] insertInListNoDup(T[] array, T element); public static Iterator<T> arrayAsIterator(T[] array); public static Iterable<T> arrayAsIterable(T[] array); public boolean hasNext(); public T next(); public void remove(); public Iterator<T> iterator(); BooleanBuilder _booleanBuilder=Optional[null]; ByteBuilder _byteBuilder=Optional[null]; ShortBuilder _shortBuilder=Optional[null]; IntBuilder _intBuilder=Optional[null]; LongBuilder _longBuilder=Optional[null]; FloatBuilder _floatBuilder=Optional[null]; DoubleBuilder _doubleBuilder=Optional[null]"}
{"code": "public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals(\\\"foo\\\")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }", "nl": "[LINE] if (o == this) return true; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ClassKey other = (ClassKey) o; [EOL]     return other._class == _class; [EOL] } public ClassKey(); public ClassKey(Class<?> clz); public void reset(Class<?> clz); public int compareTo(ClassKey other); public boolean equals(Object o); public int hashCode(); public String toString(); long serialVersionUID=Optional[1L]; String _className; Class<?> _class; int _hashCode"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [LINE] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\\\"\\\", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException(\\\"Invalid Object Id definition for \\\" + _handledType.getName() + \\\": can not find property with name '\\\" + propName + \\\"'\\\"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] } protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore); protected BeanSerializerBase(BeanSerializerBase src); protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper); public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter); protected abstract BeanSerializerBase withIgnorals(String[] toIgnore); protected abstract BeanSerializerBase asArraySerializer(); private static final BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer); public void resolve(SerializerProvider provider) throws JsonMappingException; protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public boolean usesObjectId(); public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final String _customTypeId(Object bean); protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; BeanPropertyWriter[] NO_PROPS=Optional[new BeanPropertyWriter[0]]; BeanPropertyWriter[] _props; BeanPropertyWriter[] _filteredProps; AnyGetterWriter _anyGetterWriter; Object _propertyFilterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter; JsonFormat.Shape _serializationShape"}
{"code": "public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals(\\\"{\\\\\"empty\\\\\":[]}\\\", MAPPER.writeValueAsString(list)); [EOL]     assertEquals(\\\"{\\\\\"empty\\\\\":[]}\\\", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals(\\\"{}\\\", m.writeValueAsString(list)); [EOL]     assertEquals(\\\"{}\\\", m.writeValueAsString(array)); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] } protected StringArraySerializer(); public StringArraySerializer(StringArraySerializer src, BeanProperty prop, JsonSerializer<?> ser); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(String[] value); public boolean hasSingleElement(String[] value); public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; JavaType VALUE_TYPE=Optional[TypeFactory.defaultInstance().uncheckedSimpleType(String.class)]; StringArraySerializer instance=Optional[new StringArraySerializer()]; JsonSerializer<Object> _elementSerializer"}
{"code": "public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = \\\"TestTypedArraySerialization$TypedListAsWrapper\\\"; [EOL]     assertEquals(\\\"{\\\\\"\\\" + expName + \\\"\\\\\":[true,null,false]}\\\", serializeAsString(input)); [EOL] }", "nl": "[LINE] provider.defaultSerializeNull(jgen); [LINE] @Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] } public CollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer); public CollectionSerializer(CollectionSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public CollectionSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer); public boolean isEmpty(Collection<?> value); public boolean hasSingleElement(Collection<?> value); public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException"}
{"code": "public void testCollectionLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyMapLikeType result = mapper.readValue(\\\"{\\\\\"a\\\\\":13}\\\", MyMapLikeType.class); [EOL]     assertEquals(\\\"a\\\", result.getKey()); [EOL]     assertEquals(Integer.valueOf(13), result.getValue()); [EOL] }", "nl": "[LINE] final DeserializationConfig config = ctxt.getConfig(); [LINE] @Override [EOL] public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     @SuppressWarnings(\\\"unchecked\\\") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals(\\\"{\\\\\"values\\\\\":[[7,8],[8,7]]}\\\", json); [EOL] }", "nl": "[LINE] if (!Converter.class.isAssignableFrom(converterClass)) { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException(\\\"AnnotationIntrospector returned Converter definition of type \\\" + converterDef.getClass().getName() + \\\"; expected type Converter or Class<Converter> instead\\\"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + converterClass.getName() + \\\"; expected Class<Converter>\\\"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] } public abstract MapperConfig<?> getConfig(); public abstract AnnotationIntrospector getAnnotationIntrospector(); public final boolean isEnabled(MapperFeature feature); public final boolean canOverrideAccessModifiers(); public abstract Class<?> getActiveView(); public JavaType constructType(Type type); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public abstract TypeFactory getTypeFactory(); public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException; public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException"}
{"code": "public void testListAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = \\\"[\\n\\\" + asJSONObjectValueString(m, \\\"@classy\\\", Cat.class.getName(), \\\"name\\\", \\\"Hello\\\", \\\"furColor\\\", \\\"white\\\") + \\\",\\n\\\" + asJSONObjectValueString(m, \\\"boneCount\\\", Integer.valueOf(1), \\\"@classy\\\", Dog.class.getName(), \\\"name\\\", \\\"Bob\\\") + \\\",\\n\\\" + asJSONObjectValueString(m, \\\"@classy\\\", Fish.class.getName()) + \\\", null\\n]\\\"; [EOL]     JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class); [EOL]     List<Animal> animals = m.readValue(JSON, expType); [EOL]     assertNotNull(animals); [EOL]     assertEquals(4, animals.size()); [EOL]     Cat c = (Cat) animals.get(0); [EOL]     assertEquals(\\\"Hello\\\", c.name); [EOL]     assertEquals(\\\"white\\\", c.furColor); [EOL]     Dog d = (Dog) animals.get(1); [EOL]     assertEquals(\\\"Bob\\\", d.name); [EOL]     assertEquals(1, d.boneCount); [EOL]     Fish f = (Fish) animals.get(2); [EOL]     assertNotNull(f); [EOL]     assertNull(animals.get(3)); [EOL] }", "nl": "[LINE] if (!value.isEmpty()) { [LINE] @Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] } protected MapSerializer(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer); protected MapSerializer(MapSerializer src, BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); protected MapSerializer(MapSerializer src, TypeSerializer vts); public MapSerializer _withValueTypeSerializer(TypeSerializer vts); public MapSerializer withResolved(BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored); public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer); private static HashSet<String> toSet(String[] ignoredEntries); public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(Map<?, ?> value); public boolean hasSingleElement(Map<?, ?> value); public JsonSerializer<?> getKeySerializer(); public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; protected void serializeTypedFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, JavaType type, SerializerProvider provider) throws JsonMappingException; protected Map<?, ?> _orderEntries(Map<?, ?> input); JavaType UNSPECIFIED_TYPE=Optional[TypeFactory.unknownType()]; BeanProperty _property; HashSet<String> _ignoredEntries; boolean _valueTypeIsStatic; JavaType _keyType; JavaType _valueType; JsonSerializer<Object> _keySerializer; JsonSerializer<Object> _valueSerializer; TypeSerializer _valueTypeSerializer; PropertySerializerMap _dynamicValueSerializers"}
{"code": "public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = \\\"{\\\\\"x\\\\\":1,\\\\\"y\\\\\":2}\\\"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }", "nl": "[LINE] if (t == null) { // and then we must get something... [LINE] protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, \\\"No content to map due to end-of-input\\\"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] } protected ObjectReader(ObjectMapper mapper, DeserializationConfig config); protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues); protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders); protected ObjectReader(ObjectReader base, DeserializationConfig config); protected ObjectReader(ObjectReader base, JsonFactory f); public Version version(); public ObjectReader with(DeserializationConfig config); public ObjectReader with(DeserializationFeature feature); public ObjectReader with(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withFeatures(DeserializationFeature... features); public ObjectReader without(DeserializationFeature feature); public ObjectReader without(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withoutFeatures(DeserializationFeature... features); public ObjectReader with(InjectableValues injectableValues); public ObjectReader with(JsonNodeFactory f); public ObjectReader with(JsonFactory f); public ObjectReader withRootName(String rootName); public ObjectReader with(FormatSchema schema); public ObjectReader withType(JavaType valueType); public ObjectReader withType(Class<?> valueType); public ObjectReader withType(java.lang.reflect.Type valueType); public ObjectReader withType(TypeReference<?> valueTypeRef); public ObjectReader withValueToUpdate(Object value); public ObjectReader withView(Class<?> activeView); public ObjectReader with(Locale l); public ObjectReader with(TimeZone tz); public ObjectReader withHandler(DeserializationProblemHandler h); public ObjectReader with(Base64Variant defaultBase64); public ObjectReader withFormatDetection(ObjectReader... readers); public ObjectReader withFormatDetection(DataFormatReaders readers); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(JsonParser.Feature f); public DeserializationConfig getConfig(); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public TypeFactory getTypeFactory(); public T readValue(JsonParser jp) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readValue(InputStream src) throws IOException, JsonProcessingException; public T readValue(Reader src) throws IOException, JsonProcessingException; public T readValue(String src) throws IOException, JsonProcessingException; public T readValue(byte[] src) throws IOException, JsonProcessingException; public T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public T readValue(File src) throws IOException, JsonProcessingException; public T readValue(URL src) throws IOException, JsonProcessingException; public T readValue(JsonNode src) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public final MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException; public JsonNode createArrayNode(); public JsonNode createObjectNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException; protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException, JsonProcessingException; protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType); protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException; protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException; protected MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException; protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException; protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException; protected void _verifySchemaType(FormatSchema schema); protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected ObjectReader _with(DeserializationConfig newConfig); protected void _reportUndetectableSource(Object src) throws JsonProcessingException; protected InputStream _inputStream(URL src) throws IOException; protected InputStream _inputStream(File f) throws IOException; long serialVersionUID=Optional[-4251443320039569153L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; DeserializationConfig _config; DefaultDeserializationContext _context; JsonFactory _jsonFactory; boolean _unwrapRoot; JavaType _valueType; JsonDeserializer<Object> _rootDeserializer; Object _valueToUpdate; FormatSchema _schema; InjectableValues _injectableValues; DataFormatReaders _dataFormatReaders; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; RootNameLookup _rootNames"}
{"code": "public void testPolymorphicRoundtrip() throws Exception { [EOL]     Impl in1 = new Impl(123, 456); [EOL]     in1.next = new Impl(111, 222); [EOL]     in1.next.next = in1; [EOL]     String json = mapper.writeValueAsString(in1); [EOL]     Base result0 = mapper.readValue(json, Base.class); [EOL]     assertNotNull(result0); [EOL]     assertSame(Impl.class, result0.getClass()); [EOL]     Impl result = (Impl) result0; [EOL]     assertEquals(123, result.value); [EOL]     assertEquals(456, result.extra); [EOL]     Impl result2 = (Impl) result.next; [EOL]     assertEquals(111, result2.value); [EOL]     assertEquals(222, result2.extra); [EOL]     assertSame(result, result2.next); [EOL] }", "nl": "[LINE] SettableBeanProperty prop = _beanProperties.find(propName); [LINE] private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]         } else { [EOL]             handleUnknownVanilla(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] } public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews); protected BeanDeserializer(BeanDeserializerBase src); protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown); protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper); public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir); public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanDeserializer withObjectIdReader(ObjectIdReader oir); public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanDeserializerBase asArrayDeserializer(); public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; protected Object _missingToken(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]"}
{"code": "public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \\\"root\\\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \\\"leaf\\\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\\\"{\\\\\"id\\\\\":1,\\\\\"name\\\\\":\\\\\"root\\\\\",\\\\\"parent\\\\\":null,\\\\\"child\\\\\":\\\" + \\\"{\\\\\"id\\\\\":2,\\\\\"name\\\\\":\\\\\"leaf\\\\\",\\\\\"parent\\\\\":1,\\\\\"child\\\\\":null}}\\\", json); [EOL] }", "nl": "[LINE] contextual = contextual.withObjectIdWriter(oiw); [LINE] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\\\"\\\", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException(\\\"Invalid Object Id definition for \\\" + _handledType.getName() + \\\": can not find property with name '\\\" + propName + \\\"'\\\"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] } protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore); protected BeanSerializerBase(BeanSerializerBase src); protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper); public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter); protected abstract BeanSerializerBase withIgnorals(String[] toIgnore); protected abstract BeanSerializerBase asArraySerializer(); private static final BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer); public void resolve(SerializerProvider provider) throws JsonMappingException; protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public boolean usesObjectId(); public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final String _customTypeId(Object bean); protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; BeanPropertyWriter[] NO_PROPS=Optional[new BeanPropertyWriter[0]]; BeanPropertyWriter[] _props; BeanPropertyWriter[] _filteredProps; AnyGetterWriter _anyGetterWriter; Object _propertyFilterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter; JsonFormat.Shape _serializationShape"}
{"code": "public void testModifyKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule(\\\"test\\\").setDeserializerModifier(new KeyDeserializerModifier())); [EOL]     Map<?, ?> result = mapper.readValue(\\\"{\\\\\"a\\\\\":1}\\\", Map.class); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\\\"foo\\\", result.entrySet().iterator().next().getKey()); [EOL] }", "nl": "[LINE] public SimpleModule(String name) { [LINE] public SimpleModule(String name) { [EOL]     this(name, Version.unknownVersion()); [EOL] } public SimpleModule(); public SimpleModule(String name); public SimpleModule(Version version); public SimpleModule(String name, Version version); public SimpleModule(String name, Version version, Map<Class<?>, JsonDeserializer<?>> deserializers); public SimpleModule(String name, Version version, List<JsonSerializer<?>> serializers); public SimpleModule(String name, Version version, Map<Class<?>, JsonDeserializer<?>> deserializers, List<JsonSerializer<?>> serializers); public void setSerializers(SimpleSerializers s); public void setDeserializers(SimpleDeserializers d); public void setKeySerializers(SimpleSerializers ks); public void setKeyDeserializers(SimpleKeyDeserializers kd); public void setAbstractTypes(SimpleAbstractTypeResolver atr); public void setValueInstantiators(SimpleValueInstantiators svi); public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod); public SimpleModule setSerializerModifier(BeanSerializerModifier mod); public SimpleModule addSerializer(JsonSerializer<?> ser); public SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser); public SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser); public SimpleModule addDeserializer(Class<T> type, JsonDeserializer<? extends T> deser); public SimpleModule addKeyDeserializer(Class<?> type, KeyDeserializer deser); public SimpleModule addAbstractTypeMapping(Class<T> superType, Class<? extends T> subType); public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst); public SimpleModule registerSubtypes(Class<?>... subtypes); public SimpleModule registerSubtypes(NamedType... subtypes); public SimpleModule setMixInAnnotation(Class<?> targetType, Class<?> mixinClass); public String getModuleName(); public void setupModule(SetupContext context); public Version version(); long serialVersionUID=Optional[3132264350026957446L]; String _name; Version _version; SimpleSerializers _serializers=Optional[null]; SimpleDeserializers _deserializers=Optional[null]; SimpleSerializers _keySerializers=Optional[null]; SimpleKeyDeserializers _keyDeserializers=Optional[null]; SimpleAbstractTypeResolver _abstractTypes=Optional[null]; SimpleValueInstantiators _valueInstantiators=Optional[null]; BeanDeserializerModifier _deserializerModifier=Optional[null]; BeanSerializerModifier _serializerModifier=Optional[null]; HashMap<Class<?>, Class<?>> _mixins=Optional[null]; LinkedHashSet<NamedType> _subtypes=Optional[null]"}
{"code": "public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes(\\\"<POJO><x>1</x></POJO>\\\")); [EOL]         fail(\\\"Should have failed\\\"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, \\\"Can not detect format from input\\\"); [EOL]     } [EOL] }", "nl": "[LINE] DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [LINE] protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException { [EOL]     DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [EOL]     if (!match.hasMatch()) { [EOL]         _reportUnkownFormat(_dataFormatReaders, match); [EOL]     } [EOL]     JsonParser jp = match.createParserWithMatch(); [EOL]     return match.getReader()._bindAndClose(jp, _valueToUpdate); [EOL] } protected ObjectReader(ObjectMapper mapper, DeserializationConfig config); protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues); protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders); protected ObjectReader(ObjectReader base, DeserializationConfig config); protected ObjectReader(ObjectReader base, JsonFactory f); public Version version(); public ObjectReader with(DeserializationConfig config); public ObjectReader with(DeserializationFeature feature); public ObjectReader with(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withFeatures(DeserializationFeature... features); public ObjectReader without(DeserializationFeature feature); public ObjectReader without(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withoutFeatures(DeserializationFeature... features); public ObjectReader with(InjectableValues injectableValues); public ObjectReader with(JsonNodeFactory f); public ObjectReader with(JsonFactory f); public ObjectReader withRootName(String rootName); public ObjectReader with(FormatSchema schema); public ObjectReader withType(JavaType valueType); public ObjectReader withType(Class<?> valueType); public ObjectReader withType(java.lang.reflect.Type valueType); public ObjectReader withType(TypeReference<?> valueTypeRef); public ObjectReader withValueToUpdate(Object value); public ObjectReader withView(Class<?> activeView); public ObjectReader with(Locale l); public ObjectReader with(TimeZone tz); public ObjectReader withHandler(DeserializationProblemHandler h); public ObjectReader with(Base64Variant defaultBase64); public ObjectReader withFormatDetection(ObjectReader... readers); public ObjectReader withFormatDetection(DataFormatReaders readers); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(JsonParser.Feature f); public DeserializationConfig getConfig(); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public TypeFactory getTypeFactory(); public T readValue(JsonParser jp) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readValue(InputStream src) throws IOException, JsonProcessingException; public T readValue(Reader src) throws IOException, JsonProcessingException; public T readValue(String src) throws IOException, JsonProcessingException; public T readValue(byte[] src) throws IOException, JsonProcessingException; public T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public T readValue(File src) throws IOException, JsonProcessingException; public T readValue(URL src) throws IOException, JsonProcessingException; public T readValue(JsonNode src) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public final MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException; public JsonNode createArrayNode(); public JsonNode createObjectNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException; protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException, JsonProcessingException; protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType); protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException; protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException; protected MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException; protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException; protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException; protected void _verifySchemaType(FormatSchema schema); protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected ObjectReader _with(DeserializationConfig newConfig); protected void _reportUndetectableSource(Object src) throws JsonProcessingException; protected InputStream _inputStream(URL src) throws IOException; protected InputStream _inputStream(File f) throws IOException; long serialVersionUID=Optional[-4251443320039569153L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; DeserializationConfig _config; DefaultDeserializationContext _context; JsonFactory _jsonFactory; boolean _unwrapRoot; JavaType _valueType; JsonDeserializer<Object> _rootDeserializer; Object _valueToUpdate; FormatSchema _schema; InjectableValues _injectableValues; DataFormatReaders _dataFormatReaders; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; RootNameLookup _rootNames"}
{"code": "public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put(\\\"a\\\", 1); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":1}\\\", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty(\\\"line.separator\\\"); [EOL]     assertEquals(\\\"{\\\" + lf + \\\"  \\\\\"a\\\\\" : 1\\\" + lf + \\\"}\\\", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":1}\\\", writer.writeValueAsString(data)); [EOL] }", "nl": "[LINE] _serializerFactory = mapper._serializerFactory; [LINE] protected ObjectWriter(ObjectMapper mapper, SerializationConfig config) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     _rootType = null; [EOL]     _rootSerializer = null; [EOL]     _prettyPrinter = null; [EOL]     _schema = null; [EOL] } protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, JavaType rootType, PrettyPrinter pp); protected ObjectWriter(ObjectMapper mapper, SerializationConfig config); protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, FormatSchema s); protected ObjectWriter(ObjectWriter base, SerializationConfig config, JavaType rootType, JsonSerializer<Object> rootSer, PrettyPrinter pp, FormatSchema s); protected ObjectWriter(ObjectWriter base, SerializationConfig config); public Version version(); public ObjectWriter with(SerializationFeature feature); public ObjectWriter with(SerializationFeature first, SerializationFeature... other); public ObjectWriter withFeatures(SerializationFeature... features); public ObjectWriter without(SerializationFeature feature); public ObjectWriter without(SerializationFeature first, SerializationFeature... other); public ObjectWriter withoutFeatures(SerializationFeature... features); public ObjectWriter with(DateFormat df); public ObjectWriter withDefaultPrettyPrinter(); public ObjectWriter with(FilterProvider filterProvider); public ObjectWriter with(PrettyPrinter pp); public ObjectWriter withRootName(String rootName); public ObjectWriter withSchema(FormatSchema schema); public ObjectWriter withType(JavaType rootType); public ObjectWriter withType(Class<?> rootType); public ObjectWriter withType(TypeReference<?> rootType); public ObjectWriter withView(Class<?> view); public ObjectWriter with(Locale l); public ObjectWriter with(TimeZone tz); public ObjectWriter with(Base64Variant b64variant); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(JsonParser.Feature f); public SerializationConfig getConfig(); public JsonFactory getJsonFactory(); public JsonFactory getFactory(); public TypeFactory getTypeFactory(); public boolean hasPrefetchedSerializer(); public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public boolean canSerialize(Class<?> type); protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected void _verifySchemaType(FormatSchema schema); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType); private void _configureJsonGenerator(JsonGenerator jgen); long serialVersionUID=Optional[-7024829992408267532L]; PrettyPrinter NULL_PRETTY_PRINTER=Optional[new MinimalPrettyPrinter()]; SerializationConfig _config; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; JsonFactory _jsonFactory; JavaType _rootType; JsonSerializer<Object> _rootSerializer; PrettyPrinter _prettyPrinter; FormatSchema _schema"}
{"code": "public void testSerializedAsListWithClassAnnotations() throws IOException { [EOL]     SimpleValueList list = new SimpleValueList(); [EOL]     list.add(new ActualValue(\\\"foo\\\")); [EOL]     assertEquals(\\\"[{\\\\\"value\\\\\":\\\\\"foo\\\\\"}]\\\", MAPPER.writeValueAsString(list)); [EOL] }", "nl": "[LINE] try { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapType)) { [EOL]                 throw new IllegalArgumentException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map type\\\"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapType) type).widenKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage()); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.widenContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] } protected BasicSerializerFactory(SerializerFactoryConfig config); public SerializerFactoryConfig getFactoryConfig(); public abstract SerializerFactory withConfig(SerializerFactoryConfig config); public final SerializerFactory withAdditionalSerializers(Serializers additional); public final SerializerFactory withAdditionalKeySerializers(Serializers additional); public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier); public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl); public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType); public final JsonSerializer<?> getNullSerializer(); protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping); protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException; protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected boolean isIndexedList(Class<?> cls); protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type); protected static T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type); protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property); protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer); protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); HashMap<String, JsonSerializer<?>> _concrete=Optional[new HashMap<String, JsonSerializer<?>>()]; HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy=Optional[new HashMap<String, Class<? extends JsonSerializer<?>>>()]; SerializerFactoryConfig _factoryConfig"}
{"code": "public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }", "nl": "[LINE] Object ob = jp.getEmbeddedObject(); [LINE] @Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, \\\"Can not convert a JSON String of length \\\" + str.length() + \\\" into a char element of char array\\\"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] } protected PrimitiveArrayDeserializers(Class<T> cls); public CharDeser(); public BooleanDeser(); public ByteDeser(); public ShortDeser(); public IntDeser(); public LongDeser(); public FloatDeser(); public DoubleDeser(); public static JsonDeserializer<?> forType(Class<?> rawType); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException"}
{"code": "public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\\\"a\\\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":{\\\\\"a\\\\\":3}}\\\", listJson); [EOL] }", "nl": "[LINE] if (_cacheKey == null) { [LINE] public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] } private ReadOnlyClassToSerializerMap(JsonSerializerMap map); public ReadOnlyClassToSerializerMap instance(); public static ReadOnlyClassToSerializerMap from(HashMap<TypeKey, JsonSerializer<Object>> src); public JsonSerializer<Object> typedValueSerializer(JavaType type); public JsonSerializer<Object> typedValueSerializer(Class<?> cls); public JsonSerializer<Object> untypedValueSerializer(JavaType type); public JsonSerializer<Object> untypedValueSerializer(Class<?> cls); JsonSerializerMap _map; TypeKey _cacheKey=Optional[null]"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testSuperClass() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SubType bean = new SubType(); [EOL]     Map<String, Object> result = writeAndMap(mapper, bean); [EOL]     assertEquals(4, result.size()); [EOL]     assertEquals(\\\"a\\\", result.get(\\\"a\\\")); [EOL]     assertEquals(Integer.valueOf(3), result.get(\\\"b\\\")); [EOL]     assertEquals(\\\"x\\\", result.get(\\\"a2\\\")); [EOL]     assertEquals(Boolean.TRUE, result.get(\\\"b2\\\")); [EOL]     ObjectWriter w = mapper.writerWithType(BaseType.class); [EOL]     String json = w.writeValueAsString(bean); [EOL]     result = (Map<String, Object>) mapper.readValue(json, Map.class); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(\\\"a\\\", result.get(\\\"a\\\")); [EOL]     assertEquals(Integer.valueOf(3), result.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] _serializerFactory = mapper._serializerFactory; [LINE] protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, JavaType rootType, PrettyPrinter pp) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     if (rootType != null) { [EOL]         rootType = rootType.withStaticTyping(); [EOL]     } [EOL]     _rootType = rootType; [EOL]     _prettyPrinter = pp; [EOL]     _schema = null; [EOL]     _rootSerializer = _prefetchRootSerializer(config, rootType); [EOL] } protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, JavaType rootType, PrettyPrinter pp); protected ObjectWriter(ObjectMapper mapper, SerializationConfig config); protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, FormatSchema s); protected ObjectWriter(ObjectWriter base, SerializationConfig config, JavaType rootType, JsonSerializer<Object> rootSer, PrettyPrinter pp, FormatSchema s); protected ObjectWriter(ObjectWriter base, SerializationConfig config); public Version version(); public ObjectWriter with(SerializationFeature feature); public ObjectWriter with(SerializationFeature first, SerializationFeature... other); public ObjectWriter withFeatures(SerializationFeature... features); public ObjectWriter without(SerializationFeature feature); public ObjectWriter without(SerializationFeature first, SerializationFeature... other); public ObjectWriter withoutFeatures(SerializationFeature... features); public ObjectWriter with(DateFormat df); public ObjectWriter withDefaultPrettyPrinter(); public ObjectWriter with(FilterProvider filterProvider); public ObjectWriter with(PrettyPrinter pp); public ObjectWriter withRootName(String rootName); public ObjectWriter withSchema(FormatSchema schema); public ObjectWriter withType(JavaType rootType); public ObjectWriter withType(Class<?> rootType); public ObjectWriter withType(TypeReference<?> rootType); public ObjectWriter withView(Class<?> view); public ObjectWriter with(Locale l); public ObjectWriter with(TimeZone tz); public ObjectWriter with(Base64Variant b64variant); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(JsonParser.Feature f); public SerializationConfig getConfig(); public JsonFactory getJsonFactory(); public JsonFactory getFactory(); public TypeFactory getTypeFactory(); public boolean hasPrefetchedSerializer(); public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public boolean canSerialize(Class<?> type); protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected void _verifySchemaType(FormatSchema schema); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType); private void _configureJsonGenerator(JsonGenerator jgen); long serialVersionUID=Optional[-7024829992408267532L]; PrettyPrinter NULL_PRETTY_PRINTER=Optional[new MinimalPrettyPrinter()]; SerializationConfig _config; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; JsonFactory _jsonFactory; JavaType _rootType; JsonSerializer<Object> _rootSerializer; PrettyPrinter _prettyPrinter; FormatSchema _schema"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public MemberKey(Method m); public MemberKey(Constructor<?> ctor); public MemberKey(String name, Class<?>[] argTypes); public String toString(); public int hashCode(); public boolean equals(Object o); Class<?>[] NO_CLASSES=Optional[new Class<?>[0]]; String _name; Class<?>[] _argTypes"}
{"code": "public void testSimpleSetterlessCollectionFailure() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)); [EOL]     m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false); [EOL]     assertFalse(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)); [EOL]     try { [EOL]         m.readValue(\\\"{\\\\\"values\\\\\":[ \\\\\"abc\\\\\", \\\\\"def\\\\\" ]}\\\", CollectionBean.class); [EOL]         fail(\\\"Expected an exception\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Unrecognized field\\\"); [EOL]     } [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] } protected BeanDeserializerBase(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews); protected BeanDeserializerBase(BeanDeserializerBase src); protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown); protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper); public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir); public BeanDeserializerBase(BeanDeserializerBase src, HashSet<String> ignorableProps); public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir); public abstract BeanDeserializerBase withIgnorableProperties(HashSet<String> ignorableProps); protected abstract BeanDeserializerBase asArrayDeserializer(); public void resolve(DeserializationContext ctxt) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, SettableBeanProperty prop) throws JsonMappingException; public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop); protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop); protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop); public boolean isCachable(); public ObjectIdReader getObjectIdReader(); public boolean hasProperty(String propertyName); public boolean hasViews(); public int getPropertyCount(); public Collection<Object> getKnownPropertyNames(); public final Class<?> getBeanClass(); public JavaType getValueType(); public Iterator<SettableBeanProperty> properties(); public Iterator<SettableBeanProperty> creatorProperties(); public SettableBeanProperty findProperty(String propertyName); public SettableBeanProperty findBackReference(String logicalName); public ValueInstantiator getValueInstantiator(); public void replaceProperty(SettableBeanProperty original, SettableBeanProperty replacement); public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException; protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt, Object bean, String propName) throws IOException, JsonProcessingException; protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException; public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException; public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException; protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt) throws IOException; long serialVersionUID=Optional[-2038793552422727904L]; Annotations _classAnnotations; JavaType _beanType; JsonFormat.Shape _serializationShape; ValueInstantiator _valueInstantiator; JsonDeserializer<Object> _delegateDeserializer; PropertyBasedCreator _propertyBasedCreator; boolean _nonStandardCreation; boolean _vanillaProcessing; BeanPropertyMap _beanProperties; ValueInjector[] _injectables; SettableAnyProperty _anySetter; HashSet<String> _ignorableProps; boolean _ignoreAllUnknown; boolean _needViewProcesing; Map<String, SettableBeanProperty> _backRefs; HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers; UnwrappedPropertyHandler _unwrappedPropertyHandler; ExternalTypeHandler _externalTypeIdHandler; ObjectIdReader _objectIdReader"}
{"code": "public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot(\\\"Fred\\\", 25)); [EOL]     assertEquals(\\\"{\\\\\"general.names.name\\\\\":\\\\\"Fred\\\\\",\\\\\"misc.value\\\\\":25}\\\", json); [EOL] }", "nl": "[LINE] return new UnwrappingBeanPropertyWriter(this, transformer, new SerializedString(newName)); [LINE] @Override [EOL] public UnwrappingBeanPropertyWriter rename(NameTransformer transformer) { [EOL]     String oldName = _name.getValue(); [EOL]     String newName = transformer.transform(oldName); [EOL]     transformer = NameTransformer.chainedTransformer(transformer, _nameTransformer); [EOL]     return new UnwrappingBeanPropertyWriter(this, transformer, new SerializedString(newName)); [EOL] } public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, NameTransformer unwrapper); private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, NameTransformer transformer, SerializedString name); public UnwrappingBeanPropertyWriter rename(NameTransformer transformer); public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void assignSerializer(JsonSerializer<Object> ser); protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; NameTransformer _nameTransformer"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] return _fieldMinLevel.isVisible(f); [LINE] @Override [EOL] public boolean isFieldVisible(Field f) { [EOL]     return _fieldMinLevel.isVisible(f); [EOL] } public Std(JsonAutoDetect ann); public Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field); public Std(Visibility v); public T with(JsonAutoDetect ann); public T with(Visibility v); public T withVisibility(PropertyAccessor method, Visibility v); public T withGetterVisibility(Visibility v); public T withIsGetterVisibility(Visibility v); public T withSetterVisibility(Visibility v); public T withCreatorVisibility(Visibility v); public T withFieldVisibility(Visibility v); public boolean isGetterVisible(Method m); public boolean isGetterVisible(AnnotatedMethod m); public boolean isIsGetterVisible(Method m); public boolean isIsGetterVisible(AnnotatedMethod m); public boolean isSetterVisible(Method m); public boolean isSetterVisible(AnnotatedMethod m); public boolean isCreatorVisible(Member m); public boolean isCreatorVisible(AnnotatedMember m); public boolean isFieldVisible(Field f); public boolean isFieldVisible(AnnotatedField f); public static Std defaultInstance(); public Std with(JsonAutoDetect ann); public Std with(Visibility v); public Std withVisibility(PropertyAccessor method, Visibility v); public Std withGetterVisibility(Visibility v); public Std withIsGetterVisibility(Visibility v); public Std withSetterVisibility(Visibility v); public Std withCreatorVisibility(Visibility v); public Std withFieldVisibility(Visibility v); public boolean isCreatorVisible(Member m); public boolean isCreatorVisible(AnnotatedMember m); public boolean isFieldVisible(Field f); public boolean isFieldVisible(AnnotatedField f); public boolean isGetterVisible(Method m); public boolean isGetterVisible(AnnotatedMethod m); public boolean isIsGetterVisible(Method m); public boolean isIsGetterVisible(AnnotatedMethod m); public boolean isSetterVisible(Method m); public boolean isSetterVisible(AnnotatedMethod m); public String toString()"}
{"code": "public void testDateScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     long ts = 12345678L; [EOL]     assertEquals(\\\"[[\\\\\"java.util.Date\\\\\",\\\" + ts + \\\"]]\\\", m.writeValueAsString(new Object[] { new Date(ts) })); [EOL]     Calendar c = Calendar.getInstance(); [EOL]     c.setTimeInMillis(ts); [EOL]     String json = m.writeValueAsString(new Object[] { c }); [EOL]     assertEquals(\\\"[[\\\\\"\\\" + c.getClass().getName() + \\\"\\\\\",\\\" + ts + \\\"]]\\\", json); [EOL]     Object[] result = m.readValue(json, Object[].class); [EOL]     assertEquals(1, result.length); [EOL]     assertTrue(result[0] instanceof Calendar); [EOL]     assertEquals(ts, ((Calendar) result[0]).getTimeInMillis()); [EOL] }", "nl": "[LINE] if (_useTimestamp) { [LINE] @Override [EOL] public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value.getTime(), jgen); [EOL]     } [EOL] } public CalendarSerializer(); public CalendarSerializer(boolean useTimestamp, DateFormat customFormat); public CalendarSerializer withFormat(boolean timestamp, DateFormat customFormat); protected long _timestamp(Calendar value); public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; CalendarSerializer instance=Optional[new CalendarSerializer()]"}
{"code": "public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals(\\\"Should deserialize to equal XMLGregorianCalendar ('\\\" + exp + \\\"')\\\", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }", "nl": "[LINE] GregorianCalendar calendar = new GregorianCalendar(); [LINE] @Override [EOL] public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     GregorianCalendar calendar = new GregorianCalendar(); [EOL]     calendar.setTime(d); [EOL]     TimeZone tz = ctxt.getTimeZone(); [EOL]     if (tz != null) { [EOL]         calendar.setTimeZone(tz); [EOL]     } [EOL]     return _dataTypeFactory.newXMLGregorianCalendar(calendar); [EOL] } public DurationDeserializer(); public GregorianCalendarDeserializer(); public QNameDeserializer(); public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc); protected Duration _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException; public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected QName _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException; DatatypeFactory _dataTypeFactory"}
{"code": "public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\\\"{\\\\\"bar\\\\\":3}\\\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\\\"Should have failed binding\\\"); [EOL]     } [EOL]     assertEquals(\\\"bar\\\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \\\"propX\\\"); [EOL] }", "nl": "[LINE] Class<?> cls = (_from instanceof Class<?>) ? [LINE] @Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     Class<?> cls = (_from instanceof Class<?>) ? ((Class<?>) _from) : _from.getClass(); [EOL]     Package pkg = cls.getPackage(); [EOL]     if (pkg != null) { [EOL]         sb.append(pkg.getName()); [EOL]         sb.append('.'); [EOL]     } [EOL]     sb.append(cls.getSimpleName()); [EOL]     sb.append('['); [EOL]     if (_fieldName != null) { [EOL]         sb.append('\\\"'); [EOL]         sb.append(_fieldName); [EOL]         sb.append('\\\"'); [EOL]     } else if (_index >= 0) { [EOL]         sb.append(_index); [EOL]     } else { [EOL]         sb.append('?'); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] } protected Reference(); public Reference(Object from); public Reference(Object from, String fieldName); public Reference(Object from, int index); public JsonMappingException(String msg); public JsonMappingException(String msg, Throwable rootCause); public JsonMappingException(String msg, JsonLocation loc); public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause); public void setFrom(Object o); public void setFieldName(String n); public void setIndex(int ix); public Object getFrom(); public String getFieldName(); public int getIndex(); public String toString(); public static JsonMappingException from(JsonParser jp, String msg); public static JsonMappingException from(JsonParser jp, String msg, Throwable problem); public static JsonMappingException fromUnexpectedIOE(IOException src); public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName); public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index); public static JsonMappingException wrapWithPath(Throwable src, Reference ref); public List<Reference> getPath(); public String getPathReference(); public StringBuilder getPathReference(StringBuilder sb); public void prependPath(Object referrer, String fieldName); public void prependPath(Object referrer, int index); public void prependPath(Reference r); public String getLocalizedMessage(); public String getMessage(); protected String _buildMessage(); public String toString(); protected void _appendPathDesc(StringBuilder sb); long serialVersionUID=Optional[1L]; int MAX_REFS_TO_LIST=Optional[1000]; LinkedList<Reference> _path"}
{"code": "public void testTreeRead() throws Exception { [EOL]     String JSON = \\\"{ }\\\"; [EOL]     JsonNode n = MAPPER.readTree(JSON); [EOL]     assertTrue(n instanceof ObjectNode); [EOL]     n = MAPPER.readTree(new StringReader(JSON)); [EOL]     assertTrue(n instanceof ObjectNode); [EOL]     n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes(\\\"UTF-8\\\"))); [EOL]     assertTrue(n instanceof ObjectNode); [EOL] }", "nl": "[LINE] return (n == null) ? NullNode.instance : n; [LINE] public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals(\\\"0.25\\\", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] } public FloatNode(float v); public static FloatNode valueOf(float v); public JsonToken asToken(); public JsonParser.NumberType numberType(); public boolean isFloatingPointNumber(); public boolean isFloat(); public boolean canConvertToInt(); public boolean canConvertToLong(); public Number numberValue(); public short shortValue(); public int intValue(); public long longValue(); public float floatValue(); public double doubleValue(); public BigDecimal decimalValue(); public BigInteger bigIntegerValue(); public String asText(); public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public boolean equals(Object o); public int hashCode(); float _value"}
{"code": "public void testSimpleMapField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanMap map = new FieldWrapperBeanMap(); [EOL]     map.put(\\\"foop\\\", new FieldWrapperBean(new IntWrapper(13))); [EOL]     String json = mapper.writeValueAsString(map); [EOL]     FieldWrapperBeanMap result = mapper.readValue(json, FieldWrapperBeanMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = result.get(\\\"foop\\\"); [EOL]     assertNotNull(bean); [EOL]     Object ob = bean.value; [EOL]     assertEquals(IntWrapper.class, ob.getClass()); [EOL]     assertEquals(((IntWrapper) ob).i, 13); [EOL] }", "nl": "[LINE] jgen.writeFieldName(value); [LINE] @Override [EOL] public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeFieldName(value); [EOL] } private StdKeySerializers(); public StringKeySerializer(); public DateKeySerializer(); public CalendarKeySerializer(); public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType); public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; JsonSerializer<Object> DEFAULT_KEY_SERIALIZER=Optional[new StdKeySerializer()]; JsonSerializer<Object> DEFAULT_STRING_SERIALIZER=Optional[(JsonSerializer<Object>) (JsonSerializer<?>) new StringKeySerializer()]"}
{"code": "public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue(\\\"123\\\", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }", "nl": "[LINE] return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] } public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator); protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser); protected CollectionDeserializer(CollectionDeserializer src); protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd); public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException; long serialVersionUID=Optional[-2003828398549708958L]; JavaType _collectionType; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; ValueInstantiator _valueInstantiator; JsonDeserializer<Object> _delegateDeserializer"}
{"code": "public void testRootWrapping() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true); [EOL]     String json = mapper.writeValueAsString(new StringWrapper(\\\"abc\\\")); [EOL]     assertEquals(\\\"{\\\\\"StringWrapper\\\\\":{\\\\\"str\\\\\":\\\\\"abc\\\\\"}}\\\", json); [EOL] }", "nl": "[LINE] AnnotationIntrospector intr = config.getAnnotationIntrospector(); [LINE] public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] } public RootNameLookup(); public SerializedString findRootName(JavaType rootType, MapperConfig<?> config); public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config); long serialVersionUID=Optional[1L]; LRUMap<ClassKey, SerializedString> _rootNames"}
{"code": "public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\\\"{\\\\\"bar\\\\\":3}\\\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\\\"Should have failed binding\\\"); [EOL]     } [EOL]     assertEquals(\\\"bar\\\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \\\"propX\\\"); [EOL] }", "nl": "[LINE] return _unrecognizedPropertyName; [LINE] public String getUnrecognizedPropertyName() { [EOL]     return _unrecognizedPropertyName; [EOL] } public UnrecognizedPropertyException(String msg, JsonLocation loc, Class<?> referringClass, String propName, Collection<Object> propertyIds); public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName, Collection<Object> propertyIds); public String getMessageSuffix(); public Class<?> getReferringClass(); public String getUnrecognizedPropertyName(); public Collection<Object> getKnownPropertyIds(); long serialVersionUID=Optional[1L]; Class<?> _referringClass; String _unrecognizedPropertyName; Collection<Object> _propertyIds; String _propertiesAsString; int MAX_DESC_LENGTH=Optional[200]"}
{"code": "public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode(\\\"root\\\"); [EOL]     FullTreeNode child1 = new FullTreeNode(\\\"kid1\\\"); [EOL]     FullTreeNode child2 = new FullTreeNode(\\\"kid2\\\"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals(\\\"root\\\", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals(\\\"kid1\\\", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals(\\\"kid2\\\", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }", "nl": "[LINE] try { [LINE] @Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL]     return instance; [EOL] } public FieldProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field); protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser); protected FieldProperty(FieldProperty src, String newName); protected FieldProperty(FieldProperty src, Field f); public FieldProperty withName(String newName); public FieldProperty withValueDeserializer(JsonDeserializer<?> deser); public A getAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public final void set(Object instance, Object value) throws IOException; public Object setAndReturn(Object instance, Object value) throws IOException;  Object readResolve(); long serialVersionUID=Optional[1L]; AnnotatedField _annotated; Field _field"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] final SerializationConfig config = prov.getConfig(); [LINE] @Override [EOL] @SuppressWarnings(\\\"unchecked\\\") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testWithoutModule() { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     try { [EOL]         mapper.writeValueAsString(new CustomBean(\\\"foo\\\", 3)); [EOL]         fail(\\\"Should have caused an exception\\\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \\\"No serializer found\\\"); [EOL]     } [EOL]     try { [EOL]         mapper.readValue(\\\"{\\\\\"str\\\\\":\\\\\"ab\\\\\",\\\\\"num\\\\\":2}\\\", CustomBean.class); [EOL]         fail(\\\"Should have caused an exception\\\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \\\"No suitable constructor found\\\"); [EOL]     } [EOL] }", "nl": "[LINE] return null; [LINE] protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] } protected BasicSerializerFactory(SerializerFactoryConfig config); public SerializerFactoryConfig getFactoryConfig(); public abstract SerializerFactory withConfig(SerializerFactoryConfig config); public final SerializerFactory withAdditionalSerializers(Serializers additional); public final SerializerFactory withAdditionalKeySerializers(Serializers additional); public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier); public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl); public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType); public final JsonSerializer<?> getNullSerializer(); protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping); protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException; protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected boolean isIndexedList(Class<?> cls); protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type); protected static T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type); protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property); protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer); protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); HashMap<String, JsonSerializer<?>> _concrete=Optional[new HashMap<String, JsonSerializer<?>>()]; HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy=Optional[new HashMap<String, Class<? extends JsonSerializer<?>>>()]; SerializerFactoryConfig _factoryConfig"}
{"code": "public void testCustomContentSerializer() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MyObject object = new MyObject(); [EOL]     object.list = Arrays.asList(\\\"foo\\\"); [EOL]     String json = m.writeValueAsString(object); [EOL]     assertEquals(\\\"{\\\\\"list\\\\\":[\\\\\"bar\\\\\"]}\\\", json); [EOL] }", "nl": "[LINE] final JsonSerializer<String> ser = _serializer; [LINE] private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         final JsonSerializer<String> ser = _serializer; [EOL]         for (i = 0; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 ser.serialize(str, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] } protected IndexedStringListSerializer(); public IndexedStringListSerializer(JsonSerializer<?> ser); protected JsonNode contentSchema(); protected void acceptContentVisitor(JsonArrayFormatVisitor visitor) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private final void _serializeUnwrapped(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(List<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException; private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException; IndexedStringListSerializer instance=Optional[new IndexedStringListSerializer()]; JsonSerializer<String> _serializer"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] return findTypeDeserializer(config, contentType); [LINE] public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType); [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai, contentType); [EOL]     return b.buildTypeDeserializer(config, contentType, subtypes); [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testArrayIdentityTransforms() throws Exception { [EOL]     verifyByteArrayConversion(bytes(), byte[].class); [EOL]     verifyShortArrayConversion(shorts(), short[].class); [EOL]     verifyIntArrayConversion(ints(), int[].class); [EOL]     verifyLongArrayConversion(longs(), long[].class); [EOL]     verifyFloatArrayConversion(floats(), float[].class); [EOL]     verifyDoubleArrayConversion(doubles(), float[].class); [EOL] }", "nl": "[LINE] return getNumberValue().floatValue(); [LINE] @Override [EOL] public float getFloatValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().floatValue(); [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public AnnotationIntrospector.ReferenceProperty findReferenceType() { [EOL]     return fromMemberAnnotations(new WithMember<AnnotationIntrospector.ReferenceProperty>() { [EOL]  [EOL]         @Override [EOL]         public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.findReferenceType(member); [EOL]         } [EOL]     }); [EOL] } public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector, boolean forSerialization); public POJOPropertyBuilder(POJOPropertyBuilder src, String newName); public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored); public POJOPropertyBuilder withName(String newName); public int compareTo(POJOPropertyBuilder other); public String getName(); public String getInternalName(); public PropertyName getWrapperName(); public boolean isExplicitlyIncluded(); public boolean hasGetter(); public boolean hasSetter(); public boolean hasField(); public boolean hasConstructorParameter(); public boolean couldSerialize(); public AnnotatedMethod getGetter(); public AnnotatedMethod getSetter(); public AnnotatedField getField(); public AnnotatedParameter getConstructorParameter(); public AnnotatedMember getAccessor(); public AnnotatedMember getMutator(); public AnnotatedMember getPrimaryMember(); public Class<?>[] withMember(AnnotatedMember member); public Class<?>[] findViews(); public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member); public AnnotationIntrospector.ReferenceProperty findReferenceType(); public Boolean withMember(AnnotatedMember member); public boolean isTypeId(); public Boolean withMember(AnnotatedMember member); public boolean isRequired(); public ObjectIdInfo withMember(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(); public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored); public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored); public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addAll(POJOPropertyBuilder src); private static Linked<T> merge(Linked<T> chain1, Linked<T> chain2); public void removeIgnored(); public void removeNonVisible(); public void removeNonVisible(boolean force); public void trimByVisibility(); public void mergeAnnotations(boolean forSerialization); private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes); private Linked<T> _removeIgnored(Linked<T> node); private Linked<T> _removeNonVisible(Linked<T> node); private Linked<T> _trimByVisibility(Linked<T> node); private boolean _anyExplicitNames(Linked<T> n); public boolean anyVisible(); private boolean _anyVisible(Linked<T> n); public boolean anyIgnorals(); private boolean _anyIgnorals(Linked<T> n); public String findNewName(); private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed); public String toString(); protected T fromMemberAnnotations(WithMember<T> func); public T withMember(AnnotatedMember member); public Linked<T> withValue(T newValue); public Linked<T> withNext(Linked<T> newNext); public Linked<T> withoutIgnored(); public Linked<T> withoutNonVisible(); private Linked<T> append(Linked<T> appendable); public Linked<T> trimByVisibility(); public String toString(); boolean _forSerialization; AnnotationIntrospector _annotationIntrospector; String _name; String _internalName; Linked<AnnotatedField> _fields; Linked<AnnotatedParameter> _ctorParameters; Linked<AnnotatedMethod> _getters; Linked<AnnotatedMethod> _setters"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get(\\\"value\\\"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get(\\\"x\\\")); [EOL] }", "nl": "[LINE] if (jp.nextToken() != JsonToken.FIELD_NAME) { // single entry; but we want modifiable [LINE] protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] } public UntypedObjectDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Object[] NO_OBJECTS=Optional[new Object[0]]; UntypedObjectDeserializer instance=Optional[new UntypedObjectDeserializer()]"}
{"code": "public void testTyped() { [EOL]     _testObjectBuffer(Integer.class); [EOL] }", "nl": "[LINE] @SuppressWarnings(\\\"unchecked\\\") [LINE] public <T> T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     @SuppressWarnings(\\\"unchecked\\\") [EOL]     T[] result = (T[]) Array.newInstance(componentType, totalSize); [EOL]     _copyTo(result, totalSize, lastChunk, lastChunkEntries); [EOL]     _reset(); [EOL]     return result; [EOL] } public ObjectBuffer(); public Node(Object[] data); public Object[] resetAndStart(); public Object[] appendCompletedChunk(Object[] fullChunk); public Object[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries); public T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType); public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList); public int initialCapacity(); public int bufferedSize(); protected void _reset(); protected final void _copyTo(Object resultArray, int totalSize, Object[] lastChunk, int lastChunkEntries); public Object[] getData(); public Node next(); public void linkNext(Node next); int INITIAL_CHUNK_SIZE=Optional[12]; int SMALL_CHUNK_SIZE=Optional[(1 << 14)]; int MAX_CHUNK_SIZE=Optional[(1 << 18)]; Node _bufferHead; Node _bufferTail; int _bufferedEntryCount; Object[] _freeBuffer"}
{"code": "public void testPolymorphicRoundtrip() throws Exception { [EOL]     Impl in1 = new Impl(123, 456); [EOL]     in1.next = new Impl(111, 222); [EOL]     in1.next.next = in1; [EOL]     String json = mapper.writeValueAsString(in1); [EOL]     Base result0 = mapper.readValue(json, Base.class); [EOL]     assertNotNull(result0); [EOL]     assertSame(Impl.class, result0.getClass()); [EOL]     Impl result = (Impl) result0; [EOL]     assertEquals(123, result.value); [EOL]     assertEquals(456, result.extra); [EOL]     Impl result2 = (Impl) result.next; [EOL]     assertEquals(111, result2.value); [EOL]     assertEquals(222, result2.extra); [EOL]     assertSame(result, result2.next); [EOL] }", "nl": "[LINE] final String propName = newProperty.getName(); [LINE] public BeanPropertyMap withProperty(SettableBeanProperty newProperty) { [EOL]     final int bcount = _buckets.length; [EOL]     Bucket[] newBuckets = new Bucket[bcount]; [EOL]     System.arraycopy(_buckets, 0, newBuckets, 0, bcount); [EOL]     final String propName = newProperty.getName(); [EOL]     SettableBeanProperty oldProp = find(newProperty.getName()); [EOL]     if (oldProp == null) { [EOL]         int index = propName.hashCode() & _hashMask; [EOL]         newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty, _nextBucketIndex++); [EOL]         return new BeanPropertyMap(newBuckets, _size + 1, _nextBucketIndex); [EOL]     } [EOL]     BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex); [EOL]     newMap.replace(newProperty); [EOL]     return newMap; [EOL] } public BeanPropertyMap(Collection<SettableBeanProperty> properties); private BeanPropertyMap(Bucket[] buckets, int size, int index); public Bucket(Bucket next, String key, SettableBeanProperty value, int index); public IteratorImpl(Bucket[] buckets); public BeanPropertyMap withProperty(SettableBeanProperty newProperty); public BeanPropertyMap renameAll(NameTransformer transformer); public BeanPropertyMap assignIndexes(); private static final int findSize(int size); public String toString(); public Iterator<SettableBeanProperty> iterator(); public SettableBeanProperty[] getPropertiesInInsertionOrder(); public int size(); public SettableBeanProperty find(String key); public void replace(SettableBeanProperty property); public void remove(SettableBeanProperty property); private SettableBeanProperty _findWithEquals(String key, int index); public boolean hasNext(); public SettableBeanProperty next(); public void remove(); long serialVersionUID=Optional[1L]; Bucket[] _buckets; int _hashMask; int _size; int _nextBucketIndex=Optional[0]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { [EOL]     return size() > _maxEntries; [EOL] } public LRUMap(int initialEntries, int maxEntries); protected boolean removeEldestEntry(Map.Entry<K, V> eldest); private void readObject(ObjectInputStream in) throws IOException; private void writeObject(ObjectOutputStream out) throws IOException; protected Object readResolve(); long serialVersionUID=Optional[1L]; int _maxEntries; int _jdkSerializeMaxEntries"}
{"code": "public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"abc:\\\")); [EOL]     MyMap map = mapper.readValue(\\\"{\\\\\"a\\\\\":\\\\\"b\\\\\"}\\\", MyMap.class); [EOL]     assertEquals(\\\"{\\\\\"KEY\\\\\":\\\\\"b\\\\\"}\\\", mapper.writeValueAsString(map)); [EOL] }", "nl": "[LINE] keyType = type.getKeyType(); // just in case it's used below [LINE] private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, \\\"findContentDeserializer\\\", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] } public DeserializerCache();  Object writeReplace(); public int cachedDeserializersCount(); public void flushCachedDeserializers(); public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException; public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type); protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type); protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException; protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException; private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException; private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException; protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException; long serialVersionUID=Optional[1L]; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2)]; HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers=Optional[new HashMap<JavaType, JsonDeserializer<Object>>(8)]"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] _suppressNulls = suppressNulls; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException(\\\"Can not pass member of type \\\" + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] } public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue); protected BeanPropertyWriter(BeanPropertyWriter base); protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name); public BeanPropertyWriter rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper); public void setNonTrivialBaseType(JavaType t); public String getName(); public JavaType getType(); public PropertyName getWrapperName(); public boolean isRequired(); public A getAnnotation(Class<A> acls); public A getContextAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; public Object getInternalSetting(Object key); public Object setInternalSetting(Object key, Object value); public Object removeInternalSetting(Object key); public SerializedString getSerializedName(); public boolean hasSerializer(); public boolean hasNullSerializer(); public boolean willSuppressNulls(); public JsonSerializer<Object> getSerializer(); public JavaType getSerializationType(); public Class<?> getRawSerializationType(); public Class<?> getPropertyType(); public Type getGenericPropertyType(); public Class<?>[] getViews(); protected boolean isRequired(AnnotationIntrospector intr); public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException; public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; public final Object get(Object bean) throws Exception; protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException; public String toString(); Object MARKER_FOR_EMPTY=Optional[new Object()]; AnnotatedMember _member; Annotations _contextAnnotations; JavaType _declaredType; Method _accessorMethod; Field _field; HashMap<Object, Object> _internalSettings; SerializedString _name; PropertyName _wrapperName; JavaType _cfgSerializationType; JsonSerializer<Object> _serializer; JsonSerializer<Object> _nullSerializer; PropertySerializerMap _dynamicSerializers; boolean _suppressNulls; Object _suppressableValue; Class<?>[] _includeInViews; TypeSerializer _typeSerializer; JavaType _nonTrivialBaseType; boolean _isRequired"}
{"code": "public void testDelegating() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\\\"test\\\", Version.unknownVersion()); [EOL]     module.addSerializer(new StdDelegatingSerializer(Immutable.class, new StdConverter<Immutable, Map<String, Integer>>() { [EOL]  [EOL]         @Override [EOL]         public Map<String, Integer> convert(Immutable value) { [EOL]             HashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]             map.put(\\\"x\\\", value.x()); [EOL]             map.put(\\\"y\\\", value.y()); [EOL]             return map; [EOL]         } [EOL]     })); [EOL]     mapper.registerModule(module); [EOL]     assertEquals(\\\"{\\\\\"x\\\\\":3,\\\\\"y\\\\\":7}\\\", mapper.writeValueAsString(new Immutable())); [EOL] }", "nl": "[LINE] @SuppressWarnings(\\\"unchecked\\\") [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public <T> StdDelegatingSerializer(Class<T> cls, Converter<T, ?> converter) { [EOL]     super(cls, false); [EOL]     _converter = (Converter<Object, ?>) converter; [EOL]     _delegateType = null; [EOL]     _delegateSerializer = null; [EOL] } public StdDelegatingSerializer(Converter<?, ?> converter); public StdDelegatingSerializer(Class<T> cls, Converter<T, ?> converter); public StdDelegatingSerializer(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer); protected StdDelegatingSerializer withDelegate(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer); public void resolve(SerializerProvider provider) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; protected Converter<Object, ?> getConverter(); public JsonSerializer<?> getDelegatee(); public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException; public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException; public boolean isEmpty(Object value); public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; protected Object convertValue(Object value); Converter<Object, ?> _converter; JavaType _delegateType; JsonSerializer<Object> _delegateSerializer"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) [LINE] public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] } public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue); protected BeanPropertyWriter(BeanPropertyWriter base); protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name); public BeanPropertyWriter rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper); public void setNonTrivialBaseType(JavaType t); public String getName(); public JavaType getType(); public PropertyName getWrapperName(); public boolean isRequired(); public A getAnnotation(Class<A> acls); public A getContextAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; public Object getInternalSetting(Object key); public Object setInternalSetting(Object key, Object value); public Object removeInternalSetting(Object key); public SerializedString getSerializedName(); public boolean hasSerializer(); public boolean hasNullSerializer(); public boolean willSuppressNulls(); public JsonSerializer<Object> getSerializer(); public JavaType getSerializationType(); public Class<?> getRawSerializationType(); public Class<?> getPropertyType(); public Type getGenericPropertyType(); public Class<?>[] getViews(); protected boolean isRequired(AnnotationIntrospector intr); public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException; public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; public final Object get(Object bean) throws Exception; protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException; public String toString(); Object MARKER_FOR_EMPTY=Optional[new Object()]; AnnotatedMember _member; Annotations _contextAnnotations; JavaType _declaredType; Method _accessorMethod; Field _field; HashMap<Object, Object> _internalSettings; SerializedString _name; PropertyName _wrapperName; JavaType _cfgSerializationType; JsonSerializer<Object> _serializer; JsonSerializer<Object> _nullSerializer; PropertySerializerMap _dynamicSerializers; boolean _suppressNulls; Object _suppressableValue; Class<?>[] _includeInViews; TypeSerializer _typeSerializer; JavaType _nonTrivialBaseType; boolean _isRequired"}
{"code": "public void testSimpleFields() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     String json = mapper.writeValueAsString(new FieldBean(999)); [EOL]     assertEquals(\\\"{\\\\\"Field-key\\\\\":999}\\\", json); [EOL]     FieldBean result = mapper.readValue(json, FieldBean.class); [EOL]     assertEquals(999, result.key); [EOL] }", "nl": "[LINE] POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [LINE] protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\\\"num\\\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] _writeContext = _writeContext.createChildObjectContext(); [LINE] @Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.START_OBJECT); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] if (!property.hasConstructorParameter()) { // never skip constructor params [LINE] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL]     ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL]     HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL]     for (BeanPropertyDefinition property : propDefsIn) { [EOL]         String name = property.getName(); [EOL]         if (ignored.contains(name)) { [EOL]             continue; [EOL]         } [EOL]         if (!property.hasConstructorParameter()) { [EOL]             Class<?> rawPropertyType = null; [EOL]             if (property.hasSetter()) { [EOL]                 rawPropertyType = property.getSetter().getRawParameterType(0); [EOL]             } else if (property.hasField()) { [EOL]                 rawPropertyType = property.getField().getRawType(); [EOL]             } [EOL]             if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL]                 builder.addIgnorable(name); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         result.add(property); [EOL]     } [EOL]     return result; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }]; Class<?>[] NO_VIEWS=Optional[new Class<?>[0]]; BeanDeserializerFactory instance=Optional[new BeanDeserializerFactory(new DeserializerFactoryConfig())]"}
{"code": "public void testSimpleObject() throws Exception { [EOL]     String JSON = \\\"{ \\\\\"key\\\\\" : 1, \\\\\"b\\\\\" : \\\\\"x\\\\\" }\\\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode root = mapper.readTree(JSON); [EOL]     assertFalse(root.isValueNode()); [EOL]     assertTrue(root.isContainerNode()); [EOL]     assertFalse(root.isArray()); [EOL]     assertTrue(root.isObject()); [EOL]     assertEquals(2, root.size()); [EOL]     Iterator<JsonNode> it = root.iterator(); [EOL]     assertNotNull(it); [EOL]     assertTrue(it.hasNext()); [EOL]     JsonNode n = it.next(); [EOL]     assertNotNull(n); [EOL]     assertEquals(IntNode.valueOf(1), n); [EOL]     assertTrue(it.hasNext()); [EOL]     n = it.next(); [EOL]     assertNotNull(n); [EOL]     assertEquals(TextNode.valueOf(\\\"x\\\"), n); [EOL]     assertFalse(it.hasNext()); [EOL]     ObjectNode obNode = (ObjectNode) root; [EOL]     Iterator<Map.Entry<String, JsonNode>> fit = obNode.fields(); [EOL]     assertTrue(fit.hasNext()); [EOL]     Map.Entry<String, JsonNode> en = fit.next(); [EOL]     assertEquals(\\\"key\\\", en.getKey()); [EOL]     assertEquals(IntNode.valueOf(1), en.getValue()); [EOL]     assertTrue(fit.hasNext()); [EOL]     en = fit.next(); [EOL]     assertEquals(\\\"b\\\", en.getKey()); [EOL]     assertEquals(TextNode.valueOf(\\\"x\\\"), en.getValue()); [EOL]     fit.remove(); [EOL]     assertEquals(1, obNode.size()); [EOL]     assertEquals(IntNode.valueOf(1), root.get(\\\"key\\\")); [EOL]     assertNull(root.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] switch (getNodeType()) { [LINE] @Override [EOL] public final boolean isValueNode() { [EOL]     switch(getNodeType()) { [EOL]         case ARRAY: [EOL]         case OBJECT: [EOL]         case MISSING: [EOL]             return false; [EOL]         default: [EOL]             return true; [EOL]     } [EOL] } protected JsonNode(); public abstract T deepCopy(); public int size(); public final boolean isValueNode(); public final boolean isContainerNode(); public final boolean isMissingNode(); public final boolean isArray(); public final boolean isObject(); public abstract JsonNode get(int index); public JsonNode get(String fieldName); public abstract JsonNode path(String fieldName); public abstract JsonNode path(int index); public Iterator<String> fieldNames(); public abstract JsonNodeType getNodeType(); public final boolean isPojo(); public final boolean isNumber(); public boolean isIntegralNumber(); public boolean isFloatingPointNumber(); public boolean isShort(); public boolean isInt(); public boolean isLong(); public boolean isFloat(); public boolean isDouble(); public boolean isBigDecimal(); public boolean isBigInteger(); public final boolean isTextual(); public final boolean isBoolean(); public final boolean isNull(); public final boolean isBinary(); public boolean canConvertToInt(); public boolean canConvertToLong(); public String textValue(); public byte[] binaryValue() throws IOException; public boolean booleanValue(); public Number numberValue(); public short shortValue(); public int intValue(); public long longValue(); public float floatValue(); public double doubleValue(); public BigDecimal decimalValue(); public BigInteger bigIntegerValue(); public abstract String asText(); public int asInt(); public int asInt(int defaultValue); public long asLong(); public long asLong(long defaultValue); public double asDouble(); public double asDouble(double defaultValue); public boolean asBoolean(); public boolean asBoolean(boolean defaultValue); public boolean has(String fieldName); public boolean has(int index); public boolean hasNonNull(String fieldName); public boolean hasNonNull(int index); public final Iterator<JsonNode> iterator(); public Iterator<JsonNode> elements(); public Iterator<Map.Entry<String, JsonNode>> fields(); public abstract JsonNode findValue(String fieldName); public final List<JsonNode> findValues(String fieldName); public final List<String> findValuesAsText(String fieldName); public abstract JsonNode findPath(String fieldName); public abstract JsonNode findParent(String fieldName); public final List<JsonNode> findParents(String fieldName); public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar); public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar); public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar); public JsonNode with(String propertyName); public JsonNode withArray(String propertyName); public abstract String toString(); public abstract boolean equals(Object o)"}
{"code": "public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals(\\\"uri\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"url\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testNull\\\")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals(\\\"testString\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testBoolean\\\")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals(\\\"testEnum\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testInteger\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals(\\\"testLong\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals(\\\"testBigInteger\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals(\\\"testBigDecimal\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals(\\\"testCharacter\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testShort\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals(\\\"testByte\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals(\\\"testFloat\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals(\\\"testDouble\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals(\\\"testStringBuffer\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testError\\\")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals(\\\"cause\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals(\\\"message\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals(\\\"localizedMessage\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals(\\\"stackTrace\\\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue(\\\"Probably run away loop in test. StackTrack Array was not properly closed.\\\", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals(\\\"suppressed\\\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail(\\\"Unexpected field name '\\\" + name + \\\"'\\\"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail(\\\"Unexpected field, name '\\\" + name + \\\"'\\\"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }", "nl": "[LINE] SerializationConfig config = getSerializationConfig(); [LINE] @Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader(\\\"{\\\\\"v\\\\\":\\\\\"\\\" + value + \\\"\\\\\"}\\\"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader(\\\"[ \\\\\"Infinity\\\\\" ]\\\"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }", "nl": "[LINE] return new DoubleDeser(); [LINE] public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] } protected PrimitiveArrayDeserializers(Class<T> cls); public CharDeser(); public BooleanDeser(); public ByteDeser(); public ShortDeser(); public IntDeser(); public LongDeser(); public FloatDeser(); public DoubleDeser(); public static JsonDeserializer<?> forType(Class<?> rawType); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] if (propName == null || propName.length() == 0) { [LINE] protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = \\\"\\\"; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] } protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired); protected SettableBeanProperty(SettableBeanProperty src); protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser); protected SettableBeanProperty(SettableBeanProperty src, String newName); public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(String newName); public void setManagedReferenceName(String n); public void setViews(Class<?>[] views); public void assignIndex(int index); public final String getName(); public boolean isRequired(); public JavaType getType(); public PropertyName getWrapperName(); public abstract A getAnnotation(Class<A> acls); public abstract AnnotatedMember getMember(); public A getContextAnnotation(Class<A> acls); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; protected final Class<?> getDeclaringClass(); public String getManagedReferenceName(); public boolean hasValueDeserializer(); public boolean hasValueTypeDeserializer(); public JsonDeserializer<Object> getValueDeserializer(); public TypeDeserializer getValueTypeDeserializer(); public boolean visibleInView(Class<?> activeView); public boolean hasViews(); public int getPropertyIndex(); public int getCreatorIndex(); public Object getInjectableValueId(); public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void _throwAsIOE(Exception e, Object value) throws IOException; protected IOException _throwAsIOE(Exception e) throws IOException; public String toString(); long serialVersionUID=Optional[-1026580169193933453L]; JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER=Optional[new FailingDeserializer(\\\"No _valueDeserializer assigned\\\")]; String _propName; JavaType _type; PropertyName _wrapperName; Annotations _contextAnnotations; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; NullProvider _nullProvider; String _managedReferenceName; ViewMatcher _viewMatcher; int _propertyIndex=Optional[-1]; boolean _isRequired"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] return _index < _array.length; [LINE] @Override [EOL] public boolean hasNext() { [EOL]     return _index < _array.length; [EOL] } public ArrayBuilders(); public BooleanBuilder(); public ByteBuilder(); public ShortBuilder(); public IntBuilder(); public LongBuilder(); public FloatBuilder(); public DoubleBuilder(); public ArrayIterator(T[] array); public BooleanBuilder getBooleanBuilder(); public ByteBuilder getByteBuilder(); public ShortBuilder getShortBuilder(); public IntBuilder getIntBuilder(); public LongBuilder getLongBuilder(); public FloatBuilder getFloatBuilder(); public DoubleBuilder getDoubleBuilder(); public final boolean[] _constructArray(int len); public final byte[] _constructArray(int len); public final short[] _constructArray(int len); public final int[] _constructArray(int len); public final long[] _constructArray(int len); public final float[] _constructArray(int len); public final double[] _constructArray(int len); public boolean equals(Object other); public static Object getArrayComparator(final Object defaultValue); public static HashSet<T> arrayToSet(T[] elements); public static ArrayList<T> arrayToList(T[] elements); public static HashSet<T> setAndArray(Set<T> set, T[] elements); public static List<T> addToList(List<T> list, T element); public static T[] insertInList(T[] array, T element); public static T[] insertInListNoDup(T[] array, T element); public static Iterator<T> arrayAsIterator(T[] array); public static Iterable<T> arrayAsIterable(T[] array); public boolean hasNext(); public T next(); public void remove(); public Iterator<T> iterator(); BooleanBuilder _booleanBuilder=Optional[null]; ByteBuilder _byteBuilder=Optional[null]; ShortBuilder _shortBuilder=Optional[null]; IntBuilder _intBuilder=Optional[null]; LongBuilder _longBuilder=Optional[null]; FloatBuilder _floatBuilder=Optional[null]; DoubleBuilder _doubleBuilder=Optional[null]"}
{"code": "public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\\\"test-exceptions\\\", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail(\\\"Should have gotten an exception\\\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \\\"test string\\\"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail(\\\"Wrapped exception not IAE, but \\\" + root.getClass()); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] throw JsonMappingException.wrapWithPath(t, bean, index); [LINE] public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] } protected StdSerializer(Class<T> t); protected StdSerializer(JavaType type); protected StdSerializer(Class<?> t, boolean dummy); public Class<T> handledType(); public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional) throws JsonMappingException; protected ObjectNode createObjectNode(); protected ObjectNode createSchemaNode(String type); protected ObjectNode createSchemaNode(String type, boolean isOptional); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException; public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException; protected boolean isDefaultSerializer(JsonSerializer<?> serializer); protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException; Class<T> _handledType"}
{"code": "public void testAnnotationsDisabled() throws Exception { [EOL]     assertTrue(MAPPER.isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     result = writeAndMap(m2, new AnnoBean()); [EOL]     assertEquals(1, result.size()); [EOL] }", "nl": "[LINE] return null; [LINE] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     return null; [EOL] } public ReferenceProperty(Type t, String n); public Pair(AnnotationIntrospector p, AnnotationIntrospector s); public static ReferenceProperty managed(String name); public static ReferenceProperty back(String name); public Type getType(); public String getName(); public boolean isManagedReference(); public boolean isBackReference(); public static AnnotationIntrospector nopInstance(); public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2); public Collection<AnnotationIntrospector> allIntrospectors(); public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result); public abstract Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Class<?>[] findViews(Annotated a); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated memberOrClass); public Boolean isTypeId(AnnotatedMember member); public PropertyName findWrapperName(Annotated ann); public Object findSerializer(Annotated am); public Object findKeySerializer(Annotated am); public Object findContentSerializer(Annotated am); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated a); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedMethod am); public String findSerializationName(AnnotatedField af); public boolean hasAsValueAnnotation(AnnotatedMethod am); public String findEnumValue(Enum<?> value); public Object findDeserializer(Annotated am); public Object findKeyDeserializer(Annotated am); public Object findContentDeserializer(Annotated am); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a)"}
{"code": "public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get(\\\"x\\\"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }", "nl": "[LINE] if (implName == null) { [LINE] protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             return; [EOL]         } [EOL]         visible = _visibilityChecker.isSetterVisible(m); [EOL]     } else { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addSetter(m, explName, visible, ignore); [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testSuperTypeDetectionClass() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(2, _countSupers(sub)); [EOL]     assertSame(MyStringIntMap.class, sub.getRawClass()); [EOL]     HierarchicType sup = sub.getSuperType(); [EOL]     assertSame(MyStringXMap.class, sup.getRawClass()); [EOL]     HierarchicType sup2 = sup.getSuperType(); [EOL]     assertSame(HashMap.class, sup2.getRawClass()); [EOL]     assertNull(sup2.getSuperType()); [EOL] }", "nl": "[LINE] return current; [LINE] protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return current; [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperClassChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] if (anns != null) { [LINE] private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] } private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations); public AnnotatedClass withAnnotations(AnnotationMap ann); public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public Class<?> getAnnotated(); public int getModifiers(); public String getName(); public A getAnnotation(Class<A> acls); public Type getGenericType(); public Class<?> getRawType(); protected AnnotationMap getAllAnnotations(); public Annotations getAnnotations(); public boolean hasAnnotations(); public AnnotatedConstructor getDefaultConstructor(); public List<AnnotatedConstructor> getConstructors(); public List<AnnotatedMethod> getStaticMethods(); public Iterable<AnnotatedMethod> memberMethods(); public int getMemberMethodCount(); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public int getFieldCount(); public Iterable<AnnotatedField> fields(); private void resolveClassAnnotations(); private void resolveCreators(); private void resolveMemberMethods(); private void resolveFields(); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin); protected void _addConstructorMixIns(Class<?> mixin); protected void _addFactoryMixIns(Class<?> mixin); protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields); protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields); protected AnnotatedMethod _constructMethod(Method m); protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor); protected AnnotatedMethod _constructCreatorMethod(Method m); protected AnnotatedField _constructField(Field f); private AnnotationMap _emptyAnnotationMap(); private AnnotationMap[] _emptyAnnotationMaps(int count); protected boolean _isIncludableMemberMethod(Method m); private boolean _isIncludableField(Field f); protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns); protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns); private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns); protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations); protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations); protected void _addMixUnders(Method src, AnnotatedMethod target); private final boolean _isAnnotationBundle(Annotation ann); public String toString(); AnnotationMap[] NO_ANNOTATION_MAPS=Optional[new AnnotationMap[0]]; Class<?> _class; List<Class<?>> _superTypes; AnnotationIntrospector _annotationIntrospector; MixInResolver _mixInResolver; Class<?> _primaryMixIn; AnnotationMap _classAnnotations; boolean _creatorsResolved=Optional[false]; AnnotatedConstructor _defaultConstructor; List<AnnotatedConstructor> _constructors; List<AnnotatedMethod> _creatorMethods; AnnotatedMethodMap _memberMethods; List<AnnotatedField> _fields"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [LINE] @Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] } public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private SerializationConfig(SerializationConfig src, SubtypeResolver str); private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures); private SerializationConfig(SerializationConfig src, BaseSettings base); private SerializationConfig(SerializationConfig src, FilterProvider filters); private SerializationConfig(SerializationConfig src, Class<?> view); private SerializationConfig(SerializationConfig src, JsonInclude.Include incl); private SerializationConfig(SerializationConfig src, String rootName); protected SerializationConfig(SerializationConfig src, Map<ClassKey, Class<?>> mixins); public SerializationConfig with(MapperFeature... features); public SerializationConfig without(MapperFeature... features); public SerializationConfig with(AnnotationIntrospector ai); public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig with(ClassIntrospector ci); public SerializationConfig with(DateFormat df); public SerializationConfig with(HandlerInstantiator hi); public SerializationConfig with(PropertyNamingStrategy pns); public SerializationConfig withRootName(String rootName); public SerializationConfig with(SubtypeResolver str); public SerializationConfig with(TypeFactory tf); public SerializationConfig with(TypeResolverBuilder<?> trb); public SerializationConfig withView(Class<?> view); public SerializationConfig with(VisibilityChecker<?> vc); public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SerializationConfig with(Locale l); public SerializationConfig with(TimeZone tz); public SerializationConfig with(Base64Variant base64); private final SerializationConfig _withBase(BaseSettings newBase); public SerializationConfig with(SerializationFeature feature); public SerializationConfig with(SerializationFeature first, SerializationFeature... features); public SerializationConfig withFeatures(SerializationFeature... features); public SerializationConfig without(SerializationFeature feature); public SerializationConfig without(SerializationFeature first, SerializationFeature... features); public SerializationConfig withoutFeatures(SerializationFeature... features); public SerializationConfig withFilters(FilterProvider filterProvider); public SerializationConfig withSerializationInclusion(JsonInclude.Include incl); public boolean useRootWrapping(); public AnnotationIntrospector getAnnotationIntrospector(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(SerializationFeature f); public final int getSerializationFeatures(); public JsonInclude.Include getSerializationInclusion(); public FilterProvider getFilterProvider(); public T introspect(JavaType type); public String toString(); long serialVersionUID=Optional[8849092838541724233L]; int _serFeatures; JsonInclude.Include _serializationInclusion=Optional[null]; FilterProvider _filterProvider"}
{"code": "public void testListAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = \\\"[\\n\\\" + asJSONObjectValueString(m, \\\"@classy\\\", Cat.class.getName(), \\\"name\\\", \\\"Hello\\\", \\\"furColor\\\", \\\"white\\\") + \\\",\\n\\\" + asJSONObjectValueString(m, \\\"boneCount\\\", Integer.valueOf(1), \\\"@classy\\\", Dog.class.getName(), \\\"name\\\", \\\"Bob\\\") + \\\",\\n\\\" + asJSONObjectValueString(m, \\\"@classy\\\", Fish.class.getName()) + \\\", null\\n]\\\"; [EOL]     JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class); [EOL]     List<Animal> animals = m.readValue(JSON, expType); [EOL]     assertNotNull(animals); [EOL]     assertEquals(4, animals.size()); [EOL]     Cat c = (Cat) animals.get(0); [EOL]     assertEquals(\\\"Hello\\\", c.name); [EOL]     assertEquals(\\\"white\\\", c.furColor); [EOL]     Dog d = (Dog) animals.get(1); [EOL]     assertEquals(\\\"Bob\\\", d.name); [EOL]     assertEquals(1, d.boneCount); [EOL]     Fish f = (Fish) animals.get(2); [EOL]     assertNotNull(f); [EOL]     assertNull(animals.get(3)); [EOL] }", "nl": "[LINE] _buffered = new PropertyValue.Regular(_buffered, value, prop); [LINE] public void bufferProperty(SettableBeanProperty prop, Object value) { [EOL]     _buffered = new PropertyValue.Regular(_buffered, value, prop); [EOL] } public PropertyValueBuffer(JsonParser jp, DeserializationContext ctxt, int paramCount, ObjectIdReader oir); public void inject(SettableBeanProperty[] injectableProperties); protected final Object[] getParameters(Object[] defaults); public boolean readIdProperty(String propName) throws IOException; public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException; protected PropertyValue buffered(); public boolean isComplete(); public boolean assignParameter(int index, Object value); public void bufferProperty(SettableBeanProperty prop, Object value); public void bufferAnyProperty(SettableAnyProperty prop, String propName, Object value); public void bufferMapProperty(Object key, Object value); JsonParser _parser; DeserializationContext _context; Object[] _creatorParameters; ObjectIdReader _objectIdReader; int _paramsNeeded; PropertyValue _buffered; Object _idValue"}
{"code": "public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, \\\"Bob\\\").addValue(\\\"number\\\", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue(\\\"{ }\\\", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals(\\\"Bob\\\", bean.name); [EOL] }", "nl": "[LINE] try { [LINE] @Override [EOL] protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     bean = null; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         bean = null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] } public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews); protected BeanDeserializer(BeanDeserializerBase src); protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown); protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper); public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir); public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanDeserializer withObjectIdReader(ObjectIdReader oir); public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanDeserializerBase asArrayDeserializer(); public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; protected Object _missingToken(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]"}
{"code": "public void testPropertyAnnotationSimple() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointWrapper(3, 4)); [EOL]     assertEquals(\\\"{\\\\\"value\\\\\":[3,4]}\\\", json); [EOL] }", "nl": "[LINE] JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [LINE] protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore); protected BeanSerializerBase(BeanSerializerBase src); protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper); public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter); protected abstract BeanSerializerBase withIgnorals(String[] toIgnore); protected abstract BeanSerializerBase asArraySerializer(); private static final BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer); public void resolve(SerializerProvider provider) throws JsonMappingException; protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public boolean usesObjectId(); public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final String _customTypeId(Object bean); protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; BeanPropertyWriter[] NO_PROPS=Optional[new BeanPropertyWriter[0]]; BeanPropertyWriter[] _props; BeanPropertyWriter[] _filteredProps; AnyGetterWriter _anyGetterWriter; Object _propertyFilterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter; JsonFormat.Shape _serializationShape"}
{"code": "public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23.789Z\\\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23Z\\\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T21:51:23.789+02:00\\\"); [EOL]     assertEquals(date, d); [EOL] }", "nl": "[LINE] checkOffset(date, offset, '-'); [LINE] public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException(\\\"Invalid time zone indicator \\\" + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } [EOL] } public static TimeZone timeZoneGMT(); public static String format(Date date); public static String format(Date date, boolean millis); public static String format(Date date, boolean millis, TimeZone tz); public static Date parse(String date); private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException; private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException; private static void padInt(StringBuilder buffer, int value, int length); String GMT_ID=Optional[\\\"GMT\\\"]; TimeZone TIMEZONE_GMT=Optional[TimeZone.getTimeZone(GMT_ID)]"}
{"code": "public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \\\"{\\\\\"id\\\\\": 5, \\\\\"defaultValue\\\\\": { \\\\\"value\\\\\": \\\\\"123\\\\\" } }\\\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\\\"should have raised exception instead value was set to \\\" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"not numeric\\\"); [EOL]     } [EOL] }", "nl": "[LINE] if (deserDef instanceof JsonDeserializer) { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\\\"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<JsonDeserializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] } protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory); public Impl(DeserializerFactory df); protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected Impl(Impl src, DeserializerFactory factory); public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract DefaultDeserializationContext with(DeserializerFactory factory); public abstract DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext with(DeserializerFactory factory); long serialVersionUID=Optional[1L]; LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds"}
{"code": "public void testBeanAsObject() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String str = m.writeValueAsString(new Object[] { new StringBean(\\\"abc\\\") }); [EOL]     _verifySerializationAsMap(str); [EOL]     Object ob = m.readValue(str, Object[].class); [EOL]     assertNotNull(ob); [EOL]     Object[] result = (Object[]) ob; [EOL]     assertNotNull(result[0]); [EOL]     assertEquals(StringBean.class, result[0].getClass()); [EOL]     assertEquals(\\\"abc\\\", ((StringBean) result[0]).name); [EOL] }", "nl": "[LINE] final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [LINE] @Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] } public ObjectArrayDeserializer(ArrayType arrayType, JsonDeserializer<Object> elemDeser, TypeDeserializer elemTypeDeser); public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser); public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Byte[] deserializeFromBase64(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; ArrayType _arrayType; boolean _untyped; Class<?> _elementClass; JsonDeserializer<Object> _elementDeserializer; TypeDeserializer _elementTypeDeserializer"}
{"code": "public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }", "nl": "[LINE] if (!_closed) { [LINE] @Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public TreeTraversingParser(JsonNode n); public TreeTraversingParser(JsonNode n, ObjectCodec codec); public void setCodec(ObjectCodec c); public ObjectCodec getCodec(); public Version version(); public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; public boolean isClosed(); public String getCurrentName(); public void overrideCurrentName(String name); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getText(); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public boolean hasTextCharacters(); public NumberType getNumberType() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected JsonNode currentNode(); protected JsonNode currentNumericNode() throws JsonParseException; protected void _handleEOF() throws JsonParseException; ObjectCodec _objectCodec; NodeCursor _nodeCursor; JsonToken _nextToken; boolean _startContainer; boolean _closed"}
{"code": "public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }", "nl": "[LINE] return _findSuperInterfaceChain(subtype, supertype); [LINE] protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL]     if (supertype.isInterface()) { [EOL]         return _findSuperInterfaceChain(subtype, supertype); [EOL]     } [EOL]     return _findSuperClassChain(subtype, supertype); [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testModifyCollectionDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule(\\\"test\\\").setDeserializerModifier(new CollectionDeserializerModifier())); [EOL]     List<?> result = mapper.readValue(\\\"[1,2]\\\", List.class); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\\\"foo\\\", result.get(0)); [EOL] }", "nl": "[LINE] DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [LINE] public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException(\\\"Module without defined name\\\"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException(\\\"Module without defined version\\\"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings(\\\"unchecked\\\") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals(\\\"APs=\\\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public String asText() { [EOL]     return Base64Variants.getDefaultVariant().encode(_data, false); [EOL] } public BinaryNode(byte[] data); public BinaryNode(byte[] data, int offset, int length); public static BinaryNode valueOf(byte[] data); public static BinaryNode valueOf(byte[] data, int offset, int length); public JsonNodeType getNodeType(); public JsonToken asToken(); public byte[] binaryValue(); public String asText(); public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public boolean equals(Object o); public int hashCode(); public String toString(); BinaryNode EMPTY_BINARY_NODE=Optional[new BinaryNode(new byte[0])]; byte[] _data"}
{"code": "public void testReadSimpleRootValue() throws Exception { [EOL]     String json = \\\"[false,\\\\\"Bubba\\\\\",1,2]\\\"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals(\\\"Bubba\\\", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }", "nl": "[LINE] protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) [LINE] protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeAndSet(jp, ctxt, bean); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException(\\\"Unexpected JSON values; expected at most \\\" + propCount + \\\" properties (in JSON Array)\\\"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] } public BeanAsArrayDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanAsArrayDeserializer withObjectIdReader(ObjectIdReader oir); public BeanAsArrayDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanDeserializerBase asArrayDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; BeanDeserializerBase _delegate; SettableBeanProperty[] _orderedProperties"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] typeIdPropName = _idType.getDefaultPropertyName(); [LINE] @Override [EOL] public StdTypeResolverBuilder typeProperty(String typeIdPropName) { [EOL]     if (typeIdPropName == null || typeIdPropName.length() == 0) { [EOL]         typeIdPropName = _idType.getDefaultPropertyName(); [EOL]     } [EOL]     _typeProperty = typeIdPropName; [EOL]     return this; [EOL] } public StdTypeResolverBuilder(); public static StdTypeResolverBuilder noTypeInfoBuilder(); public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs); public StdTypeResolverBuilder typeProperty(String typeIdPropName); public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl); public StdTypeResolverBuilder typeIdVisibility(boolean isVisible); public String getTypeProperty(); public Class<?> getDefaultImpl(); public boolean isTypeIdVisible(); protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser); JsonTypeInfo.Id _idType; JsonTypeInfo.As _includeAs; String _typeProperty; boolean _typeIdVisible=Optional[false]; Class<?> _defaultImpl; TypeIdResolver _customIdResolver"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put(\\\"number\\\", 15); [EOL]     n.put(\\\"string\\\", \\\"abc\\\"); [EOL]     ObjectNode n2 = n.putObject(\\\"ob\\\"); [EOL]     n2.putArray(\\\"arr\\\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals(\\\"abc\\\", result.get(\\\"string\\\")); [EOL]     assertEquals(Integer.valueOf(15), result.get(\\\"number\\\")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get(\\\"ob\\\"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get(\\\"arr\\\"); [EOL]     assertEquals(0, list.size()); [EOL] }", "nl": "[LINE] return _deserializationContext.createInstance(cfg, [LINE] protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { [EOL]     return _deserializationContext.createInstance(cfg, jp, _injectableValues); [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] public final SerializerAndMapResult findAndAddSerializer(JavaType type, [LINE] public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer)); [EOL] } public SerializerAndMapResult(JsonSerializer<Object> serializer, PropertySerializerMap map); public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer); public Single(Class<?> type, JsonSerializer<Object> serializer); public Double(Class<?> type1, JsonSerializer<Object> serializer1, Class<?> type2, JsonSerializer<Object> serializer2); public Multi(TypeAndSerializer[] entries); public abstract JsonSerializer<Object> serializerFor(Class<?> type); public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public static PropertySerializerMap emptyMap(); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)"}
{"code": "public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"xyz:\\\")); [EOL]     assertEquals(quote(\\\"xyz:456\\\"), mapper.writeValueAsString(new MyBean(\\\"456\\\"))); [EOL] }", "nl": "[LINE] if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [LINE] @Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned serializer definition of type \\\" + serDef.getClass().getName() + \\\"; expected type JsonSerializer or Class<JsonSerializer> instead\\\"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + serClass.getName() + \\\"; expected Class<JsonSerializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] } protected DefaultSerializerProvider(); protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f); public Impl(); protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f); public abstract DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf); public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException; public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType) throws IOException, JsonGenerationException; public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public boolean hasSerializerFor(Class<?> cls); public int cachedSerializersCount(); public void flushCachedSerializers(); public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType); public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException; public Impl createInstance(SerializationConfig config, SerializerFactory jsf); long serialVersionUID=Optional[1L]; IdentityHashMap<Object, WritableObjectId> _seenObjectIds; ArrayList<ObjectIdGenerator<?>> _objectIdGenerators"}
{"code": "public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \\\"root\\\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \\\"leaf\\\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\\\"{\\\\\"id\\\\\":1,\\\\\"name\\\\\":\\\\\"root\\\\\",\\\\\"parent\\\\\":null,\\\\\"child\\\\\":\\\" + \\\"{\\\\\"id\\\\\":2,\\\\\"name\\\\\":\\\\\"leaf\\\\\",\\\\\"parent\\\\\":1,\\\\\"child\\\\\":null}}\\\", json); [EOL] }", "nl": "[LINE] String propName = objectIdInfo.getPropertyName(); [LINE] protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException(\\\"Invalid Object Id definition for \\\" + beanDesc.getBeanClass().getName() + \\\": can not find property with name '\\\" + propName + \\\"'\\\"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testFinalFieldIgnoral() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertTrue(mapper.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)); [EOL]     mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     try { [EOL]         mapper.readValue(\\\"{\\\\\"x\\\\\":2}\\\", FixedPoint.class); [EOL]         fail(\\\"Should not try to use final field\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"unrecognized field \\\\\"x\\\\\"\\\"); [EOL]     } [EOL] }", "nl": "[LINE] continue; [LINE] protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if (\\\"\\\".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\\\"xyz:\\\")); [EOL]     assertEquals(quote(\\\"xyz:456\\\"), mapper.writeValueAsString(new MyBean(\\\"456\\\"))); [EOL] }", "nl": "[LINE] _propertyNamingStrategy = pns; [LINE] public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai, VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf, TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi, Locale locale, TimeZone tz, Base64Variant defaultBase64) { [EOL]     _classIntrospector = ci; [EOL]     _annotationIntrospector = ai; [EOL]     _visibilityChecker = vc; [EOL]     _propertyNamingStrategy = pns; [EOL]     _typeFactory = tf; [EOL]     _typeResolverBuilder = typer; [EOL]     _dateFormat = dateFormat; [EOL]     _handlerInstantiator = hi; [EOL]     _locale = locale; [EOL]     _timeZone = tz; [EOL]     _defaultBase64 = defaultBase64; [EOL] } public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai, VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf, TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi, Locale locale, TimeZone tz, Base64Variant defaultBase64); public BaseSettings withClassIntrospector(ClassIntrospector ci); public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai); public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc); public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns); public BaseSettings withTypeFactory(TypeFactory tf); public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer); public BaseSettings withDateFormat(DateFormat df); public BaseSettings withHandlerInstantiator(HandlerInstantiator hi); public BaseSettings with(Locale l); public BaseSettings with(TimeZone tz); public BaseSettings with(Base64Variant base64); public ClassIntrospector getClassIntrospector(); public AnnotationIntrospector getAnnotationIntrospector(); public VisibilityChecker<?> getVisibilityChecker(); public PropertyNamingStrategy getPropertyNamingStrategy(); public TypeFactory getTypeFactory(); public TypeResolverBuilder<?> getTypeResolverBuilder(); public DateFormat getDateFormat(); public HandlerInstantiator getHandlerInstantiator(); public Locale getLocale(); public TimeZone getTimeZone(); public Base64Variant getBase64Variant(); long serialVersionUID=Optional[4939673998947122190L]; ClassIntrospector _classIntrospector; AnnotationIntrospector _annotationIntrospector; VisibilityChecker<?> _visibilityChecker; PropertyNamingStrategy _propertyNamingStrategy; TypeFactory _typeFactory; TypeResolverBuilder<?> _typeResolverBuilder; DateFormat _dateFormat; HandlerInstantiator _handlerInstantiator; Locale _locale; TimeZone _timeZone; Base64Variant _defaultBase64"}
{"code": "public void testRootUsingExplicitConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer().withRootName(\\\"wrapper\\\"); [EOL]     String json = writer.writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"wrapper\\\\\":{\\\\\"a\\\\\":3}}\\\", json); [EOL]     ObjectReader reader = mapper.reader(Bean.class).withRootName(\\\"wrapper\\\"); [EOL]     Bean bean = reader.readValue(json); [EOL]     assertNotNull(bean); [EOL]     ObjectMapper wrapping = rootMapper(); [EOL]     json = wrapping.writer().withRootName(\\\"something\\\").writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"something\\\\\":{\\\\\"a\\\\\":3}}\\\", json); [EOL]     json = wrapping.writer().withRootName(\\\"\\\").writeValueAsString(new Bean()); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":3}\\\", json); [EOL]     bean = wrapping.reader(Bean.class).withRootName(\\\"\\\").readValue(json); [EOL]     assertNotNull(bean); [EOL] }", "nl": "[LINE] public ObjectReader withRootName(String rootName) { [LINE] public ObjectReader withRootName(String rootName) { [EOL]     return _with(_config.withRootName(rootName)); [EOL] } protected ObjectReader(ObjectMapper mapper, DeserializationConfig config); protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues); protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders); protected ObjectReader(ObjectReader base, DeserializationConfig config); protected ObjectReader(ObjectReader base, JsonFactory f); public Version version(); public ObjectReader with(DeserializationConfig config); public ObjectReader with(DeserializationFeature feature); public ObjectReader with(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withFeatures(DeserializationFeature... features); public ObjectReader without(DeserializationFeature feature); public ObjectReader without(DeserializationFeature first, DeserializationFeature... other); public ObjectReader withoutFeatures(DeserializationFeature... features); public ObjectReader with(InjectableValues injectableValues); public ObjectReader with(JsonNodeFactory f); public ObjectReader with(JsonFactory f); public ObjectReader withRootName(String rootName); public ObjectReader with(FormatSchema schema); public ObjectReader withType(JavaType valueType); public ObjectReader withType(Class<?> valueType); public ObjectReader withType(java.lang.reflect.Type valueType); public ObjectReader withType(TypeReference<?> valueTypeRef); public ObjectReader withValueToUpdate(Object value); public ObjectReader withView(Class<?> activeView); public ObjectReader with(Locale l); public ObjectReader with(TimeZone tz); public ObjectReader withHandler(DeserializationProblemHandler h); public ObjectReader with(Base64Variant defaultBase64); public ObjectReader withFormatDetection(ObjectReader... readers); public ObjectReader withFormatDetection(DataFormatReaders readers); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(JsonParser.Feature f); public DeserializationConfig getConfig(); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public TypeFactory getTypeFactory(); public T readValue(JsonParser jp) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public Iterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public T readValue(InputStream src) throws IOException, JsonProcessingException; public T readValue(Reader src) throws IOException, JsonProcessingException; public T readValue(String src) throws IOException, JsonProcessingException; public T readValue(byte[] src) throws IOException, JsonProcessingException; public T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public T readValue(File src) throws IOException, JsonProcessingException; public T readValue(URL src) throws IOException, JsonProcessingException; public T readValue(JsonNode src) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException; public final MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(URL src) throws IOException, JsonProcessingException; public JsonNode createArrayNode(); public JsonNode createObjectNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException; protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException, JsonProcessingException; protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType); protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException; protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException; protected MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException; protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException; protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException; protected void _verifySchemaType(FormatSchema schema); protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected ObjectReader _with(DeserializationConfig newConfig); protected void _reportUndetectableSource(Object src) throws JsonProcessingException; protected InputStream _inputStream(URL src) throws IOException; protected InputStream _inputStream(File f) throws IOException; long serialVersionUID=Optional[-4251443320039569153L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; DeserializationConfig _config; DefaultDeserializationContext _context; JsonFactory _jsonFactory; boolean _unwrapRoot; JavaType _valueType; JsonDeserializer<Object> _rootDeserializer; Object _valueToUpdate; FormatSchema _schema; InjectableValues _injectableValues; DataFormatReaders _dataFormatReaders; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers; RootNameLookup _rootNames"}
{"code": "public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\\\"\\\\\"value1\\\\\"\\\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\\\"value1\\\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }", "nl": "[LINE] return null; [LINE] @Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll(\\\"\\\\\"\\\", \\\"'\\\"); [EOL]     assertEquals(\\\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\\\", json); [EOL] }", "nl": "[LINE] if (filter == null) { [LINE] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode(\\\"object\\\", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put(\\\"id\\\", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put(\\\"properties\\\", propertiesNode); [EOL]     return o; [EOL] } protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore); protected BeanSerializerBase(BeanSerializerBase src); protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper); public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter); protected abstract BeanSerializerBase withIgnorals(String[] toIgnore); protected abstract BeanSerializerBase asArraySerializer(); private static final BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer); public void resolve(SerializerProvider provider) throws JsonMappingException; protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public boolean usesObjectId(); public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final String _customTypeId(Object bean); protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; BeanPropertyWriter[] NO_PROPS=Optional[new BeanPropertyWriter[0]]; BeanPropertyWriter[] _props; BeanPropertyWriter[] _filteredProps; AnyGetterWriter _anyGetterWriter; Object _propertyFilterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter; JsonFormat.Shape _serializationShape"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\\\"num\\\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] if (index > 0) { [LINE] public void set(int index, JsonToken tokenType) { [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] if (java.util.Date.class.isAssignableFrom(raw)) { [LINE] protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] } protected BasicSerializerFactory(SerializerFactoryConfig config); public SerializerFactoryConfig getFactoryConfig(); public abstract SerializerFactory withConfig(SerializerFactoryConfig config); public final SerializerFactory withAdditionalSerializers(Serializers additional); public final SerializerFactory withAdditionalKeySerializers(Serializers additional); public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier); public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl); public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType); public final JsonSerializer<?> getNullSerializer(); protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping); protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException; protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected boolean isIndexedList(Class<?> cls); protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type); protected static T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type); protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property); protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer); protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); HashMap<String, JsonSerializer<?>> _concrete=Optional[new HashMap<String, JsonSerializer<?>>()]; HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy=Optional[new HashMap<String, Class<? extends JsonSerializer<?>>>()]; SerializerFactoryConfig _factoryConfig"}
{"code": "public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }", "nl": "[LINE] typer = typer.init(JsonTypeInfo.Id.CLASS, null); [LINE] public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { [EOL]     TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); [EOL]     typer = typer.init(JsonTypeInfo.Id.CLASS, null); [EOL]     typer = typer.inclusion(includeAs); [EOL]     return setDefaultTyping(typer); [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testEmptyCollection() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(SerializationFeature.INDENT_OUTPUT, true); [EOL]     List<User> friends = new ArrayList<User>(); [EOL]     friends.add(new DefaultUser(\\\"Joe Hildebrandt\\\", null)); [EOL]     friends.add(new DefaultEmployee(\\\"Richard Nasr\\\", null, \\\"MDA\\\")); [EOL]     User user = new DefaultEmployee(\\\"John Vanspronssen\\\", friends, \\\"MDA\\\"); [EOL]     String json = mapper.writeValueAsString(user); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.registerSubtypes(DefaultEmployee.class); [EOL]     mapper.registerSubtypes(DefaultUser.class); [EOL]     User result = mapper.readValue(json, User.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(DefaultEmployee.class, result.getClass()); [EOL]     friends = result.getFriends(); [EOL]     assertEquals(2, friends.size()); [EOL]     assertEquals(DefaultUser.class, friends.get(0).getClass()); [EOL]     assertEquals(DefaultEmployee.class, friends.get(1).getClass()); [EOL] }", "nl": "[LINE] AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [LINE] @Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai) { [EOL]     HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         Class<?> rawBase = type.getRawType(); [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, subtypes); [EOL]             } [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(type.getRawType(), null); [EOL]     _collectAndResolve(type, rootType, config, ai, subtypes); [EOL]     return new ArrayList<NamedType>(subtypes.values()); [EOL] } public StdSubtypeResolver(); public void registerSubtypes(NamedType... types); public void registerSubtypes(Class<?>... classes); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType); public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai); protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes); long serialVersionUID=Optional[1L]; LinkedHashSet<NamedType> _registeredSubtypes"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] return new SerializerAndMapResult(serializer, newWith(type, serializer)); [LINE] public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type, serializer)); [EOL] } public SerializerAndMapResult(JsonSerializer<Object> serializer, PropertySerializerMap map); public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer); public Single(Class<?> type, JsonSerializer<Object> serializer); public Double(Class<?> type1, JsonSerializer<Object> serializer1, Class<?> type2, JsonSerializer<Object> serializer2); public Multi(TypeAndSerializer[] entries); public abstract JsonSerializer<Object> serializerFor(Class<?> type); public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public static PropertySerializerMap emptyMap(); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)"}
{"code": "public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals(\\\"APs=\\\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }", "nl": "[LINE] public byte[] binaryValue() { return _data; } [LINE] @Override [EOL] public byte[] binaryValue() { [EOL]     return _data; [EOL] } public BinaryNode(byte[] data); public BinaryNode(byte[] data, int offset, int length); public static BinaryNode valueOf(byte[] data); public static BinaryNode valueOf(byte[] data, int offset, int length); public JsonNodeType getNodeType(); public JsonToken asToken(); public byte[] binaryValue(); public String asText(); public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public boolean equals(Object o); public int hashCode(); public String toString(); BinaryNode EMPTY_BINARY_NODE=Optional[new BinaryNode(new byte[0])]; byte[] _data"}
{"code": "public void testCopy() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     ObjectMapper m2 = m.copy(); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL]     assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL]     assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertNotSame(m.getFactory(), m2.getFactory()); [EOL]     assertEquals(0, m.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m.getDeserializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getDeserializationConfig().mixInCount()); [EOL]     m.addMixInAnnotations(String.class, Integer.class); [EOL]     assertEquals(1, m.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getSerializationConfig().mixInCount()); [EOL]     assertEquals(1, m.getDeserializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getDeserializationConfig().mixInCount()); [EOL] }", "nl": "[LINE] _deserializationConfig = _deserializationConfig.without(feature); [LINE] public ObjectMapper disable(DeserializationFeature feature) { [EOL]     _deserializationConfig = _deserializationConfig.without(feature); [EOL]     return this; [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testParametricTypes() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructParametricType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     JavaType strC = tf.constructType(String.class); [EOL]     assertEquals(1, t.containedTypeCount()); [EOL]     assertEquals(strC, t.containedType(0)); [EOL]     assertNull(t.containedType(1)); [EOL]     JavaType t2 = tf.constructParametricType(Map.class, strC, t); [EOL]     assertEquals(MapType.class, t2.getClass()); [EOL]     assertEquals(2, t2.containedTypeCount()); [EOL]     assertEquals(strC, t2.containedType(0)); [EOL]     assertEquals(t, t2.containedType(1)); [EOL]     assertNull(t2.containedType(2)); [EOL]     JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class); [EOL]     assertEquals(SimpleType.class, custom.getClass()); [EOL]     assertEquals(1, custom.containedTypeCount()); [EOL]     assertEquals(strC, custom.containedType(0)); [EOL]     assertNull(custom.containedType(1)); [EOL]     assertEquals(\\\"X\\\", custom.containedTypeName(0)); [EOL]     try { [EOL]         tf.constructParametricType(Map.class, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \\\"Need exactly 2 parameter types for Map types\\\"); [EOL]     } [EOL]     try { [EOL]         tf.constructParametricType(SingleArgGeneric.class, strC, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \\\"expected 1 parameters, was given 2\\\"); [EOL]     } [EOL] }", "nl": "[LINE] else if (Collection.class.isAssignableFrom(parametrized)) { [LINE] public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException(\\\"Need exactly 1 parameter type for arrays (\\\" + parametrized.getName() + \\\")\\\"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException(\\\"Need exactly 2 parameter types for Map types (\\\" + parametrized.getName() + \\\")\\\"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException(\\\"Need exactly 1 parameter type for Collection types (\\\" + parametrized.getName() + \\\")\\\"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] ctorPropNames[param.getIndex()] = propDef.getName(); [LINE] protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] return ann; [LINE] private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes) { [EOL]     AnnotationMap ann = nodes[index].value.getAllAnnotations(); [EOL]     ++index; [EOL]     for (; index < nodes.length; ++index) { [EOL]         if (nodes[index] != null) { [EOL]             return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes)); [EOL]         } [EOL]     } [EOL]     return ann; [EOL] } public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector, boolean forSerialization); public POJOPropertyBuilder(POJOPropertyBuilder src, String newName); public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored); public POJOPropertyBuilder withName(String newName); public int compareTo(POJOPropertyBuilder other); public String getName(); public String getInternalName(); public PropertyName getWrapperName(); public boolean isExplicitlyIncluded(); public boolean hasGetter(); public boolean hasSetter(); public boolean hasField(); public boolean hasConstructorParameter(); public boolean couldSerialize(); public AnnotatedMethod getGetter(); public AnnotatedMethod getSetter(); public AnnotatedField getField(); public AnnotatedParameter getConstructorParameter(); public AnnotatedMember getAccessor(); public AnnotatedMember getMutator(); public AnnotatedMember getPrimaryMember(); public Class<?>[] withMember(AnnotatedMember member); public Class<?>[] findViews(); public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member); public AnnotationIntrospector.ReferenceProperty findReferenceType(); public Boolean withMember(AnnotatedMember member); public boolean isTypeId(); public Boolean withMember(AnnotatedMember member); public boolean isRequired(); public ObjectIdInfo withMember(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(); public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored); public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored); public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored); public void addAll(POJOPropertyBuilder src); private static Linked<T> merge(Linked<T> chain1, Linked<T> chain2); public void removeIgnored(); public void removeNonVisible(); public void removeNonVisible(boolean force); public void trimByVisibility(); public void mergeAnnotations(boolean forSerialization); private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes); private Linked<T> _removeIgnored(Linked<T> node); private Linked<T> _removeNonVisible(Linked<T> node); private Linked<T> _trimByVisibility(Linked<T> node); private boolean _anyExplicitNames(Linked<T> n); public boolean anyVisible(); private boolean _anyVisible(Linked<T> n); public boolean anyIgnorals(); private boolean _anyIgnorals(Linked<T> n); public String findNewName(); private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed); public String toString(); protected T fromMemberAnnotations(WithMember<T> func); public T withMember(AnnotatedMember member); public Linked<T> withValue(T newValue); public Linked<T> withNext(Linked<T> newNext); public Linked<T> withoutIgnored(); public Linked<T> withoutNonVisible(); private Linked<T> append(Linked<T> appendable); public Linked<T> trimByVisibility(); public String toString(); boolean _forSerialization; AnnotationIntrospector _annotationIntrospector; String _name; String _internalName; Linked<AnnotatedField> _fields; Linked<AnnotatedParameter> _ctorParameters; Linked<AnnotatedMethod> _getters; Linked<AnnotatedMethod> _setters"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] public BeanSerializerBuilder(BeanDescription beanDesc) { [LINE] public BeanSerializerBuilder(BeanDescription beanDesc) { [EOL]     _beanDesc = beanDesc; [EOL] } public BeanSerializerBuilder(BeanDescription beanDesc); protected BeanSerializerBuilder(BeanSerializerBuilder src); protected void setConfig(SerializationConfig config); public void setProperties(List<BeanPropertyWriter> properties); public void setFilteredProperties(BeanPropertyWriter[] properties); public void setAnyGetter(AnyGetterWriter anyGetter); public void setFilterId(Object filterId); public void setTypeId(AnnotatedMember idProp); public void setObjectIdWriter(ObjectIdWriter w); public AnnotatedClass getClassInfo(); public BeanDescription getBeanDescription(); public List<BeanPropertyWriter> getProperties(); public boolean hasProperties(); public BeanPropertyWriter[] getFilteredProperties(); public AnyGetterWriter getAnyGetter(); public Object getFilterId(); public AnnotatedMember getTypeId(); public ObjectIdWriter getObjectIdWriter(); public JsonSerializer<?> build(); public BeanSerializer createDummy(); BeanPropertyWriter[] NO_PROPERTIES=Optional[new BeanPropertyWriter[0]]; BeanDescription _beanDesc; SerializationConfig _config; List<BeanPropertyWriter> _properties; BeanPropertyWriter[] _filteredProperties; AnyGetterWriter _anyGetter; Object _filterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] return _deserialize(jp, ctxt); [LINE] @Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] } public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl); public AsArrayTypeDeserializer(AsArrayTypeDeserializer src, BeanProperty property); public TypeDeserializer forProperty(BeanProperty prop); public As getTypeInclusion(); public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[5345570420394408290L]"}
{"code": "public void testSimpleBean() throws Exception { [EOL]     ArrayList<Object> misc = new ArrayList<Object>(); [EOL]     misc.add(\\\"xyz\\\"); [EOL]     misc.add(42); [EOL]     misc.add(null); [EOL]     misc.add(Boolean.TRUE); [EOL]     TestBean bean = new TestBean(13, -900L, \\\"\\\\\"test\\\\\"\\\", new URI(\\\"http://foobar.com\\\"), misc); [EOL]     String json = MAPPER.writeValueAsString(bean); [EOL]     TestBean result = MAPPER.readValue(json, TestBean.class); [EOL]     assertEquals(bean, result); [EOL] }", "nl": "[LINE] provider.defaultSerializeNull(jgen); [LINE] @Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] } public IndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer); public IndexedListSerializer(IndexedListSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer); public IndexedListSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer); public boolean isEmpty(List<?> value); public boolean hasSingleElement(List<?> value); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException; public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException"}
{"code": "public void testNodeConvert() throws Exception { [EOL]     ObjectNode src = (ObjectNode) MAPPER.readTree(\\\"{}\\\"); [EOL]     TreeNode node = src; [EOL]     ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class); [EOL]     assertSame(src, result); [EOL] }", "nl": "[LINE] return (T) n; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testMultiAccess() throws Exception { [EOL]     String json = \\\"{\\\\\"c\\\\\":3,\\\\\"a\\\\\":2,\\\\\"b\\\\\":-9}\\\"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }", "nl": "[LINE] return ann.value(); [LINE] @Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return \\\"\\\"; [EOL]     } [EOL]     return null; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\\\"\\\\\"value1\\\\\"\\\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\\\"value1\\\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }", "nl": "[LINE] return ((ann == null) || (ann.builder() == NoClass.class)) ? [LINE] @Override [EOL] public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL]     JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class); [EOL]     return ((ann == null) || (ann.builder() == NoClass.class)) ? null : ann.builder(); [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\\\"{\\\\\"enumA\\\\\":\\\\\"value\\\\\"}\\\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\\\"value\\\", value.get(EnumWithCreator.A)); [EOL] }", "nl": "[LINE] final TypeDeserializer typeDeser = _valueTypeDeserializer; [LINE] protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] } public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser); protected MapDeserializer(MapDeserializer src); protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable); protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable); protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser); public void setIgnorableProperties(String[] ignorable); public void resolve(DeserializationContext ctxt) throws JsonMappingException; public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public final Class<?> getMapClass(); public JavaType getValueType(); protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Map<Object, Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void wrapAndThrow(Throwable t, Object ref) throws IOException; long serialVersionUID=Optional[-3378654289961736240L]; JavaType _mapType; KeyDeserializer _keyDeserializer; boolean _standardStringKey; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; ValueInstantiator _valueInstantiator; boolean _hasDefaultCreator; JsonDeserializer<Object> _delegateDeserializer; PropertyBasedCreator _propertyBasedCreator; HashSet<String> _ignorableProperties"}
{"code": "public void testCustomMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator())); [EOL]     MyMap result = mapper.readValue(\\\"{ \\\\\"a\\\\\":\\\\\"b\\\\\" }\\\", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(MyMap.class, result.getClass()); [EOL]     assertEquals(1, result.size()); [EOL] }", "nl": "[LINE] if (instantiator == null) { [LINE] @Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException(\\\"Broken registered ValueInstantiators (of type \\\" + insts.getClass().getName() + \\\"): returned null ValueInstantiator\\\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException(\\\"Argument #\\\" + nonAnnotatedParam.getIndex() + \\\" of constructor \\\" + ctor + \\\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\\\"); [EOL]     } [EOL]     return instantiator; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader(\\\"{\\\\\"v\\\\\":\\\\\"\\\" + value + \\\"\\\\\"}\\\"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader(\\\"[ \\\\\"Infinity\\\\\" ]\\\"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }", "nl": "[LINE] double[] chunk = builder.resetAndStart(); [LINE] @Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] } protected PrimitiveArrayDeserializers(Class<T> cls); public CharDeser(); public BooleanDeser(); public ByteDeser(); public ShortDeser(); public IntDeser(); public LongDeser(); public FloatDeser(); public DoubleDeser(); public static JsonDeserializer<?> forType(Class<?> rawType); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException"}
{"code": "public void testSpecialMap() throws IOException { [EOL]     final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class); [EOL]     _doTestUntyped(map); [EOL] }", "nl": "[LINE] ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [LINE] protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] } public UntypedObjectDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Object[] NO_OBJECTS=Optional[new Object[0]]; UntypedObjectDeserializer instance=Optional[new UntypedObjectDeserializer()]"}
{"code": "public void testMixinMethodInheritance() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new Beano2()); [EOL]     assertEquals(2, result.size()); [EOL]     assertTrue(result.containsKey(\\\"id\\\")); [EOL]     assertTrue(result.containsKey(\\\"name\\\")); [EOL] }", "nl": "[LINE] if (EnumMap.class.isAssignableFrom(mapClass)) { [LINE] @Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings(\\\"unchecked\\\") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException(\\\"Can not construct EnumMap; generic (key) type not available\\\"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings(\\\"rawtypes\\\") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException(\\\"Can not find a deserializer for non-concrete Map type \\\" + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] int i = 0; [LINE] private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer != null) { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     for (String str : value) { [EOL]         try { [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]             ++i; [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] } protected StringCollectionSerializer(); protected StringCollectionSerializer(JsonSerializer<?> ser); protected JsonNode contentSchema(); protected void acceptContentVisitor(JsonArrayFormatVisitor visitor) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private final void _serializeUnwrapped(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private void serializeUsingCustom(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; StringCollectionSerializer instance=Optional[new StringCollectionSerializer()]; JsonSerializer<String> _serializer"}
{"code": "public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue(\\\"{\\\\\"booleanValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"byteValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"charValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"shortValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"intValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"longValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"floatValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"doubleValue\\\\\":\\\\\"\\\\\"}\\\", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }", "nl": "[LINE] if (rawType == Character.TYPE) { [LINE] public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException(\\\"Internal error: can't find deserializer for \\\" + rawType.getName()); [EOL] } protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl); public BooleanDeserializer(Class<Boolean> cls, Boolean nvl); public ByteDeserializer(Class<Byte> cls, Byte nvl); public ShortDeserializer(Class<Short> cls, Short nvl); public CharacterDeserializer(Class<Character> cls, Character nvl); public IntegerDeserializer(Class<Integer> cls, Integer nvl); public LongDeserializer(Class<Long> cls, Long nvl); public FloatDeserializer(Class<Float> cls, Float nvl); public DoubleDeserializer(Class<Double> cls, Double nvl); public NumberDeserializer(); public BigIntegerDeserializer(); public BigDecimalDeserializer(); public static StdDeserializer<?>[] all(); public static JsonDeserializer<?> find(Class<?> rawType, String clsName); public final T getNullValue(); public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Boolean deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Byte deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Integer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Long deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Float deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; HashSet<String> _classNames=Optional[new HashSet<String>()]"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertEquals(\\\"2\\\", map.get(\\\"b\\\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertNull(map.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] return getTypeFactory().constructSpecializedType(baseType, subclass); [LINE] public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getTypeFactory().constructSpecializedType(baseType, subclass); [EOL] } protected MapperConfig(BaseSettings base, int mapperFeatures); protected MapperConfig(MapperConfig<T> src); public static int collectFeatureDefaults(Class<F> enumClass); public abstract T with(MapperFeature... features); public abstract T without(MapperFeature... features); public final boolean isEnabled(MapperFeature f); public final boolean isAnnotationProcessingEnabled(); public final boolean canOverrideAccessModifiers(); public final boolean shouldSortPropertiesAlphabetically(); public abstract boolean useRootWrapping(); public ClassIntrospector getClassIntrospector(); public AnnotationIntrospector getAnnotationIntrospector(); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final PropertyNamingStrategy getPropertyNamingStrategy(); public final HandlerInstantiator getHandlerInstantiator(); public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType); public abstract SubtypeResolver getSubtypeResolver(); public final TypeFactory getTypeFactory(); public final JavaType constructType(Class<?> cls); public final JavaType constructType(TypeReference<?> valueTypeRef); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public BeanDescription introspectClassAnnotations(Class<?> cls); public abstract BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(Class<?> cls); public abstract BeanDescription introspectDirectClassAnnotations(JavaType type); public final DateFormat getDateFormat(); public final Locale getLocale(); public final TimeZone getTimeZone(); public abstract Class<?> getActiveView(); public Base64Variant getBase64Variant(); public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass); public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass); long serialVersionUID=Optional[8891625428805876137L]; int _mapperFeatures; BaseSettings _base"}
{"code": "public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, \\\"@class\\\"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println(\\\"deserialised list size = \\\" + result.size()); [EOL] }", "nl": "[LINE] idProp = null; [LINE] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException(\\\"Invalid Object Id definition for \\\" + beanDesc.getBeanClass().getName() + \\\": can not find property with name '\\\" + propName + \\\"'\\\"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }]; Class<?>[] NO_VIEWS=Optional[new Class<?>[0]]; BeanDeserializerFactory instance=Optional[new BeanDeserializerFactory(new DeserializerFactoryConfig())]"}
{"code": "public void testPOJO() { [EOL]     POJONode n = new POJONode(\\\"x\\\"); [EOL]     assertStandardEquals(n); [EOL]     assertEquals(n, new POJONode(\\\"x\\\")); [EOL]     assertEquals(\\\"x\\\", n.asText()); [EOL]     assertEquals(\\\"x\\\", n.toString()); [EOL]     assertEquals(new POJONode(null), new POJONode(null)); [EOL]     assertNodeNumbersForNonNumeric(n); [EOL]     assertNodeNumbers(new POJONode(Integer.valueOf(123)), 123, 123.0); [EOL] }", "nl": "[LINE] return other._value == null; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] } public POJONode(Object v); public JsonNodeType getNodeType(); public JsonToken asToken(); public byte[] binaryValue() throws IOException; public String asText(); public boolean asBoolean(boolean defaultValue); public int asInt(int defaultValue); public long asLong(long defaultValue); public double asDouble(double defaultValue); public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public Object getPojo(); public boolean equals(Object o); public int hashCode(); public String toString(); Object _value"}
{"code": "public void testGettersWithoutSetters() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     GettersWithoutSetters bean = new GettersWithoutSetters(123); [EOL]     assertFalse(m.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":3,\\\\\"b\\\\\":4,\\\\\"c\\\\\":5,\\\\\"d\\\\\":6}\\\", m.writeValueAsString(bean)); [EOL]     m = new ObjectMapper(); [EOL]     m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":3,\\\\\"c\\\\\":5,\\\\\"d\\\\\":6}\\\", m.writeValueAsString(bean)); [EOL] }", "nl": "[LINE] while (it.hasNext()) { [LINE] protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testSuperInterfaces() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { BaseInt.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }", "nl": "[LINE] return result; [LINE] public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] } private EnumTypeLocator(); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result); private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself); public static String canBeABeanType(Class<?> type); public static String isLocalType(Class<?> type, boolean allowNonStatic); public static Class<?> getOuterClass(Class<?> type); public static boolean isProxyType(Class<?> type); public static boolean isConcrete(Class<?> type); public static boolean isConcrete(Member member); public static boolean isCollectionMapOrArray(Class<?> type); public static String getClassDescription(Object classOrInstance); public static Class<?> findClass(String className) throws ClassNotFoundException; public static boolean hasGetterSignature(Method m); public static Throwable getRootCause(Throwable t); public static void throwRootCause(Throwable t) throws Exception; public static void throwAsIAE(Throwable t); public static void throwAsIAE(Throwable t, String msg); public static void unwrapAndThrowAsIAE(Throwable t); public static void unwrapAndThrowAsIAE(Throwable t, String msg); public static T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Object defaultValue(Class<?> cls); public static Class<?> wrapperType(Class<?> primitiveType); public static void checkAndFixAccess(Member member); public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s); public static Class<? extends Enum<?>> findEnumType(EnumMap<?, ?> m); public static Class<? extends Enum<?>> findEnumType(Enum<?> en); public static Class<? extends Enum<?>> findEnumType(Class<?> cls); public static boolean isJacksonStdImpl(Object impl); public static boolean isJacksonStdImpl(Class<?> implClass); public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set); public Class<? extends Enum<?>> enumTypeFor(EnumMap<?, ?> set); private Object get(Object bean, Field field); private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)"}
{"code": "public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23.789Z\\\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23Z\\\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T21:51:23.789+02:00\\\"); [EOL]     assertEquals(date, d); [EOL] }", "nl": "[LINE] result *= 10; [LINE] private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException(\\\"Invalid number: \\\" + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException(\\\"Invalid number: \\\" + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] } public static TimeZone timeZoneGMT(); public static String format(Date date); public static String format(Date date, boolean millis); public static String format(Date date, boolean millis, TimeZone tz); public static Date parse(String date); private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException; private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException; private static void padInt(StringBuilder buffer, int value, int length); String GMT_ID=Optional[\\\"GMT\\\"]; TimeZone TIMEZONE_GMT=Optional[TimeZone.getTimeZone(GMT_ID)]"}
{"code": "public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue(\\\"[ 1, 2 ]\\\", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail(\\\"Expected an exception, but got result value: \\\" + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, \\\"START_ARRAY\\\"); [EOL]     } [EOL] }", "nl": "[LINE] throw ctxt.mappingException(getMapClass()); [LINE] @Override [EOL] @SuppressWarnings(\\\"unchecked\\\") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), \\\"No default constructor found\\\"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] } public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser); protected MapDeserializer(MapDeserializer src); protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable); protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable); protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser); public void setIgnorableProperties(String[] ignorable); public void resolve(DeserializationContext ctxt) throws JsonMappingException; public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public final Class<?> getMapClass(); public JavaType getValueType(); protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Map<Object, Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void wrapAndThrow(Throwable t, Object ref) throws IOException; long serialVersionUID=Optional[-3378654289961736240L]; JavaType _mapType; KeyDeserializer _keyDeserializer; boolean _standardStringKey; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; ValueInstantiator _valueInstantiator; boolean _hasDefaultCreator; JsonDeserializer<Object> _delegateDeserializer; PropertyBasedCreator _propertyBasedCreator; HashSet<String> _ignorableProperties"}
{"code": "public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue(\\\"{\\\\\"beans\\\\\":[\\\\\"x\\\\\"]}\\\", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals(\\\"list=x\\\", bean.beans.get(0).value); [EOL]     bean = mapper.readValue(\\\"{\\\\\"beans\\\\\":[\\\\\"x\\\\\",\\\\\"y\\\\\",\\\\\"z\\\\\"]}\\\", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals(\\\"list=x\\\", bean.beans.get(0).value); [EOL]     assertEquals(\\\"list=y\\\", bean.beans.get(1).value); [EOL]     assertEquals(\\\"list=z\\\", bean.beans.get(2).value); [EOL] }", "nl": "[LINE] return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [LINE] @Override [EOL] public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] } public SimpleDeserializers(); public SimpleDeserializers(Map<Class<?>, JsonDeserializer<?>> desers); public void addDeserializer(Class<T> forClass, JsonDeserializer<? extends T> deser); public void addDeserializers(Map<Class<?>, JsonDeserializer<?>> desers); public JsonDeserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> findMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; long serialVersionUID=Optional[-3006673354353448880L]; HashMap<ClassKey, JsonDeserializer<?>> _classMappings=Optional[null]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] } public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private SerializationConfig(SerializationConfig src, SubtypeResolver str); private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures); private SerializationConfig(SerializationConfig src, BaseSettings base); private SerializationConfig(SerializationConfig src, FilterProvider filters); private SerializationConfig(SerializationConfig src, Class<?> view); private SerializationConfig(SerializationConfig src, JsonInclude.Include incl); private SerializationConfig(SerializationConfig src, String rootName); protected SerializationConfig(SerializationConfig src, Map<ClassKey, Class<?>> mixins); public SerializationConfig with(MapperFeature... features); public SerializationConfig without(MapperFeature... features); public SerializationConfig with(AnnotationIntrospector ai); public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public SerializationConfig with(ClassIntrospector ci); public SerializationConfig with(DateFormat df); public SerializationConfig with(HandlerInstantiator hi); public SerializationConfig with(PropertyNamingStrategy pns); public SerializationConfig withRootName(String rootName); public SerializationConfig with(SubtypeResolver str); public SerializationConfig with(TypeFactory tf); public SerializationConfig with(TypeResolverBuilder<?> trb); public SerializationConfig withView(Class<?> view); public SerializationConfig with(VisibilityChecker<?> vc); public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SerializationConfig with(Locale l); public SerializationConfig with(TimeZone tz); public SerializationConfig with(Base64Variant base64); private final SerializationConfig _withBase(BaseSettings newBase); public SerializationConfig with(SerializationFeature feature); public SerializationConfig with(SerializationFeature first, SerializationFeature... features); public SerializationConfig withFeatures(SerializationFeature... features); public SerializationConfig without(SerializationFeature feature); public SerializationConfig without(SerializationFeature first, SerializationFeature... features); public SerializationConfig withoutFeatures(SerializationFeature... features); public SerializationConfig withFilters(FilterProvider filterProvider); public SerializationConfig withSerializationInclusion(JsonInclude.Include incl); public boolean useRootWrapping(); public AnnotationIntrospector getAnnotationIntrospector(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(SerializationFeature f); public final int getSerializationFeatures(); public JsonInclude.Include getSerializationInclusion(); public FilterProvider getFilterProvider(); public T introspect(JavaType type); public String toString(); long serialVersionUID=Optional[8849092838541724233L]; int _serFeatures; JsonInclude.Include _serializationInclusion=Optional[null]; FilterProvider _filterProvider"}
{"code": "public void testForFactoryAndCtor() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     BaseClass result; [EOL]     result = m.readValue(\\\"\\\\\"string\\\\\"\\\", BaseClass.class); [EOL]     assertEquals(\\\"string...\\\", result._a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(BaseClass.class, MixIn.class); [EOL]     result = m.readValue(\\\"\\\\\"string\\\\\"\\\", BaseClass.class); [EOL]     assertEquals(\\\"stringX\\\", result._a); [EOL] }", "nl": "[LINE] if (m.getParameterTypes().length == 0) { [LINE] protected void _addFactoryMixIns(Class<?> mixin) { [EOL]     MemberKey[] methodKeys = null; [EOL]     int methodCount = _creatorMethods.size(); [EOL]     for (Method m : mixin.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (m.getParameterTypes().length == 0) { [EOL]             continue; [EOL]         } [EOL]         if (methodKeys == null) { [EOL]             methodKeys = new MemberKey[methodCount]; [EOL]             for (int i = 0; i < methodCount; ++i) { [EOL]                 methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated()); [EOL]             } [EOL]         } [EOL]         MemberKey key = new MemberKey(m); [EOL]         for (int i = 0; i < methodCount; ++i) { [EOL]             if (!key.equals(methodKeys[i])) { [EOL]                 continue; [EOL]             } [EOL]             _addMixOvers(m, _creatorMethods.get(i), true); [EOL]             break; [EOL]         } [EOL]     } [EOL] } private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations); public AnnotatedClass withAnnotations(AnnotationMap ann); public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public Class<?> getAnnotated(); public int getModifiers(); public String getName(); public A getAnnotation(Class<A> acls); public Type getGenericType(); public Class<?> getRawType(); protected AnnotationMap getAllAnnotations(); public Annotations getAnnotations(); public boolean hasAnnotations(); public AnnotatedConstructor getDefaultConstructor(); public List<AnnotatedConstructor> getConstructors(); public List<AnnotatedMethod> getStaticMethods(); public Iterable<AnnotatedMethod> memberMethods(); public int getMemberMethodCount(); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public int getFieldCount(); public Iterable<AnnotatedField> fields(); private void resolveClassAnnotations(); private void resolveCreators(); private void resolveMemberMethods(); private void resolveFields(); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin); protected void _addConstructorMixIns(Class<?> mixin); protected void _addFactoryMixIns(Class<?> mixin); protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields); protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields); protected AnnotatedMethod _constructMethod(Method m); protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor); protected AnnotatedMethod _constructCreatorMethod(Method m); protected AnnotatedField _constructField(Field f); private AnnotationMap _emptyAnnotationMap(); private AnnotationMap[] _emptyAnnotationMaps(int count); protected boolean _isIncludableMemberMethod(Method m); private boolean _isIncludableField(Field f); protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns); protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns); private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns); protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations); protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations); protected void _addMixUnders(Method src, AnnotatedMethod target); private final boolean _isAnnotationBundle(Annotation ann); public String toString(); AnnotationMap[] NO_ANNOTATION_MAPS=Optional[new AnnotationMap[0]]; Class<?> _class; List<Class<?>> _superTypes; AnnotationIntrospector _annotationIntrospector; MixInResolver _mixInResolver; Class<?> _primaryMixIn; AnnotationMap _classAnnotations; boolean _creatorsResolved=Optional[false]; AnnotatedConstructor _defaultConstructor; List<AnnotatedConstructor> _constructors; List<AnnotatedMethod> _creatorMethods; AnnotatedMethodMap _memberMethods; List<AnnotatedField> _fields"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] if (deser != null) { [LINE] protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] HashMap<String, ET> map = new HashMap<String, ET>(); [LINE] public static <ET extends Enum<ET>> EnumResolver<ET> constructFor(Class<ET> enumCls, AnnotationIntrospector ai) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     if (enumValues == null) { [EOL]         throw new IllegalArgumentException(\\\"No enum constants for class \\\" + enumCls.getName()); [EOL]     } [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (ET e : enumValues) { [EOL]         map.put(ai.findEnumValue(e), e); [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] } protected EnumResolver(Class<T> enumClass, T[] enums, HashMap<String, T> map); public static EnumResolver<ET> constructFor(Class<ET> enumCls, AnnotationIntrospector ai); public static EnumResolver<ET> constructUsingToString(Class<ET> enumCls); public static EnumResolver<ET> constructUsingMethod(Class<ET> enumCls, Method accessor); public static EnumResolver<?> constructUnsafe(Class<?> rawEnumCls, AnnotationIntrospector ai); public static EnumResolver<?> constructUnsafeUsingToString(Class<?> rawEnumCls); public static EnumResolver<?> constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor); public T findEnum(String key); public T getEnum(int index); public Class<T> getEnumClass(); public int lastValidIndex(); long serialVersionUID=Optional[1L]; Class<T> _enumClass; T[] _enums; HashMap<String, T> _enumsById"}
{"code": "public void testJackson744() throws Exception { [EOL]     BasicBeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue744Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL]     AnnotatedMethod setter = beanDesc.findAnySetter(); [EOL]     assertNotNull(setter); [EOL] }", "nl": "[LINE] _anyGetters.add(m); [LINE] protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] _defaultCreator = defaultCreator; [LINE] public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, CreatorProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs) { [EOL]     _defaultCreator = defaultCreator; [EOL]     _delegateCreator = delegateCreator; [EOL]     _delegateType = delegateType; [EOL]     _delegateArguments = delegateArgs; [EOL]     _withArgsCreator = withArgsCreator; [EOL]     _constructorArguments = constructorArgs; [EOL] } public StdValueInstantiator(DeserializationConfig config, Class<?> valueType); public StdValueInstantiator(DeserializationConfig config, JavaType valueType); protected StdValueInstantiator(StdValueInstantiator src); public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, CreatorProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs); public void configureFromStringCreator(AnnotatedWithParams creator); public void configureFromIntCreator(AnnotatedWithParams creator); public void configureFromLongCreator(AnnotatedWithParams creator); public void configureFromDoubleCreator(AnnotatedWithParams creator); public void configureFromBooleanCreator(AnnotatedWithParams creator); public void configureIncompleteParameter(AnnotatedParameter parameter); public String getValueTypeDesc(); public boolean canCreateFromString(); public boolean canCreateFromInt(); public boolean canCreateFromLong(); public boolean canCreateFromDouble(); public boolean canCreateFromBoolean(); public boolean canCreateUsingDefault(); public boolean canCreateUsingDelegate(); public boolean canCreateFromObjectWith(); public JavaType getDelegateType(DeserializationConfig config); public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config); public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException; public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException; public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException; public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException; public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException; public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException; public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException; public AnnotatedWithParams getDelegateCreator(); public AnnotatedWithParams getDefaultCreator(); public AnnotatedWithParams getWithArgsCreator(); public AnnotatedParameter getIncompleteParameter(); protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException; protected JsonMappingException wrapException(Throwable t); long serialVersionUID=Optional[1L]; String _valueTypeDesc; boolean _cfgEmptyStringsAsObjects; AnnotatedWithParams _defaultCreator; AnnotatedWithParams _withArgsCreator; CreatorProperty[] _constructorArguments; JavaType _delegateType; AnnotatedWithParams _delegateCreator; CreatorProperty[] _delegateArguments; AnnotatedWithParams _fromStringCreator; AnnotatedWithParams _fromIntCreator; AnnotatedWithParams _fromLongCreator; AnnotatedWithParams _fromDoubleCreator; AnnotatedWithParams _fromBooleanCreator; AnnotatedParameter _incompleteParameter"}
{"code": "public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(\\\" { \\\\\"values\\\\\" : { \\\\\"a\\\\\": 1, \\\\\"b\\\\\":2 } } \\\", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get(\\\"a\\\").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get(\\\"a\\\"))._a); [EOL]     assertEquals(ValueClass.class, map.get(\\\"b\\\").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get(\\\"b\\\"))._a); [EOL] }", "nl": "[LINE] if (_propertyBasedCreator != null) { [LINE] @Override [EOL] @SuppressWarnings(\\\"unchecked\\\") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), \\\"No default constructor found\\\"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] } public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser); protected MapDeserializer(MapDeserializer src); protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable); protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable); protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser); public void setIgnorableProperties(String[] ignorable); public void resolve(DeserializationContext ctxt) throws JsonMappingException; public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public final Class<?> getMapClass(); public JavaType getValueType(); protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException; public Map<Object, Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void wrapAndThrow(Throwable t, Object ref) throws IOException; long serialVersionUID=Optional[-3378654289961736240L]; JavaType _mapType; KeyDeserializer _keyDeserializer; boolean _standardStringKey; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; ValueInstantiator _valueInstantiator; boolean _hasDefaultCreator; JsonDeserializer<Object> _delegateDeserializer; PropertyBasedCreator _propertyBasedCreator; HashSet<String> _ignorableProperties"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] jgen.writeString(value); [LINE] @Override [EOL] public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value); [EOL] } public StringSerializer(); public boolean isEmpty(String value); public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException"}
{"code": "public void testEmptyStringForWrappers() throws IOException { [EOL]     WrappersBean bean; [EOL]     bean = mapper.readValue(\\\"{\\\\\"booleanValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.booleanValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"byteValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.byteValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"charValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.charValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"shortValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.shortValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"intValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.intValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"longValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.longValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"floatValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.floatValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"doubleValue\\\\\":\\\\\"\\\\\"}\\\", WrappersBean.class); [EOL]     assertNull(bean.doubleValue); [EOL] }", "nl": "[LINE] int value; [LINE] protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, \\\"not a valid Short value\\\"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, \\\"overflow, value can not be represented as 16-bit value\\\"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } protected StdDeserializer(Class<?> vc); protected StdDeserializer(JavaType valueType); public Class<?> getValueClass(); public JavaType getValueType(); protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer); protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected static final double parseDouble(String numStr) throws NumberFormatException; protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException; protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException; protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Class<?> _valueClass"}
{"code": "public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO(\\\"foobar\\\"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals(\\\"foobar\\\", result.value); [EOL] }", "nl": "[LINE] case VALUE_STRING: [LINE] @SuppressWarnings(\\\"incomplete-switch\\\") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] } public abstract TypeDeserializer forProperty(BeanProperty prop); public abstract As getTypeInclusion(); public abstract String getPropertyName(); public abstract TypeIdResolver getTypeIdResolver(); public abstract Class<?> getDefaultImpl(); public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, JavaType baseType) throws IOException, JsonProcessingException; public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] _type = null; [LINE] public TypeKey(Class<?> key, boolean typed) { [EOL]     _class = key; [EOL]     _type = null; [EOL]     _isTyped = typed; [EOL]     _hashCode = hash(key, typed); [EOL] } public SerializerCache(); public TypeKey(Class<?> key, boolean typed); public TypeKey(JavaType key, boolean typed); public ReadOnlyClassToSerializerMap getReadOnlyLookupMap(); public synchronized int size(); public JsonSerializer<Object> untypedValueSerializer(Class<?> type); public JsonSerializer<Object> untypedValueSerializer(JavaType type); public JsonSerializer<Object> typedValueSerializer(JavaType type); public JsonSerializer<Object> typedValueSerializer(Class<?> cls); public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser); public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser); public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException; public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException; public synchronized void flush(); private static final int hash(Class<?> cls, boolean typed); private static final int hash(JavaType type, boolean typed); public void resetTyped(Class<?> cls); public void resetUntyped(Class<?> cls); public void resetTyped(JavaType type); public void resetUntyped(JavaType type); public final int hashCode(); public final String toString(); public final boolean equals(Object o); HashMap<TypeKey, JsonSerializer<Object>> _sharedMap=Optional[new HashMap<TypeKey, JsonSerializer<Object>>(64)]; ReadOnlyClassToSerializerMap _readOnlyMap=Optional[null]"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [LINE] @Override [EOL] public boolean useRootWrapping() { [EOL]     if (_rootName != null) { [EOL]         return (_rootName.length() > 0); [EOL]     } [EOL]     return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] } public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private DeserializationConfig(DeserializationConfig src, SubtypeResolver str); private DeserializationConfig(DeserializationConfig src, int mapperFeatures, int deserFeatures); private DeserializationConfig(DeserializationConfig src, BaseSettings base); private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f); private DeserializationConfig(DeserializationConfig src, LinkedNode<DeserializationProblemHandler> problemHandlers); private DeserializationConfig(DeserializationConfig src, String rootName); private DeserializationConfig(DeserializationConfig src, Class<?> view); protected DeserializationConfig(DeserializationConfig src, Map<ClassKey, Class<?>> mixins); protected BaseSettings getBaseSettings(); public DeserializationConfig with(MapperFeature... features); public DeserializationConfig without(MapperFeature... features); public DeserializationConfig with(ClassIntrospector ci); public DeserializationConfig with(AnnotationIntrospector ai); public DeserializationConfig with(VisibilityChecker<?> vc); public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public DeserializationConfig with(TypeResolverBuilder<?> trb); public DeserializationConfig with(SubtypeResolver str); public DeserializationConfig with(PropertyNamingStrategy pns); public DeserializationConfig withRootName(String rootName); public DeserializationConfig with(TypeFactory tf); public DeserializationConfig with(DateFormat df); public DeserializationConfig with(HandlerInstantiator hi); public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withView(Class<?> view); public DeserializationConfig with(Locale l); public DeserializationConfig with(TimeZone tz); public DeserializationConfig with(Base64Variant base64); private final DeserializationConfig _withBase(BaseSettings newBase); public DeserializationConfig with(JsonNodeFactory f); public DeserializationConfig withHandler(DeserializationProblemHandler h); public DeserializationConfig withNoProblemHandlers(); public DeserializationConfig with(DeserializationFeature feature); public DeserializationConfig with(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withFeatures(DeserializationFeature... features); public DeserializationConfig without(DeserializationFeature feature); public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withoutFeatures(DeserializationFeature... features); public AnnotationIntrospector getAnnotationIntrospector(); public boolean useRootWrapping(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(DeserializationFeature f); public final int getDeserializationFeatures(); public LinkedNode<DeserializationProblemHandler> getProblemHandlers(); public final JsonNodeFactory getNodeFactory(); public T introspect(JavaType type); public T introspectForCreation(JavaType type); public T introspectForBuilder(JavaType type); long serialVersionUID=Optional[-4227480407273773599L]; int _deserFeatures; LinkedNode<DeserializationProblemHandler> _problemHandlers; JsonNodeFactory _nodeFactory"}
{"code": "public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\\\"{\\\\\"number\\\\\":17}\\\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }", "nl": "[LINE] public StdValueInstantiator(DeserializationConfig config, JavaType valueType) [LINE] public StdValueInstantiator(DeserializationConfig config, JavaType valueType) { [EOL]     _cfgEmptyStringsAsObjects = (config == null) ? false : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT); [EOL]     _valueTypeDesc = (valueType == null) ? \\\"UNKNOWN TYPE\\\" : valueType.toString(); [EOL] } public StdValueInstantiator(DeserializationConfig config, Class<?> valueType); public StdValueInstantiator(DeserializationConfig config, JavaType valueType); protected StdValueInstantiator(StdValueInstantiator src); public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, CreatorProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs); public void configureFromStringCreator(AnnotatedWithParams creator); public void configureFromIntCreator(AnnotatedWithParams creator); public void configureFromLongCreator(AnnotatedWithParams creator); public void configureFromDoubleCreator(AnnotatedWithParams creator); public void configureFromBooleanCreator(AnnotatedWithParams creator); public void configureIncompleteParameter(AnnotatedParameter parameter); public String getValueTypeDesc(); public boolean canCreateFromString(); public boolean canCreateFromInt(); public boolean canCreateFromLong(); public boolean canCreateFromDouble(); public boolean canCreateFromBoolean(); public boolean canCreateUsingDefault(); public boolean canCreateUsingDelegate(); public boolean canCreateFromObjectWith(); public JavaType getDelegateType(DeserializationConfig config); public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config); public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException; public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException; public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException; public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException; public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException; public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException; public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException; public AnnotatedWithParams getDelegateCreator(); public AnnotatedWithParams getDefaultCreator(); public AnnotatedWithParams getWithArgsCreator(); public AnnotatedParameter getIncompleteParameter(); protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException; protected JsonMappingException wrapException(Throwable t); long serialVersionUID=Optional[1L]; String _valueTypeDesc; boolean _cfgEmptyStringsAsObjects; AnnotatedWithParams _defaultCreator; AnnotatedWithParams _withArgsCreator; CreatorProperty[] _constructorArguments; JavaType _delegateType; AnnotatedWithParams _delegateCreator; CreatorProperty[] _delegateArguments; AnnotatedWithParams _fromStringCreator; AnnotatedWithParams _fromIntCreator; AnnotatedWithParams _fromLongCreator; AnnotatedWithParams _fromDoubleCreator; AnnotatedWithParams _fromBooleanCreator; AnnotatedParameter _incompleteParameter"}
{"code": "public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue(\\\"{\\\\\"intValue\\\\\":null, \\\\\"booleanValue\\\\\":null, \\\\\"doubleValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue(\\\"{\\\\\"byteValue\\\\\":null, \\\\\"longValue\\\\\":null, \\\\\"floatValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"booleanValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for boolean + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type boolean\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"byteValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for byte + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type byte\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"charValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for char + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type char\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"shortValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for short + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type short\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"intValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for int + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type int\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"longValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for long + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type long\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"floatValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for float + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type float\\\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\\\"{\\\\\"doubleValue\\\\\":null}\\\", PrimitivesBean.class); [EOL]         fail(\\\"Expected failure for double + null\\\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \\\"Can not map JSON null into type double\\\"); [EOL]     } [EOL] }", "nl": "[LINE] if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { [LINE] public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException { [EOL]     if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { [EOL]         throw ctxt.mappingException(\\\"Can not map JSON null into type \\\" + _rawType.getName() + \\\" (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\\\"); [EOL]     } [EOL]     return _nullValue; [EOL] } public NullProvider(JavaType type, Object nullValue); public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException; long serialVersionUID=Optional[1L]; Object _nullValue; boolean _isPrimitive; Class<?> _rawType"}
{"code": "public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals(\\\"{\\\\\"nums\\\\\":[\\\\\"java.util.ArrayList\\\\\",[[\\\\\"java.lang.Long\\\\\",1],2,3.0]]}\\\", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }", "nl": "[LINE] case VALUE_NUMBER_INT: [LINE] @SuppressWarnings(\\\"incomplete-switch\\\") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] } protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl); public BooleanDeserializer(Class<Boolean> cls, Boolean nvl); public ByteDeserializer(Class<Byte> cls, Byte nvl); public ShortDeserializer(Class<Short> cls, Short nvl); public CharacterDeserializer(Class<Character> cls, Character nvl); public IntegerDeserializer(Class<Integer> cls, Integer nvl); public LongDeserializer(Class<Long> cls, Long nvl); public FloatDeserializer(Class<Float> cls, Float nvl); public DoubleDeserializer(Class<Double> cls, Double nvl); public NumberDeserializer(); public BigIntegerDeserializer(); public BigDecimalDeserializer(); public static StdDeserializer<?>[] all(); public static JsonDeserializer<?> find(Class<?> rawType, String clsName); public final T getNullValue(); public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Boolean deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Byte deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Integer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Long deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Float deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; HashSet<String> _classNames=Optional[new HashSet<String>()]"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }", "nl": "[LINE] if (ob instanceof SerializableString) { [LINE] public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { [EOL]     Segment segment = _first; [EOL]     int ptr = -1; [EOL]     while (true) { [EOL]         if (++ptr >= Segment.TOKENS_PER_SEGMENT) { [EOL]             ptr = 0; [EOL]             segment = segment.next(); [EOL]             if (segment == null) [EOL]                 break; [EOL]         } [EOL]         JsonToken t = segment.type(ptr); [EOL]         if (t == null) [EOL]             break; [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 jgen.writeStartObject(); [EOL]                 break; [EOL]             case END_OBJECT: [EOL]                 jgen.writeEndObject(); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 jgen.writeStartArray(); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 jgen.writeEndArray(); [EOL]                 break; [EOL]             case FIELD_NAME: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeFieldName((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeFieldName((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeString((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeString((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_INT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Integer) { [EOL]                         jgen.writeNumber((Integer) n); [EOL]                     } else if (n instanceof BigInteger) { [EOL]                         jgen.writeNumber((BigInteger) n); [EOL]                     } else if (n instanceof Long) { [EOL]                         jgen.writeNumber((Long) n); [EOL]                     } else if (n instanceof Short) { [EOL]                         jgen.writeNumber((Short) n); [EOL]                     } else { [EOL]                         jgen.writeNumber(((Number) n).intValue()); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Double) { [EOL]                         jgen.writeNumber(((Double) n).doubleValue()); [EOL]                     } else if (n instanceof BigDecimal) { [EOL]                         jgen.writeNumber((BigDecimal) n); [EOL]                     } else if (n instanceof Float) { [EOL]                         jgen.writeNumber(((Float) n).floatValue()); [EOL]                     } else if (n == null) { [EOL]                         jgen.writeNull(); [EOL]                     } else if (n instanceof String) { [EOL]                         jgen.writeNumber((String) n); [EOL]                     } else { [EOL]                         throw new JsonGenerationException(\\\"Unrecognized value type for VALUE_NUMBER_FLOAT: \\\" + n.getClass().getName() + \\\", can not serialize\\\"); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_TRUE: [EOL]                 jgen.writeBoolean(true); [EOL]                 break; [EOL]             case VALUE_FALSE: [EOL]                 jgen.writeBoolean(false); [EOL]                 break; [EOL]             case VALUE_NULL: [EOL]                 jgen.writeNull(); [EOL]                 break; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 jgen.writeObject(segment.get(ptr)); [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException(\\\"Internal error: should never end up through this code path\\\"); [EOL]         } [EOL]     } [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \\\"root\\\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \\\"leaf\\\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\\\"{\\\\\"id\\\\\":1,\\\\\"name\\\\\":\\\\\"root\\\\\",\\\\\"parent\\\\\":null,\\\\\"child\\\\\":\\\" + \\\"{\\\\\"id\\\\\":2,\\\\\"name\\\\\":\\\\\"leaf\\\\\",\\\\\"parent\\\\\":1,\\\\\"child\\\\\":null}}\\\", json); [EOL] }", "nl": "[LINE] Object id = objectId.generateId(bean); [LINE] protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] } protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore); protected BeanSerializerBase(BeanSerializerBase src); protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper); public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter); protected abstract BeanSerializerBase withIgnorals(String[] toIgnore); protected abstract BeanSerializerBase asArraySerializer(); private static final BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer); public void resolve(SerializerProvider provider) throws JsonMappingException; protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public boolean usesObjectId(); public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException; protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final String _customTypeId(Object bean); protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; BeanPropertyWriter[] NO_PROPS=Optional[new BeanPropertyWriter[0]]; BeanPropertyWriter[] _props; BeanPropertyWriter[] _filteredProps; AnyGetterWriter _anyGetterWriter; Object _propertyFilterId; AnnotatedMember _typeId; ObjectIdWriter _objectIdWriter; JsonFormat.Shape _serializationShape"}
{"code": "public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \\\"{\\\\\"id\\\\\": 5, \\\\\"defaultValue\\\\\": { \\\\\"value\\\\\": \\\\\"123\\\\\" } }\\\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\\\"should have raised exception instead value was set to \\\" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"not numeric\\\"); [EOL]     } [EOL] }", "nl": "[LINE] return deser; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] } public DeserializerCache();  Object writeReplace(); public int cachedDeserializersCount(); public void flushCachedDeserializers(); public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException; public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type); protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type); protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException; protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException; private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException; private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException; protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException; long serialVersionUID=Optional[1L]; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2)]; HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers=Optional[new HashMap<JavaType, JsonDeserializer<Object>>(8)]"}
{"code": "public void testCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(ArrayList.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     t = tf.constructType(new TypeReference<ArrayList<String>>() { [EOL]     }); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     JavaType elemType = ((CollectionType) t).getContentType(); [EOL]     assertNotNull(elemType); [EOL]     assertSame(SimpleType.class, elemType.getClass()); [EOL]     assertSame(String.class, elemType.getRawClass()); [EOL]     t = tf.constructCollectionType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(String.class, ((CollectionType) t).getContentType().getRawClass()); [EOL] }", "nl": "[LINE] return findTypeParameters(raw, expType, new TypeBindings(this, type)); [LINE] public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testWithCreator() throws IOException { [EOL]     final String MSG = \\\"the message\\\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\\\"foo\\\")); [EOL] }", "nl": "[LINE] public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) [LINE] public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] } public AnnotationMap(); private AnnotationMap(HashMap<Class<? extends Annotation>, Annotation> a); public A get(Class<A> cls); public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary); public int size(); public void addIfNotPresent(Annotation ann); public void add(Annotation ann); public String toString(); protected final void _add(Annotation ann); HashMap<Class<? extends Annotation>, Annotation> _annotations"}
{"code": "public void testDataBindingUsage() throws Exception { [EOL]     ObjectMapper objectMapper = createObjectMapper(null); [EOL]     String result = serializeWithObjectMapper(new ComplexTestData(), Views.View.class, objectMapper); [EOL]     assertEquals(-1, result.indexOf(\\\"nameHidden\\\")); [EOL] }", "nl": "[LINE] _delegate.serializeAsField(bean, jgen, prov); [LINE] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsField(bean, jgen, prov); [EOL]     } [EOL] } protected SingleView(BeanPropertyWriter delegate, Class<?> view); protected MultiView(BeanPropertyWriter delegate, Class<?>[] views); public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn); public SingleView rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public MultiView rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception"}
{"code": "public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree(\\\"{ \\\\\"name\\\\\" : \\\\\"Tatu\\\\\", \\n\\\" + \\\"\\\\\"magicNumber\\\\\" : 42,\\\" + \\\"\\\\\"kids\\\\\" : [ \\\\\"Leo\\\\\", \\\\\"Lila\\\\\", \\\\\"Leia\\\\\" ] \\n\\\" + \\\"}\\\"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals(\\\"Tatu\\\", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals(\\\"Leo\\\", tatu.kids.get(0)); [EOL]     assertEquals(\\\"Lila\\\", tatu.kids.get(1)); [EOL]     assertEquals(\\\"Leia\\\", tatu.kids.get(2)); [EOL] }", "nl": "[LINE] try { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\\\"c3VyZS4=\\\", byte[].class); [EOL]     byte[] exp = \\\"sure.\\\".getBytes(\\\"Ascii\\\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }", "nl": "[LINE] return _config.getBase64Variant(); [LINE] public final Base64Variant getBase64Variant() { [EOL]     return _config.getBase64Variant(); [EOL] } protected DeserializationContext(DeserializerFactory df); protected DeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DeserializationContext(DeserializationContext src, DeserializerFactory factory); protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues injectableValues); public DeserializationConfig getConfig(); public final Class<?> getActiveView(); public final AnnotationIntrospector getAnnotationIntrospector(); public final TypeFactory getTypeFactory(); public DeserializerFactory getFactory(); public final boolean isEnabled(DeserializationFeature feat); public final JsonParser getParser(); public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance); public final Base64Variant getBase64Variant(); public final JsonNodeFactory getNodeFactory(); public Locale getLocale(); public TimeZone getTimeZone(); public boolean hasValueDeserializerFor(JavaType type); public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty property) throws JsonMappingException; public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException; public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty property) throws JsonMappingException; public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public final JavaType constructType(Class<?> cls); public Class<?> findClass(String className) throws ClassNotFoundException; public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final ObjectBuffer leaseObjectBuffer(); public final void returnObjectBuffer(ObjectBuffer buf); public final ArrayBuilders getArrayBuilders(); public Date parseDate(String dateStr) throws IllegalArgumentException; public Calendar constructCalendar(Date d); public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException; public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException; public JsonMappingException mappingException(Class<?> targetClass); public JsonMappingException mappingException(Class<?> targetClass, JsonToken token); public JsonMappingException mappingException(String message); public JsonMappingException instantiationException(Class<?> instClass, Throwable t); public JsonMappingException instantiationException(Class<?> instClass, String msg); public JsonMappingException weirdStringException(Class<?> instClass, String msg); public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg); public JsonMappingException weirdNumberException(Class<?> instClass, String msg); public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg); public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg); public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg); public JsonMappingException unknownTypeException(JavaType type, String id); public JsonMappingException endOfInputException(Class<?> instClass); protected DateFormat getDateFormat(); protected String determineClassName(Object instance); protected String _calcName(Class<?> cls); protected String _valueDesc(); protected String _desc(String desc); long serialVersionUID=Optional[-7727373309391091315L]; int MAX_ERROR_STR_LEN=Optional[500]; DeserializerCache _cache; DeserializerFactory _factory; DeserializationConfig _config; int _featureFlags; Class<?> _view; JsonParser _parser; InjectableValues _injectableValues; ArrayBuilders _arrayBuilders; ObjectBuffer _objectBuffer; DateFormat _dateFormat"}
{"code": "public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\\\"a\\\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":{\\\\\"a\\\\\":3}}\\\", listJson); [EOL] }", "nl": "[LINE] JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [LINE] @Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testIssue476() throws Exception { [EOL]     final String JSON = \\\"{\\\\\"value1\\\\\" : {\\\\\"name\\\\\" : \\\\\"fruit\\\\\", \\\\\"value\\\\\" : \\\\\"apple\\\\\"}, \\\\\"value2\\\\\" : {\\\\\"name\\\\\" : \\\\\"color\\\\\", \\\\\"value\\\\\" : \\\\\"red\\\\\"}}\\\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new Issue476Module()); [EOL]     mapper.readValue(JSON, Issue476Bean.class); [EOL]     assertEquals(2, Issue476Deserializer.propCount); [EOL] }", "nl": "[LINE] super(src, src._ignoreAllUnknown); [LINE] protected BeanDeserializer(BeanDeserializerBase src) { [EOL]     super(src, src._ignoreAllUnknown); [EOL] } public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews); protected BeanDeserializer(BeanDeserializerBase src); protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown); protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper); public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir); public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanDeserializer withObjectIdReader(ObjectIdReader oir); public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanDeserializerBase asArrayDeserializer(); public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; protected Object _missingToken(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); [LINE] protected boolean isPotentialBeanType(Class<?> type) { [EOL]     return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testMixinMethodInheritance() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new Beano2()); [EOL]     assertEquals(2, result.size()); [EOL]     assertTrue(result.containsKey(\\\"id\\\")); [EOL]     assertTrue(result.containsKey(\\\"name\\\")); [EOL] }", "nl": "[LINE] return deser; [LINE] @Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings(\\\"unchecked\\\") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException(\\\"Can not construct EnumMap; generic (key) type not available\\\"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings(\\\"rawtypes\\\") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException(\\\"Can not find a deserializer for non-concrete Map type \\\" + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, [LINE] protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] } public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator); protected StringCollectionDeserializer(JavaType collectionType, ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser); protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser); public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonDeserializer<Object> getContentDeserializer(); public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException; private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt, Collection<String> result, final JsonDeserializer<String> deser) throws IOException, JsonProcessingException; public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; JavaType _collectionType; JsonDeserializer<String> _valueDeserializer; ValueInstantiator _valueInstantiator; JsonDeserializer<Object> _delegateDeserializer"}
{"code": "public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO(\\\"foobar\\\"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, \\\"xxx\\\"); [EOL]     assertEquals(10, n.size()); [EOL] }", "nl": "[LINE] _add(POJONode(value)); [LINE] public ArrayNode addPOJO(Object value) { [EOL]     if (value == null) { [EOL]         addNull(); [EOL]     } else { [EOL]         _add(POJONode(value)); [EOL]     } [EOL]     return this; [EOL] } public ArrayNode(JsonNodeFactory nc); public ArrayNode deepCopy(); public JsonNodeType getNodeType(); public JsonToken asToken(); public int size(); public Iterator<JsonNode> elements(); public JsonNode get(int index); public JsonNode get(String fieldName); public JsonNode path(String fieldName); public JsonNode path(int index); public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException; public JsonNode findValue(String fieldName); public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar); public List<String> findValuesAsText(String fieldName, List<String> foundSoFar); public ObjectNode findParent(String fieldName); public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar); public JsonNode set(int index, JsonNode value); public ArrayNode add(JsonNode value); public ArrayNode addAll(ArrayNode other); public ArrayNode addAll(Collection<JsonNode> nodes); public ArrayNode insert(int index, JsonNode value); public JsonNode remove(int index); public ArrayNode removeAll(); public ArrayNode addArray(); public ObjectNode addObject(); public ArrayNode addPOJO(Object value); public ArrayNode addNull(); public ArrayNode add(int v); public ArrayNode add(Integer value); public ArrayNode add(long v); public ArrayNode add(Long value); public ArrayNode add(float v); public ArrayNode add(Float value); public ArrayNode add(double v); public ArrayNode add(Double value); public ArrayNode add(BigDecimal v); public ArrayNode add(String v); public ArrayNode add(boolean v); public ArrayNode add(Boolean value); public ArrayNode add(byte[] v); public ArrayNode insertArray(int index); public ObjectNode insertObject(int index); public ArrayNode insertPOJO(int index, Object value); public ArrayNode insertNull(int index); public ArrayNode insert(int index, int v); public ArrayNode insert(int index, Integer value); public ArrayNode insert(int index, long v); public ArrayNode insert(int index, Long value); public ArrayNode insert(int index, float v); public ArrayNode insert(int index, Float value); public ArrayNode insert(int index, double v); public ArrayNode insert(int index, Double value); public ArrayNode insert(int index, BigDecimal v); public ArrayNode insert(int index, String v); public ArrayNode insert(int index, boolean v); public ArrayNode insert(int index, Boolean value); public ArrayNode insert(int index, byte[] v); public boolean equals(Object o); public int hashCode(); public String toString(); private ArrayNode _add(JsonNode node); private ArrayNode _insert(int index, JsonNode node); List<JsonNode> _children=Optional[new ArrayList<JsonNode>()]"}
{"code": "public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \\\"root\\\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \\\"leaf\\\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\\\"{\\\\\"id\\\\\":1,\\\\\"name\\\\\":\\\\\"root\\\\\",\\\\\"parent\\\\\":null,\\\\\"child\\\\\":\\\" + \\\"{\\\\\"id\\\\\":2,\\\\\"name\\\\\":\\\\\"leaf\\\\\",\\\\\"parent\\\\\":1,\\\\\"child\\\\\":null}}\\\", json); [EOL] }", "nl": "[LINE] return new BeanSerializer(this, objectIdWriter); [LINE] @Override [EOL] public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) { [EOL]     return new BeanSerializer(this, objectIdWriter); [EOL] } public BeanSerializer(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties); protected BeanSerializer(BeanSerializerBase src); protected BeanSerializer(BeanSerializerBase src, ObjectIdWriter objectIdWriter); protected BeanSerializer(BeanSerializerBase src, String[] toIgnore); public static BeanSerializer createDummy(JavaType forType); public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper); public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter); protected BeanSerializer withIgnorals(String[] toIgnore); protected BeanSerializerBase asArraySerializer(); public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public String toString()"}
{"code": "public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException(\\\"TEST\\\"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }", "nl": "[LINE] prop = (SettableBeanProperty)pending[i]; [LINE] @Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, \\\"Can not instantiate abstract type \\\" + _beanType + \\\" (need to add/enable type information?)\\\"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException(\\\"Can not deserialize Throwable of type \\\" + _beanType + \\\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\\\"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] } public ThrowableDeserializer(BeanDeserializer baseDeserializer); protected ThrowableDeserializer(BeanDeserializer src, NameTransformer unwrapper); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; String PROP_NAME_MESSAGE=Optional[\\\"message\\\"]"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] _typeSerializer = typeSer; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException(\\\"Can not pass member of type \\\" + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] } public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue); protected BeanPropertyWriter(BeanPropertyWriter base); protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name); public BeanPropertyWriter rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper); public void setNonTrivialBaseType(JavaType t); public String getName(); public JavaType getType(); public PropertyName getWrapperName(); public boolean isRequired(); public A getAnnotation(Class<A> acls); public A getContextAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; public Object getInternalSetting(Object key); public Object setInternalSetting(Object key, Object value); public Object removeInternalSetting(Object key); public SerializedString getSerializedName(); public boolean hasSerializer(); public boolean hasNullSerializer(); public boolean willSuppressNulls(); public JsonSerializer<Object> getSerializer(); public JavaType getSerializationType(); public Class<?> getRawSerializationType(); public Class<?> getPropertyType(); public Type getGenericPropertyType(); public Class<?>[] getViews(); protected boolean isRequired(AnnotationIntrospector intr); public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException; public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; public final Object get(Object bean) throws Exception; protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException; public String toString(); Object MARKER_FOR_EMPTY=Optional[new Object()]; AnnotatedMember _member; Annotations _contextAnnotations; JavaType _declaredType; Method _accessorMethod; Field _field; HashMap<Object, Object> _internalSettings; SerializedString _name; PropertyName _wrapperName; JavaType _cfgSerializationType; JsonSerializer<Object> _serializer; JsonSerializer<Object> _nullSerializer; PropertySerializerMap _dynamicSerializers; boolean _suppressNulls; Object _suppressableValue; Class<?>[] _includeInViews; TypeSerializer _typeSerializer; JavaType _nonTrivialBaseType; boolean _isRequired"}
{"code": "public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals(\\\"uri\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"url\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testNull\\\")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals(\\\"testString\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testBoolean\\\")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals(\\\"testEnum\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testInteger\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals(\\\"testLong\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals(\\\"testBigInteger\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals(\\\"testBigDecimal\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals(\\\"testCharacter\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testShort\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals(\\\"testByte\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals(\\\"testFloat\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals(\\\"testDouble\\\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals(\\\"testStringBuffer\\\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\\\"testError\\\")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals(\\\"cause\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals(\\\"message\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals(\\\"localizedMessage\\\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals(\\\"stackTrace\\\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue(\\\"Probably run away loop in test. StackTrack Array was not properly closed.\\\", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals(\\\"suppressed\\\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail(\\\"Unexpected field name '\\\" + name + \\\"'\\\"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail(\\\"Unexpected field, name '\\\" + name + \\\"'\\\"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }", "nl": "[LINE] if (value instanceof BigDecimal) { [LINE] @Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] } protected NumberSerializers(); public ShortSerializer(); public IntegerSerializer(); public IntLikeSerializer(); public LongSerializer(); public FloatSerializer(); public DoubleSerializer(); public NumberSerializer(); public static void addAll(Map<String, JsonSerializer<?>> allDeserializers); public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint); public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException"}
{"code": "public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { \\\"me\\\", \\\"you\\\", \\\"him\\\" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \\\"you\\\"); [EOL]     Assert.assertArrayEquals(new String[] { \\\"you\\\", \\\"me\\\", \\\"him\\\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \\\"me\\\"); [EOL]     Assert.assertArrayEquals(new String[] { \\\"me\\\", \\\"you\\\", \\\"him\\\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \\\"him\\\"); [EOL]     Assert.assertArrayEquals(new String[] { \\\"him\\\", \\\"me\\\", \\\"you\\\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \\\"foobar\\\"); [EOL]     Assert.assertArrayEquals(new String[] { \\\"foobar\\\", \\\"me\\\", \\\"you\\\", \\\"him\\\" }, newarr); [EOL] }", "nl": "[LINE] return result; [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public static <T> T[] insertInListNoDup(T[] array, T element) { [EOL]     final int len = array.length; [EOL]     for (int ix = 0; ix < len; ++ix) { [EOL]         if (array[ix] == element) { [EOL]             if (ix == 0) { [EOL]                 return array; [EOL]             } [EOL]             T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len); [EOL]             System.arraycopy(array, 0, result, 1, ix); [EOL]             result[0] = element; [EOL]             ++ix; [EOL]             int left = len - ix; [EOL]             if (left > 0) { [EOL]                 System.arraycopy(array, ix, result, ix, left); [EOL]             } [EOL]             return result; [EOL]         } [EOL]     } [EOL]     T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1); [EOL]     if (len > 0) { [EOL]         System.arraycopy(array, 0, result, 1, len); [EOL]     } [EOL]     result[0] = element; [EOL]     return result; [EOL] } public ArrayBuilders(); public BooleanBuilder(); public ByteBuilder(); public ShortBuilder(); public IntBuilder(); public LongBuilder(); public FloatBuilder(); public DoubleBuilder(); public ArrayIterator(T[] array); public BooleanBuilder getBooleanBuilder(); public ByteBuilder getByteBuilder(); public ShortBuilder getShortBuilder(); public IntBuilder getIntBuilder(); public LongBuilder getLongBuilder(); public FloatBuilder getFloatBuilder(); public DoubleBuilder getDoubleBuilder(); public final boolean[] _constructArray(int len); public final byte[] _constructArray(int len); public final short[] _constructArray(int len); public final int[] _constructArray(int len); public final long[] _constructArray(int len); public final float[] _constructArray(int len); public final double[] _constructArray(int len); public boolean equals(Object other); public static Object getArrayComparator(final Object defaultValue); public static HashSet<T> arrayToSet(T[] elements); public static ArrayList<T> arrayToList(T[] elements); public static HashSet<T> setAndArray(Set<T> set, T[] elements); public static List<T> addToList(List<T> list, T element); public static T[] insertInList(T[] array, T element); public static T[] insertInListNoDup(T[] array, T element); public static Iterator<T> arrayAsIterator(T[] array); public static Iterable<T> arrayAsIterable(T[] array); public boolean hasNext(); public T next(); public void remove(); public Iterator<T> iterator(); BooleanBuilder _booleanBuilder=Optional[null]; ByteBuilder _byteBuilder=Optional[null]; ShortBuilder _shortBuilder=Optional[null]; IntBuilder _intBuilder=Optional[null]; LongBuilder _longBuilder=Optional[null]; FloatBuilder _floatBuilder=Optional[null]; DoubleBuilder _doubleBuilder=Optional[null]"}
{"code": "public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals(\\\"[1,2,3,4]\\\", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }", "nl": "[LINE] if (_delegateDeserializer != null) { [LINE] protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, \\\"Can not instantiate abstract type \\\" + _beanType + \\\" (need to add/enable type information?)\\\"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, \\\"No suitable constructor found for type \\\" + _beanType + \\\": can not instantiate from JSON object (need to add/enable type information?)\\\"); [EOL] } public BeanAsArrayDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanAsArrayDeserializer withObjectIdReader(ObjectIdReader oir); public BeanAsArrayDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanDeserializerBase asArrayDeserializer(); public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; BeanDeserializerBase _delegate; SettableBeanProperty[] _orderedProperties"}
{"code": "public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\\\"abc\\\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }", "nl": "[LINE] ser = _serializer; [LINE] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] } protected StringCollectionSerializer(); protected StringCollectionSerializer(JsonSerializer<?> ser); protected JsonNode contentSchema(); protected void acceptContentVisitor(JsonArrayFormatVisitor visitor) throws JsonMappingException; public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private final void _serializeUnwrapped(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; private void serializeUsingCustom(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; StringCollectionSerializer instance=Optional[new StringCollectionSerializer()]; JsonSerializer<String> _serializer"}
{"code": "public void testSimpleBuilder() throws Exception { [EOL]     ValueClassXY value = MAPPER.readValue(\\\"[1,2]\\\", ValueClassXY.class); [EOL]     assertEquals(2, value._x); [EOL]     assertEquals(3, value._y); [EOL] }", "nl": "[LINE] prop.deserializeSetAndReturn(jp, ctxt, builder); [LINE] protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException(\\\"Unexpected JSON values; expected at most \\\" + propCount + \\\" properties (in JSON Array)\\\"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] } public BeanAsArrayBuilderDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered, AnnotatedMethod buildMethod); public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper); public BeanAsArrayBuilderDeserializer withObjectIdReader(ObjectIdReader oir); public BeanAsArrayBuilderDeserializer withIgnorableProperties(HashSet<String> ignorableProps); protected BeanAsArrayBuilderDeserializer asArrayDeserializer(); protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException; public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException; public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; BeanDeserializerBase _delegate; SettableBeanProperty[] _orderedProperties; AnnotatedMethod _buildMethod"}
{"code": "public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\\\"B\\\"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\\\"B\\\"), Alpha.class)); [EOL] }", "nl": "[LINE] return NopAnnotationIntrospector.instance; [LINE] @Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return NopAnnotationIntrospector.instance; [EOL] } public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins); private DeserializationConfig(DeserializationConfig src, SubtypeResolver str); private DeserializationConfig(DeserializationConfig src, int mapperFeatures, int deserFeatures); private DeserializationConfig(DeserializationConfig src, BaseSettings base); private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f); private DeserializationConfig(DeserializationConfig src, LinkedNode<DeserializationProblemHandler> problemHandlers); private DeserializationConfig(DeserializationConfig src, String rootName); private DeserializationConfig(DeserializationConfig src, Class<?> view); protected DeserializationConfig(DeserializationConfig src, Map<ClassKey, Class<?>> mixins); protected BaseSettings getBaseSettings(); public DeserializationConfig with(MapperFeature... features); public DeserializationConfig without(MapperFeature... features); public DeserializationConfig with(ClassIntrospector ci); public DeserializationConfig with(AnnotationIntrospector ai); public DeserializationConfig with(VisibilityChecker<?> vc); public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public DeserializationConfig with(TypeResolverBuilder<?> trb); public DeserializationConfig with(SubtypeResolver str); public DeserializationConfig with(PropertyNamingStrategy pns); public DeserializationConfig withRootName(String rootName); public DeserializationConfig with(TypeFactory tf); public DeserializationConfig with(DateFormat df); public DeserializationConfig with(HandlerInstantiator hi); public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai); public DeserializationConfig withView(Class<?> view); public DeserializationConfig with(Locale l); public DeserializationConfig with(TimeZone tz); public DeserializationConfig with(Base64Variant base64); private final DeserializationConfig _withBase(BaseSettings newBase); public DeserializationConfig with(JsonNodeFactory f); public DeserializationConfig withHandler(DeserializationProblemHandler h); public DeserializationConfig withNoProblemHandlers(); public DeserializationConfig with(DeserializationFeature feature); public DeserializationConfig with(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withFeatures(DeserializationFeature... features); public DeserializationConfig without(DeserializationFeature feature); public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features); public DeserializationConfig withoutFeatures(DeserializationFeature... features); public AnnotationIntrospector getAnnotationIntrospector(); public boolean useRootWrapping(); public BeanDescription introspectClassAnnotations(JavaType type); public BeanDescription introspectDirectClassAnnotations(JavaType type); public VisibilityChecker<?> getDefaultVisibilityChecker(); public final boolean isEnabled(DeserializationFeature f); public final int getDeserializationFeatures(); public LinkedNode<DeserializationProblemHandler> getProblemHandlers(); public final JsonNodeFactory getNodeFactory(); public T introspect(JavaType type); public T introspectForCreation(JavaType type); public T introspectForBuilder(JavaType type); long serialVersionUID=Optional[-4227480407273773599L]; int _deserFeatures; LinkedNode<DeserializationProblemHandler> _problemHandlers; JsonNodeFactory _nodeFactory"}
{"code": "public void testPropertyRemoval() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new RemovingModifier(\\\"a\\\"))); [EOL]     Bean bean = mapper.readValue(\\\"{\\\\\"b\\\\\":\\\\\"2\\\\\"}\\\", Bean.class); [EOL]     assertEquals(\\\"2\\\", bean.b); [EOL]     assertEquals(\\\"a\\\", bean.a); [EOL] }", "nl": "[LINE] public Iterable<BeanDeserializerModifier> deserializerModifiers() { [LINE] public Iterable<BeanDeserializerModifier> deserializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }]; Deserializers[] _additionalDeserializers; KeyDeserializers[] _additionalKeyDeserializers; BeanDeserializerModifier[] _modifiers; AbstractTypeResolver[] _abstractTypeResolvers; ValueInstantiators[] _valueInstantiators"}
{"code": "public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals(\\\"java.util.Calendar\\\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\\\"java.util.ArrayList<java.lang.Object>\\\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\\\"java.util.TreeMap<java.lang.Object,java.lang.Object>\\\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\\\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\\\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }", "nl": "[LINE] private JavaType _collectionType(Class<?> rawClass) [LINE] private JavaType _collectionType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Collection.class); [EOL]     if (typeParams == null) { [EOL]         return CollectionType.construct(rawClass, _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 1) { [EOL]         throw new IllegalArgumentException(\\\"Strange Collection type \\\" + rawClass.getName() + \\\": can not determine type parameters\\\"); [EOL]     } [EOL]     return CollectionType.construct(rawClass, typeParams[0]); [EOL] } private TypeFactory(); protected TypeFactory(TypeParser p, TypeModifier[] mods); public TypeFactory withModifier(TypeModifier mod); public static TypeFactory defaultInstance(); public static JavaType unknownType(); public static Class<?> rawClass(Type t); public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass); public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException; public JavaType[] findTypeParameters(JavaType type, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType); public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings); public JavaType moreSpecificType(JavaType type1, JavaType type2); public JavaType constructType(Type type); public JavaType constructType(Type type, TypeBindings bindings); public JavaType constructType(TypeReference<?> typeRef); public JavaType constructType(Type type, Class<?> context); public JavaType constructType(Type type, JavaType context); protected JavaType _constructType(Type type, TypeBindings context); public ArrayType constructArrayType(Class<?> elementType); public ArrayType constructArrayType(JavaType elementType); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass); public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass); public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType); public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType); public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass); public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType); public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass); public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes); public JavaType uncheckedSimpleType(Class<?> cls); public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses); public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes); public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass); public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass); public MapType constructRawMapType(Class<? extends Map> mapClass); public MapLikeType constructRawMapLikeType(Class<?> mapClass); protected JavaType _fromClass(Class<?> clz, TypeBindings context); protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes); protected JavaType _fromParamType(ParameterizedType type, TypeBindings context); protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context); protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context); protected JavaType _fromWildcard(WildcardType type, TypeBindings context); private JavaType _mapType(Class<?> rawClass); private JavaType _collectionType(Class<?> rawClass); protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings); protected JavaType _unknownType(); protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype); protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target); protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target); protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target); protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current); protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current); long serialVersionUID=Optional[1L]; JavaType[] NO_TYPES=Optional[new JavaType[0]]; TypeFactory instance=Optional[new TypeFactory()]; SimpleType CORE_TYPE_STRING=Optional[new SimpleType(String.class)]; SimpleType CORE_TYPE_BOOL=Optional[new SimpleType(Boolean.TYPE)]; SimpleType CORE_TYPE_INT=Optional[new SimpleType(Integer.TYPE)]; SimpleType CORE_TYPE_LONG=Optional[new SimpleType(Long.TYPE)]; LRUMap<ClassKey, JavaType> _typeCache=Optional[new LRUMap<ClassKey, JavaType>(16, 100)]; HierarchicType _cachedHashMapType; HierarchicType _cachedArrayListType; TypeModifier[] _modifiers; TypeParser _parser"}
{"code": "public void testDeepUnwrapping() throws Exception { [EOL]     DeepUnwrapping bean = mapper.readValue(\\\"{\\\\\"x\\\\\":3,\\\\\"name\\\\\":\\\\\"Bob\\\\\",\\\\\"y\\\\\":27}\\\", DeepUnwrapping.class); [EOL]     Unwrapping uw = bean.unwrapped; [EOL]     assertNotNull(uw); [EOL]     assertEquals(\\\"Bob\\\", uw.name); [EOL]     Location loc = uw.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(3, loc.x); [EOL]     assertEquals(27, loc.y); [EOL] }", "nl": "[LINE] _valueTypeDeserializer = src._valueTypeDeserializer; [LINE] protected SettableBeanProperty(SettableBeanProperty src, String newName) { [EOL]     _propName = newName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueDeserializer = src._valueDeserializer; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _nullProvider = src._nullProvider; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     _viewMatcher = src._viewMatcher; [EOL] } protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired); protected SettableBeanProperty(SettableBeanProperty src); protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser); protected SettableBeanProperty(SettableBeanProperty src, String newName); public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(String newName); public void setManagedReferenceName(String n); public void setViews(Class<?>[] views); public void assignIndex(int index); public final String getName(); public boolean isRequired(); public JavaType getType(); public PropertyName getWrapperName(); public abstract A getAnnotation(Class<A> acls); public abstract AnnotatedMember getMember(); public A getContextAnnotation(Class<A> acls); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; protected final Class<?> getDeclaringClass(); public String getManagedReferenceName(); public boolean hasValueDeserializer(); public boolean hasValueTypeDeserializer(); public JsonDeserializer<Object> getValueDeserializer(); public TypeDeserializer getValueTypeDeserializer(); public boolean visibleInView(Class<?> activeView); public boolean hasViews(); public int getPropertyIndex(); public int getCreatorIndex(); public Object getInjectableValueId(); public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void _throwAsIOE(Exception e, Object value) throws IOException; protected IOException _throwAsIOE(Exception e) throws IOException; public String toString(); long serialVersionUID=Optional[-1026580169193933453L]; JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER=Optional[new FailingDeserializer(\\\"No _valueDeserializer assigned\\\")]; String _propName; JavaType _type; PropertyName _wrapperName; Annotations _contextAnnotations; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; NullProvider _nullProvider; String _managedReferenceName; ViewMatcher _viewMatcher; int _propertyIndex=Optional[-1]; boolean _isRequired"}
{"code": "public void testImmutable() throws Exception { [EOL]     final String json = \\\"{\\\\\"value\\\\\":13}\\\"; [EOL]     ValueImmutable value = mapper.readValue(json, ValueImmutable.class); [EOL]     assertEquals(13, value.value); [EOL] }", "nl": "[LINE] public JsonDeserializer<?> buildBuilderBased(JavaType valueType, [LINE] public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException(\\\"Builder class \\\" + _beanDesc.getBeanClass().getName() + \\\" does not have build method '\\\" + expBuildMethodName + \\\"()'\\\"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException(\\\"Build method '\\\" + _buildMethod.getFullName() + \\\" has bad return type (\\\" + rawBuildType.getName() + \\\"), not compatible with POJO type (\\\" + valueType.getRawClass().getName() + \\\")\\\"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] } public BeanDeserializerBuilder(BeanDescription beanDesc, DeserializationConfig config); protected BeanDeserializerBuilder(BeanDeserializerBuilder src); private static HashMap<String, SettableBeanProperty> _copy(HashMap<String, SettableBeanProperty> src); public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride); public void addProperty(SettableBeanProperty prop); public void addBackReferenceProperty(String referenceName, SettableBeanProperty prop); public void addInjectable(String propertyName, JavaType propertyType, Annotations contextAnnotations, AnnotatedMember member, Object valueId); public void addIgnorable(String propName); public void addCreatorProperty(SettableBeanProperty prop); public void addCreatorProperty(BeanPropertyDefinition propDef); public void setAnySetter(SettableAnyProperty s); public void setIgnoreUnknownProperties(boolean ignore); public void setValueInstantiator(ValueInstantiator inst); public void setObjectIdReader(ObjectIdReader r); public void setPOJOBuilder(AnnotatedMethod buildMethod, JsonPOJOBuilder.Value config); public Iterator<SettableBeanProperty> getProperties(); public SettableBeanProperty findProperty(String propertyName); public boolean hasProperty(String propertyName); public SettableBeanProperty removeProperty(String name); public SettableAnyProperty getAnySetter(); public ValueInstantiator getValueInstantiator(); public List<ValueInjector> getInjectables(); public ObjectIdReader getObjectIdReader(); public AnnotatedMethod getBuildMethod(); public JsonPOJOBuilder.Value getBuilderConfig(); public JsonDeserializer<?> build(); public AbstractDeserializer buildAbstract(); public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName); BeanDescription _beanDesc; boolean _defaultViewInclusion; Map<String, SettableBeanProperty> _properties=Optional[new LinkedHashMap<String, SettableBeanProperty>()]; List<ValueInjector> _injectables; HashMap<String, SettableBeanProperty> _backRefProperties; HashSet<String> _ignorableProps; ValueInstantiator _valueInstantiator; ObjectIdReader _objectIdReader; SettableAnyProperty _anySetter; boolean _ignoreAllUnknown; AnnotatedMethod _buildMethod; JsonPOJOBuilder.Value _builderConfig"}
{"code": "public void testDouble() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     double value = 3.04; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isNull()); [EOL]     assertType(result, DoubleNode.class); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isDouble()); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.doubleValue()); [EOL]     assertEquals(value, result.numberValue().doubleValue()); [EOL]     assertEquals((int) value, result.intValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals(result, DoubleNode.valueOf(value)); [EOL] }", "nl": "[LINE] public double doubleValue() { return _value; } [LINE] @Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] } public DoubleNode(double v); public static DoubleNode valueOf(double v); public JsonToken asToken(); public JsonParser.NumberType numberType(); public boolean isFloatingPointNumber(); public boolean isDouble(); public boolean canConvertToInt(); public boolean canConvertToLong(); public Number numberValue(); public short shortValue(); public int intValue(); public long longValue(); public float floatValue(); public double doubleValue(); public BigDecimal decimalValue(); public BigInteger bigIntegerValue(); public String asText(); public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException; public boolean equals(Object o); public int hashCode(); double _value"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] if (value == bean) { [LINE] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] } public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue); protected BeanPropertyWriter(BeanPropertyWriter base); protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name); public BeanPropertyWriter rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper); public void setNonTrivialBaseType(JavaType t); public String getName(); public JavaType getType(); public PropertyName getWrapperName(); public boolean isRequired(); public A getAnnotation(Class<A> acls); public A getContextAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; public Object getInternalSetting(Object key); public Object setInternalSetting(Object key, Object value); public Object removeInternalSetting(Object key); public SerializedString getSerializedName(); public boolean hasSerializer(); public boolean hasNullSerializer(); public boolean willSuppressNulls(); public JsonSerializer<Object> getSerializer(); public JavaType getSerializationType(); public Class<?> getRawSerializationType(); public Class<?> getPropertyType(); public Type getGenericPropertyType(); public Class<?>[] getViews(); protected boolean isRequired(AnnotationIntrospector intr); public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException; public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; public final Object get(Object bean) throws Exception; protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException; public String toString(); Object MARKER_FOR_EMPTY=Optional[new Object()]; AnnotatedMember _member; Annotations _contextAnnotations; JavaType _declaredType; Method _accessorMethod; Field _field; HashMap<Object, Object> _internalSettings; SerializedString _name; PropertyName _wrapperName; JavaType _cfgSerializationType; JsonSerializer<Object> _serializer; JsonSerializer<Object> _nullSerializer; PropertySerializerMap _dynamicSerializers; boolean _suppressNulls; Object _suppressableValue; Class<?>[] _includeInViews; TypeSerializer _typeSerializer; JavaType _nonTrivialBaseType; boolean _isRequired"}
{"code": "public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] if (len == MAX_ENTRIES) { [LINE] @Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     int len = _entries.length; [EOL]     if (len == MAX_ENTRIES) { [EOL]         return this; [EOL]     } [EOL]     TypeAndSerializer[] entries = new TypeAndSerializer[len + 1]; [EOL]     System.arraycopy(_entries, 0, entries, 0, len); [EOL]     entries[len] = new TypeAndSerializer(type, serializer); [EOL]     return new Multi(entries); [EOL] } public SerializerAndMapResult(JsonSerializer<Object> serializer, PropertySerializerMap map); public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer); public Single(Class<?> type, JsonSerializer<Object> serializer); public Double(Class<?> type1, JsonSerializer<Object> serializer1, Class<?> type2, JsonSerializer<Object> serializer2); public Multi(TypeAndSerializer[] entries); public abstract JsonSerializer<Object> serializerFor(Class<?> type); public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException; public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public static PropertySerializerMap emptyMap(); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer); public JsonSerializer<Object> serializerFor(Class<?> type); public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)"}
{"code": "public void testBeanAsObject() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String str = m.writeValueAsString(new Object[] { new StringBean(\\\"abc\\\") }); [EOL]     _verifySerializationAsMap(str); [EOL]     Object ob = m.readValue(str, Object[].class); [EOL]     assertNotNull(ob); [EOL]     Object[] result = (Object[]) ob; [EOL]     assertNotNull(result[0]); [EOL]     assertEquals(StringBean.class, result[0].getClass()); [EOL]     assertEquals(\\\"abc\\\", ((StringBean) result[0]).name); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL]     jgen.writeStartObject(); [EOL] } public AsArrayTypeSerializer(TypeIdResolver idRes, BeanProperty property); public AsArrayTypeSerializer forProperty(BeanProperty prop); public As getTypeInclusion(); public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException; public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException; public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException; public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException; public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException; public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException; public void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException; public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException; public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException; public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException"}
{"code": "@SuppressWarnings(\\\"unchecked\\\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertEquals(\\\"2\\\", map.get(\\\"b\\\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\\\"1\\\", map.get(\\\"a\\\")); [EOL]     assertNull(map.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public T next() { [EOL]     if (_index >= _array.length) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return _array[_index++]; [EOL] } public ArrayBuilders(); public BooleanBuilder(); public ByteBuilder(); public ShortBuilder(); public IntBuilder(); public LongBuilder(); public FloatBuilder(); public DoubleBuilder(); public ArrayIterator(T[] array); public BooleanBuilder getBooleanBuilder(); public ByteBuilder getByteBuilder(); public ShortBuilder getShortBuilder(); public IntBuilder getIntBuilder(); public LongBuilder getLongBuilder(); public FloatBuilder getFloatBuilder(); public DoubleBuilder getDoubleBuilder(); public final boolean[] _constructArray(int len); public final byte[] _constructArray(int len); public final short[] _constructArray(int len); public final int[] _constructArray(int len); public final long[] _constructArray(int len); public final float[] _constructArray(int len); public final double[] _constructArray(int len); public boolean equals(Object other); public static Object getArrayComparator(final Object defaultValue); public static HashSet<T> arrayToSet(T[] elements); public static ArrayList<T> arrayToList(T[] elements); public static HashSet<T> setAndArray(Set<T> set, T[] elements); public static List<T> addToList(List<T> list, T element); public static T[] insertInList(T[] array, T element); public static T[] insertInListNoDup(T[] array, T element); public static Iterator<T> arrayAsIterator(T[] array); public static Iterable<T> arrayAsIterable(T[] array); public boolean hasNext(); public T next(); public void remove(); public Iterator<T> iterator(); BooleanBuilder _booleanBuilder=Optional[null]; ByteBuilder _byteBuilder=Optional[null]; ShortBuilder _shortBuilder=Optional[null]; IntBuilder _intBuilder=Optional[null]; LongBuilder _longBuilder=Optional[null]; FloatBuilder _floatBuilder=Optional[null]; DoubleBuilder _doubleBuilder=Optional[null]"}
{"code": "public void testSimpleClass() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType baseType = tf.constructType(BaseType.class); [EOL]     assertSame(BaseType.class, baseType.getRawClass()); [EOL]     assertTrue(baseType.hasRawClass(BaseType.class)); [EOL]     assertFalse(baseType.isArrayType()); [EOL]     assertFalse(baseType.isContainerType()); [EOL]     assertFalse(baseType.isEnumType()); [EOL]     assertFalse(baseType.isInterface()); [EOL]     assertFalse(baseType.isPrimitive()); [EOL]     assertNull(baseType.getContentType()); [EOL]     assertNull(baseType.getValueHandler()); [EOL]     assertSame(baseType, baseType.narrowBy(BaseType.class)); [EOL]     assertSame(baseType, baseType.widenBy(BaseType.class)); [EOL]     try { [EOL]         baseType.narrowBy(SubType.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \\\"should never be called\\\"); [EOL]     } [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public JavaType getContentType() { [EOL]     return null; [EOL] } protected JavaType(Class<?> raw, int additionalHash, Object valueHandler, Object typeHandler, boolean asStatic); public abstract JavaType withTypeHandler(Object h); public abstract JavaType withContentTypeHandler(Object h); public abstract JavaType withValueHandler(Object h); public abstract JavaType withContentValueHandler(Object h); public abstract JavaType withStaticTyping(); public JavaType narrowBy(Class<?> subclass); public JavaType forcedNarrowBy(Class<?> subclass); public JavaType widenBy(Class<?> superclass); protected abstract JavaType _narrow(Class<?> subclass); protected JavaType _widen(Class<?> superclass); public abstract JavaType narrowContentsBy(Class<?> contentClass); public abstract JavaType widenContentsBy(Class<?> contentClass); public final Class<?> getRawClass(); public final boolean hasRawClass(Class<?> clz); public boolean isAbstract(); public boolean isConcrete(); public boolean isThrowable(); public boolean isArrayType(); public final boolean isEnumType(); public final boolean isInterface(); public final boolean isPrimitive(); public final boolean isFinal(); public abstract boolean isContainerType(); public boolean isCollectionLikeType(); public boolean isMapLikeType(); public final boolean useStaticType(); public boolean hasGenericTypes(); public JavaType getKeyType(); public JavaType getContentType(); public int containedTypeCount(); public JavaType containedType(int index); public String containedTypeName(int index); public T getValueHandler(); public T getTypeHandler(); public String getGenericSignature(); public abstract StringBuilder getGenericSignature(StringBuilder sb); public String getErasedSignature(); public abstract StringBuilder getErasedSignature(StringBuilder sb); protected void _assertSubclass(Class<?> subclass, Class<?> superClass); public abstract String toString(); public abstract boolean equals(Object o); public final int hashCode(); long serialVersionUID=Optional[6774285981275451126L]; Class<?> _class; int _hashCode; Object _valueHandler; Object _typeHandler; boolean _asStatic"}
{"code": "public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = \\\"test\\\"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue(\\\"{\\\\\"num\\\\\": 10, \\\\\"str\\\\\":\\\\\"foobar\\\\\"}\\\"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals(\\\"foobar\\\", bean.str); [EOL] }", "nl": "[LINE] return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView); [LINE] public boolean visibleInView(Class<?> activeView) { [EOL]     return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView); [EOL] } protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired); protected SettableBeanProperty(SettableBeanProperty src); protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser); protected SettableBeanProperty(SettableBeanProperty src, String newName); public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(String newName); public void setManagedReferenceName(String n); public void setViews(Class<?>[] views); public void assignIndex(int index); public final String getName(); public boolean isRequired(); public JavaType getType(); public PropertyName getWrapperName(); public abstract A getAnnotation(Class<A> acls); public abstract AnnotatedMember getMember(); public A getContextAnnotation(Class<A> acls); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; protected final Class<?> getDeclaringClass(); public String getManagedReferenceName(); public boolean hasValueDeserializer(); public boolean hasValueTypeDeserializer(); public JsonDeserializer<Object> getValueDeserializer(); public TypeDeserializer getValueTypeDeserializer(); public boolean visibleInView(Class<?> activeView); public boolean hasViews(); public int getPropertyIndex(); public int getCreatorIndex(); public Object getInjectableValueId(); public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void _throwAsIOE(Exception e, Object value) throws IOException; protected IOException _throwAsIOE(Exception e) throws IOException; public String toString(); long serialVersionUID=Optional[-1026580169193933453L]; JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER=Optional[new FailingDeserializer(\\\"No _valueDeserializer assigned\\\")]; String _propName; JavaType _type; PropertyName _wrapperName; Annotations _contextAnnotations; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; NullProvider _nullProvider; String _managedReferenceName; ViewMatcher _viewMatcher; int _propertyIndex=Optional[-1]; boolean _isRequired"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] _isRequired = propDef.isRequired(); [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException(\\\"Can not pass member of type \\\" + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] } public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue); protected BeanPropertyWriter(BeanPropertyWriter base); protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name); public BeanPropertyWriter rename(NameTransformer transformer); public void assignSerializer(JsonSerializer<Object> ser); public void assignNullSerializer(JsonSerializer<Object> nullSer); public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper); public void setNonTrivialBaseType(JavaType t); public String getName(); public JavaType getType(); public PropertyName getWrapperName(); public boolean isRequired(); public A getAnnotation(Class<A> acls); public A getContextAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; public Object getInternalSetting(Object key); public Object setInternalSetting(Object key, Object value); public Object removeInternalSetting(Object key); public SerializedString getSerializedName(); public boolean hasSerializer(); public boolean hasNullSerializer(); public boolean willSuppressNulls(); public JsonSerializer<Object> getSerializer(); public JavaType getSerializationType(); public Class<?> getRawSerializationType(); public Class<?> getPropertyType(); public Type getGenericPropertyType(); public Class<?>[] getViews(); protected boolean isRequired(AnnotationIntrospector intr); public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException; public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception; protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException; public final Object get(Object bean) throws Exception; protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException; public String toString(); Object MARKER_FOR_EMPTY=Optional[new Object()]; AnnotatedMember _member; Annotations _contextAnnotations; JavaType _declaredType; Method _accessorMethod; Field _field; HashMap<Object, Object> _internalSettings; SerializedString _name; PropertyName _wrapperName; JavaType _cfgSerializationType; JsonSerializer<Object> _serializer; JsonSerializer<Object> _nullSerializer; PropertySerializerMap _dynamicSerializers; boolean _suppressNulls; Object _suppressableValue; Class<?>[] _includeInViews; TypeSerializer _typeSerializer; JavaType _nonTrivialBaseType; boolean _isRequired"}
{"code": "public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] return null; [LINE] public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] } private EnumTypeLocator(); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore); public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result); private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself); public static String canBeABeanType(Class<?> type); public static String isLocalType(Class<?> type, boolean allowNonStatic); public static Class<?> getOuterClass(Class<?> type); public static boolean isProxyType(Class<?> type); public static boolean isConcrete(Class<?> type); public static boolean isConcrete(Member member); public static boolean isCollectionMapOrArray(Class<?> type); public static String getClassDescription(Object classOrInstance); public static Class<?> findClass(String className) throws ClassNotFoundException; public static boolean hasGetterSignature(Method m); public static Throwable getRootCause(Throwable t); public static void throwRootCause(Throwable t) throws Exception; public static void throwAsIAE(Throwable t); public static void throwAsIAE(Throwable t, String msg); public static void unwrapAndThrowAsIAE(Throwable t); public static void unwrapAndThrowAsIAE(Throwable t, String msg); public static T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException; public static Object defaultValue(Class<?> cls); public static Class<?> wrapperType(Class<?> primitiveType); public static void checkAndFixAccess(Member member); public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s); public static Class<? extends Enum<?>> findEnumType(EnumMap<?, ?> m); public static Class<? extends Enum<?>> findEnumType(Enum<?> en); public static Class<? extends Enum<?>> findEnumType(Class<?> cls); public static boolean isJacksonStdImpl(Object impl); public static boolean isJacksonStdImpl(Class<?> implClass); public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set); public Class<? extends Enum<?>> enumTypeFor(EnumMap<?, ?> set); private Object get(Object bean, Field field); private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] final SerializationConfig config = prov.getConfig(); [LINE] protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] } protected BeanSerializerFactory(SerializerFactoryConfig config); public SerializerFactory withConfig(SerializerFactoryConfig config); protected Iterable<Serializers> customSerializers(); public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException; protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; public final JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public final TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor, BeanProperty property) throws JsonMappingException; public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException; protected final JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc, BeanProperty property) throws JsonMappingException; protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException; protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException; protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews); protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc); protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc); protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc); protected boolean isPotentialBeanType(Class<?> type); protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props); protected void processViews(SerializationConfig config, BeanSerializerBuilder builder); protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties); protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException; long serialVersionUID=Optional[1]; BeanSerializerFactory instance=Optional[new BeanSerializerFactory(null)]"}
{"code": "public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\\\"abc\\\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\\\"abc\\\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }", "nl": "[LINE] _propName = InternCache.instance.intern(propName); [LINE] protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = \\\"\\\"; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] } protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations); protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired); protected SettableBeanProperty(SettableBeanProperty src); protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser); protected SettableBeanProperty(SettableBeanProperty src, String newName); public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser); public abstract SettableBeanProperty withName(String newName); public void setManagedReferenceName(String n); public void setViews(Class<?>[] views); public void assignIndex(int index); public final String getName(); public boolean isRequired(); public JavaType getType(); public PropertyName getWrapperName(); public abstract A getAnnotation(Class<A> acls); public abstract AnnotatedMember getMember(); public A getContextAnnotation(Class<A> acls); public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) throws JsonMappingException; protected final Class<?> getDeclaringClass(); public String getManagedReferenceName(); public boolean hasValueDeserializer(); public boolean hasValueTypeDeserializer(); public JsonDeserializer<Object> getValueDeserializer(); public TypeDeserializer getValueTypeDeserializer(); public boolean visibleInView(Class<?> activeView); public boolean hasViews(); public int getPropertyIndex(); public int getCreatorIndex(); public Object getInjectableValueId(); public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public abstract void set(Object instance, Object value) throws IOException; public abstract Object setAndReturn(Object instance, Object value) throws IOException; public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected void _throwAsIOE(Exception e, Object value) throws IOException; protected IOException _throwAsIOE(Exception e) throws IOException; public String toString(); long serialVersionUID=Optional[-1026580169193933453L]; JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER=Optional[new FailingDeserializer(\\\"No _valueDeserializer assigned\\\")]; String _propName; JavaType _type; PropertyName _wrapperName; Annotations _contextAnnotations; JsonDeserializer<Object> _valueDeserializer; TypeDeserializer _valueTypeDeserializer; NullProvider _nullProvider; String _managedReferenceName; ViewMatcher _viewMatcher; int _propertyIndex=Optional[-1]; boolean _isRequired"}
{"code": "public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public ArrayType withTypeHandler(Object h) { [EOL]     if (h == _typeHandler) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic); [EOL] } private ArrayType(JavaType componentType, Object emptyInstance, Object valueHandler, Object typeHandler, boolean asStatic); public static ArrayType construct(JavaType componentType, Object valueHandler, Object typeHandler); public ArrayType withTypeHandler(Object h); public ArrayType withContentTypeHandler(Object h); public ArrayType withValueHandler(Object h); public ArrayType withContentValueHandler(Object h); public ArrayType withStaticTyping(); protected String buildCanonicalName(); protected JavaType _narrow(Class<?> subclass); public JavaType narrowContentsBy(Class<?> contentClass); public JavaType widenContentsBy(Class<?> contentClass); public boolean isArrayType(); public boolean isAbstract(); public boolean isConcrete(); public boolean hasGenericTypes(); public String containedTypeName(int index); public boolean isContainerType(); public JavaType getContentType(); public int containedTypeCount(); public JavaType containedType(int index); public StringBuilder getGenericSignature(StringBuilder sb); public StringBuilder getErasedSignature(StringBuilder sb); public String toString(); public boolean equals(Object o); long serialVersionUID=Optional[9040058063449087477L]; JavaType _componentType; Object _emptyArray"}
{"code": "public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\\\"\\\\\"value1\\\\\"\\\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\\\"value1\\\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return \\\"\\\"; [EOL]     } [EOL]     return null; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\\\"c3VyZS4=\\\", byte[].class); [EOL]     byte[] exp = \\\"sure.\\\".getBytes(\\\"Ascii\\\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }", "nl": "[LINE] final DeserializationConfig config = ctxt.getConfig(); [LINE] @Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }", "nl": "[LINE] writeString(new String(text, offset, len)); [LINE] @Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     writeString(new String(text, offset, len)); [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
{"code": "public void testIssue831() throws Exception { [EOL]     final String JSON = \\\"{ \\\\\"petType\\\\\": \\\\\"dog\\\\\",\\n\\\" + \\\"\\\\\"pet\\\\\": { \\\\\"name\\\\\": \\\\\"Pluto\\\\\" }\\n}\\\"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals(\\\"dog\\\", result.petType); [EOL] }", "nl": "[LINE] String typeId = jp.getText(); [LINE] public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] } protected ExternalTypeHandler(ExtTypedProperty[] properties, HashMap<String, Integer> nameToPropertyIndex, String[] typeIds, TokenBuffer[] tokens); protected ExternalTypeHandler(ExternalTypeHandler h); public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser); public ExternalTypeHandler start(); public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException; public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException; public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException; public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException; protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, int index, String typeId) throws IOException, JsonProcessingException; protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException, JsonProcessingException; public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser); public ExternalTypeHandler build(); public boolean hasTypePropertyName(String n); public boolean hasDefaultType(); public String getDefaultTypeId(); public String getTypePropertyName(); public SettableBeanProperty getProperty(); ExtTypedProperty[] _properties; HashMap<String, Integer> _nameToPropertyIndex; String[] _typeIds; TokenBuffer[] _tokens"}
{"code": "public void testCustomMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator())); [EOL]     MyMap result = mapper.readValue(\\\"{ \\\\\"a\\\\\":\\\\\"b\\\\\" }\\\", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(MyMap.class, result.getClass()); [EOL]     assertEquals(1, result.size()); [EOL] }", "nl": "[LINE] if (instantiators == null) { [LINE] public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators) { [EOL]     if (instantiators == null) { [EOL]         throw new IllegalArgumentException(\\\"Can not pass null resolver\\\"); [EOL]     } [EOL]     ValueInstantiators[] all = ArrayBuilders.insertInListNoDup(_valueInstantiators, instantiators); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, _modifiers, _abstractTypeResolvers, all); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }]; Deserializers[] _additionalDeserializers; KeyDeserializers[] _additionalKeyDeserializers; BeanDeserializerModifier[] _modifiers; AbstractTypeResolver[] _abstractTypeResolvers; ValueInstantiators[] _valueInstantiators"}
{"code": "public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue(\\\"{\\\\\"a\\\\\":true }\\\", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals(\\\"a\\\", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }", "nl": "[LINE] try { [LINE] private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, \\\"findContentDeserializer\\\", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] } public DeserializerCache();  Object writeReplace(); public int cachedDeserializersCount(); public void flushCachedDeserializers(); public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException; public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type); protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type); protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException; protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException; protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException; private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException; private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type) throws JsonMappingException; protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type) throws JsonMappingException; long serialVersionUID=Optional[1L]; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2)]; HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers=Optional[new HashMap<JavaType, JsonDeserializer<Object>>(8)]"}
{"code": "public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":\\\\\"a\\\\\",\\\\\"b\\\\\":\\\\\"b\\\\\"}\\\", mapper.writeValueAsString(bean)); [EOL] }", "nl": "[LINE] return builder; [LINE] public BeanSerializerBuilder updateBuilder(SerializationConfig config, BeanDescription beanDesc, BeanSerializerBuilder builder) { [EOL]     return builder; [EOL] } public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties); public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties); public BeanSerializerBuilder updateBuilder(SerializationConfig config, BeanDescription beanDesc, BeanSerializerBuilder builder); public JsonSerializer<?> modifySerializer(SerializationConfig config, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyArraySerializer(SerializationConfig config, ArrayType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyCollectionSerializer(SerializationConfig config, CollectionType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyCollectionLikeSerializer(SerializationConfig config, CollectionLikeType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyMapSerializer(SerializationConfig config, MapType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyMapLikeSerializer(SerializationConfig config, MapLikeType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyEnumSerializer(SerializationConfig config, JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer); public JsonSerializer<?> modifyKeySerializer(SerializationConfig config, JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer)"}
{"code": "public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\\\"B\\\"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\\\"B\\\"), Alpha.class)); [EOL] }", "nl": "[LINE] return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [LINE] protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] } private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations); public AnnotatedClass withAnnotations(AnnotationMap ann); public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir); public Class<?> getAnnotated(); public int getModifiers(); public String getName(); public A getAnnotation(Class<A> acls); public Type getGenericType(); public Class<?> getRawType(); protected AnnotationMap getAllAnnotations(); public Annotations getAnnotations(); public boolean hasAnnotations(); public AnnotatedConstructor getDefaultConstructor(); public List<AnnotatedConstructor> getConstructors(); public List<AnnotatedMethod> getStaticMethods(); public Iterable<AnnotatedMethod> memberMethods(); public int getMemberMethodCount(); public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes); public int getFieldCount(); public Iterable<AnnotatedField> fields(); private void resolveClassAnnotations(); private void resolveCreators(); private void resolveMemberMethods(); private void resolveFields(); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask); protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin); protected void _addConstructorMixIns(Class<?> mixin); protected void _addFactoryMixIns(Class<?> mixin); protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns); protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields); protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields); protected AnnotatedMethod _constructMethod(Method m); protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor); protected AnnotatedMethod _constructCreatorMethod(Method m); protected AnnotatedField _constructField(Field f); private AnnotationMap _emptyAnnotationMap(); private AnnotationMap[] _emptyAnnotationMaps(int count); protected boolean _isIncludableMemberMethod(Method m); private boolean _isIncludableField(Field f); protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns); protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns); private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns); private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns); protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations); protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations); protected void _addMixUnders(Method src, AnnotatedMethod target); private final boolean _isAnnotationBundle(Annotation ann); public String toString(); AnnotationMap[] NO_ANNOTATION_MAPS=Optional[new AnnotationMap[0]]; Class<?> _class; List<Class<?>> _superTypes; AnnotationIntrospector _annotationIntrospector; MixInResolver _mixInResolver; Class<?> _primaryMixIn; AnnotationMap _classAnnotations; boolean _creatorsResolved=Optional[false]; AnnotatedConstructor _defaultConstructor; List<AnnotatedConstructor> _constructors; List<AnnotatedMethod> _creatorMethods; AnnotatedMethodMap _memberMethods; List<AnnotatedField> _fields"}
{"code": "public void testJackson703() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class)); [EOL]     assertNotNull(beanDesc); [EOL]     Jackson703 bean = new Jackson703(); [EOL]     String json = mapper.writeValueAsString(bean); [EOL]     assertNotNull(json); [EOL] }", "nl": "[LINE] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [LINE] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     return null; [EOL] } public ReferenceProperty(Type t, String n); public Pair(AnnotationIntrospector p, AnnotationIntrospector s); public static ReferenceProperty managed(String name); public static ReferenceProperty back(String name); public Type getType(); public String getName(); public boolean isManagedReference(); public boolean isBackReference(); public static AnnotationIntrospector nopInstance(); public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2); public Collection<AnnotationIntrospector> allIntrospectors(); public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result); public abstract Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Class<?>[] findViews(Annotated a); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated memberOrClass); public Boolean isTypeId(AnnotatedMember member); public PropertyName findWrapperName(Annotated ann); public Object findSerializer(Annotated am); public Object findKeySerializer(Annotated am); public Object findContentSerializer(Annotated am); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated a); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedMethod am); public String findSerializationName(AnnotatedField af); public boolean hasAsValueAnnotation(AnnotatedMethod am); public String findEnumValue(Enum<?> value); public Object findDeserializer(Annotated am); public Object findKeyDeserializer(Annotated am); public Object findContentDeserializer(Annotated am); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a)"}
{"code": "public void testSimpleUUIDForClassRoundTrip() throws Exception { [EOL]     UUIDNode root = new UUIDNode(1); [EOL]     UUIDNode child1 = new UUIDNode(2); [EOL]     UUIDNode child2 = new UUIDNode(3); [EOL]     root.first = child1; [EOL]     root.second = child2; [EOL]     child1.parent = root; [EOL]     child2.parent = root; [EOL]     child1.first = child2; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     UUIDNode result = mapper.readValue(json, UUIDNode.class); [EOL]     assertEquals(1, result.value); [EOL]     UUIDNode result2 = result.first; [EOL]     UUIDNode result3 = result.second; [EOL]     assertNotNull(result2); [EOL]     assertNotNull(result3); [EOL]     assertEquals(2, result2.value); [EOL]     assertEquals(3, result3.value); [EOL]     assertSame(result, result2.parent); [EOL]     assertSame(result, result3.parent); [EOL]     assertSame(result3, result2.first); [EOL] }", "nl": "[LINE] SettableBeanProperty idProp = _objectIdReader.idProperty; [LINE] @Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     Object id = _valueDeserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     roid.bindItem(instance); [EOL]     SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]     if (idProp != null) { [EOL]         return idProp.setAndReturn(instance, id); [EOL]     } [EOL]     return instance; [EOL] } public ObjectIdValueProperty(ObjectIdReader objectIdReader); public ObjectIdValueProperty(ObjectIdReader objectIdReader, boolean isRequired); protected ObjectIdValueProperty(ObjectIdValueProperty src, JsonDeserializer<?> deser); protected ObjectIdValueProperty(ObjectIdValueProperty src, String newName); public ObjectIdValueProperty withName(String newName); public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser); public A getAnnotation(Class<A> acls); public AnnotatedMember getMember(); public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException; public void set(Object instance, Object value) throws IOException; public Object setAndReturn(Object instance, Object value) throws IOException; long serialVersionUID=Optional[1L]; ObjectIdReader _objectIdReader"}
{"code": "public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode(\\\"   APs=\\n\\\"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode(\\\"?!??\\\"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"Illegal character\\\"); [EOL]     } [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]         _nodeCursor = null; [EOL]         _currToken = null; [EOL]     } [EOL] } public TreeTraversingParser(JsonNode n); public TreeTraversingParser(JsonNode n, ObjectCodec codec); public void setCodec(ObjectCodec c); public ObjectCodec getCodec(); public Version version(); public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; public boolean isClosed(); public String getCurrentName(); public void overrideCurrentName(String name); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getText(); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public boolean hasTextCharacters(); public NumberType getNumberType() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected JsonNode currentNode(); protected JsonNode currentNumericNode() throws JsonParseException; protected void _handleEOF() throws JsonParseException; ObjectCodec _objectCodec; NodeCursor _nodeCursor; JsonToken _nextToken; boolean _startContainer; boolean _closed"}
{"code": "public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\\\"{\\\\\"bar\\\\\":3}\\\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\\\"Should have failed binding\\\"); [EOL]     } [EOL]     assertEquals(\\\"bar\\\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \\\"propX\\\"); [EOL] }", "nl": "[LINE] sb.append(']'); [LINE] @Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     Class<?> cls = (_from instanceof Class<?>) ? ((Class<?>) _from) : _from.getClass(); [EOL]     Package pkg = cls.getPackage(); [EOL]     if (pkg != null) { [EOL]         sb.append(pkg.getName()); [EOL]         sb.append('.'); [EOL]     } [EOL]     sb.append(cls.getSimpleName()); [EOL]     sb.append('['); [EOL]     if (_fieldName != null) { [EOL]         sb.append('\\\"'); [EOL]         sb.append(_fieldName); [EOL]         sb.append('\\\"'); [EOL]     } else if (_index >= 0) { [EOL]         sb.append(_index); [EOL]     } else { [EOL]         sb.append('?'); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] } protected Reference(); public Reference(Object from); public Reference(Object from, String fieldName); public Reference(Object from, int index); public JsonMappingException(String msg); public JsonMappingException(String msg, Throwable rootCause); public JsonMappingException(String msg, JsonLocation loc); public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause); public void setFrom(Object o); public void setFieldName(String n); public void setIndex(int ix); public Object getFrom(); public String getFieldName(); public int getIndex(); public String toString(); public static JsonMappingException from(JsonParser jp, String msg); public static JsonMappingException from(JsonParser jp, String msg, Throwable problem); public static JsonMappingException fromUnexpectedIOE(IOException src); public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName); public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index); public static JsonMappingException wrapWithPath(Throwable src, Reference ref); public List<Reference> getPath(); public String getPathReference(); public StringBuilder getPathReference(StringBuilder sb); public void prependPath(Object referrer, String fieldName); public void prependPath(Object referrer, int index); public void prependPath(Reference r); public String getLocalizedMessage(); public String getMessage(); protected String _buildMessage(); public String toString(); protected void _appendPathDesc(StringBuilder sb); long serialVersionUID=Optional[1L]; int MAX_REFS_TO_LIST=Optional[1000]; LinkedList<Reference> _path"}
{"code": "public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, \\\"   17\\\"); [EOL]     map.put(AB.B, \\\" -1\\\"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(\\\" -1\\\", bean.B); [EOL] }", "nl": "[LINE] if (property != null) { [LINE] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] } public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums, TypeSerializer vts, JsonSerializer<Object> valueSerializer); public EnumMapSerializer(EnumMapSerializer src, BeanProperty property, JsonSerializer<?> ser); public EnumMapSerializer _withValueTypeSerializer(TypeSerializer vts); public EnumMapSerializer withValueSerializer(BeanProperty prop, JsonSerializer<?> ser); public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException; public JavaType getContentType(); public JsonSerializer<?> getContentSerializer(); public boolean isEmpty(EnumMap<? extends Enum<?>, ?> value); public boolean hasSingleElement(EnumMap<? extends Enum<?>, ?> value); public void serialize(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; public void serializeWithType(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException; protected void serializeContents(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException; protected void serializeContentsUsing(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> valueSer) throws IOException, JsonGenerationException; public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException; public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException; boolean _staticTyping; BeanProperty _property; EnumValues _keyEnums; JavaType _valueType; JsonSerializer<Object> _valueSerializer; TypeSerializer _valueTypeSerializer"}
{"code": "public void testIntArray() throws Exception { [EOL]     assertEquals(\\\"[0,-3]\\\", serializeAsString(MAPPER, new int[] { 0, -3 })); [EOL]     assertEquals(\\\"[13,9]\\\", serializeAsString(MAPPER, new Integer[] { 13, 9 })); [EOL] }", "nl": "[LINE] return (_typeParameters == null) ? 0 : _typeParameters.length; [LINE] @Override [EOL] public int containedTypeCount() { [EOL]     return (_typeParameters == null) ? 0 : _typeParameters.length; [EOL] } protected SimpleType(Class<?> cls); protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic); public static SimpleType constructUnsafe(Class<?> raw); protected JavaType _narrow(Class<?> subclass); public JavaType narrowContentsBy(Class<?> subclass); public JavaType widenContentsBy(Class<?> subclass); public static SimpleType construct(Class<?> cls); public SimpleType withTypeHandler(Object h); public JavaType withContentTypeHandler(Object h); public SimpleType withValueHandler(Object h); public SimpleType withContentValueHandler(Object h); public SimpleType withStaticTyping(); protected String buildCanonicalName(); public boolean isContainerType(); public int containedTypeCount(); public JavaType containedType(int index); public String containedTypeName(int index); public StringBuilder getErasedSignature(StringBuilder sb); public StringBuilder getGenericSignature(StringBuilder sb); public String toString(); public boolean equals(Object o); long serialVersionUID=Optional[-800374828948534376L]; JavaType[] _typeParameters; String[] _typeNames"}
{"code": "public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \\\"{\\\\\"id\\\\\": 5, \\\\\"defaultValue\\\\\": { \\\\\"value\\\\\": \\\\\"123\\\\\" } }\\\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\\\"should have raised exception instead value was set to \\\" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"not numeric\\\"); [EOL]     } [EOL] }", "nl": "[LINE] if (!(deserDef instanceof Class)) { [LINE] @SuppressWarnings(\\\"unchecked\\\") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\\\"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<JsonDeserializer>\\\"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] } protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory); public Impl(DeserializerFactory df); protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values); protected Impl(Impl src, DeserializerFactory factory); public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator); public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException; public abstract DefaultDeserializationContext with(DeserializerFactory factory); public abstract DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values); public DefaultDeserializationContext with(DeserializerFactory factory); long serialVersionUID=Optional[1L]; LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds"}
{"code": "public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23.789Z\\\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T19:51:23Z\\\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\\\"2007-08-13T21:51:23.789+02:00\\\"); [EOL]     assertEquals(date, d); [EOL] }", "nl": "[LINE] int day = parseInt(date, offset += 1, offset += 2); [LINE] public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException(\\\"Invalid time zone indicator \\\" + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException(\\\"Failed to parse date \\\" + date, e); [EOL]     } [EOL] } public static TimeZone timeZoneGMT(); public static String format(Date date); public static String format(Date date, boolean millis); public static String format(Date date, boolean millis, TimeZone tz); public static Date parse(String date); private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException; private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException; private static void padInt(StringBuilder buffer, int value, int length); String GMT_ID=Optional[\\\"GMT\\\"]; TimeZone TIMEZONE_GMT=Optional[TimeZone.getTimeZone(GMT_ID)]"}
{"code": "public void testIterator() throws IOException { [EOL]     StringWriter sw = new StringWriter(); [EOL]     ArrayList<Integer> l = new ArrayList<Integer>(); [EOL]     l.add(1); [EOL]     l.add(-9); [EOL]     l.add(0); [EOL]     MAPPER.writeValue(sw, l.iterator()); [EOL]     assertEquals(\\\"[1,-9,0]\\\", sw.toString().trim()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] } public IteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property); public IteratorSerializer(IteratorSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer); public boolean isEmpty(Iterator<?> value); public boolean hasSingleElement(Iterator<?> value); public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts); public IteratorSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer); public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException"}
{"code": "public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject(\\\"inner\\\").put(\\\"value\\\", \\\"test\\\"); [EOL]     n.putObject(\\\"unknown\\\").putNull(\\\"inner\\\"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals(\\\"test\\\", obj.inner.value); [EOL] }", "nl": "[LINE] return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType)); [LINE] @Override [EOL] @SuppressWarnings(\\\"unchecked\\\") [EOL] public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType)); [EOL] } public DefaultTypeResolverBuilder(DefaultTyping t); public ObjectMapper(); public ObjectMapper(JsonFactory jf); protected ObjectMapper(ObjectMapper src); public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc); public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes); public boolean useForType(JavaType t); public ObjectMapper copy(); protected void _checkInvalidCopy(Class<?> exp); public Version version(); public Version getMapperVersion(); public C getOwner(); public TypeFactory getTypeFactory(); public boolean isEnabled(MapperFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public void addDeserializers(Deserializers d); public void addKeyDeserializers(KeyDeserializers d); public void addBeanDeserializerModifier(BeanDeserializerModifier modifier); public void addSerializers(Serializers s); public void addKeySerializers(Serializers s); public void addBeanSerializerModifier(BeanSerializerModifier modifier); public void addAbstractTypeResolver(AbstractTypeResolver resolver); public void addTypeModifier(TypeModifier modifier); public void addValueInstantiators(ValueInstantiators instantiators); public void setClassIntrospector(ClassIntrospector ci); public void insertAnnotationIntrospector(AnnotationIntrospector ai); public void appendAnnotationIntrospector(AnnotationIntrospector ai); public void registerSubtypes(Class<?>... subtypes); public void registerSubtypes(NamedType... subtypes); public void setMixInAnnotations(Class<?> target, Class<?> mixinSource); public void addDeserializationProblemHandler(DeserializationProblemHandler handler); public ObjectMapper registerModule(Module module); public ObjectMapper registerModules(Module... modules); public ObjectMapper registerModules(Iterable<Module> modules); public static List<Module> findModules(); public static List<Module> findModules(ClassLoader classLoader); public ObjectMapper findAndRegisterModules(); public SerializationConfig getSerializationConfig(); public DeserializationConfig getDeserializationConfig(); public DeserializationContext getDeserializationContext(); public ObjectMapper setSerializerFactory(SerializerFactory f); public SerializerFactory getSerializerFactory(); public ObjectMapper setSerializerProvider(DefaultSerializerProvider p); public SerializerProvider getSerializerProvider(); public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins); public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource); public final Class<?> findMixInClassFor(Class<?> cls); public final int mixInCount(); public VisibilityChecker<?> getVisibilityChecker(); public void setVisibilityChecker(VisibilityChecker<?> vc); public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility); public SubtypeResolver getSubtypeResolver(); public ObjectMapper setSubtypeResolver(SubtypeResolver str); public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai); public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI); public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s); public ObjectMapper setSerializationInclusion(JsonInclude.Include incl); public ObjectMapper enableDefaultTyping(); public ObjectMapper enableDefaultTyping(DefaultTyping dti); public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs); public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName); public ObjectMapper disableDefaultTyping(); public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer); public void registerSubtypes(Class<?>... classes); public void registerSubtypes(NamedType... types); public TypeFactory getTypeFactory(); public ObjectMapper setTypeFactory(TypeFactory f); public JavaType constructType(Type t); public ObjectMapper setNodeFactory(JsonNodeFactory f); public ObjectMapper addHandler(DeserializationProblemHandler h); public ObjectMapper clearProblemHandlers(); public void setFilters(FilterProvider filterProvider); public ObjectMapper setBase64Variant(Base64Variant v); public JsonFactory getFactory(); public JsonFactory getJsonFactory(); public ObjectMapper setDateFormat(DateFormat dateFormat); public Object setHandlerInstantiator(HandlerInstantiator hi); public ObjectMapper setInjectableValues(InjectableValues injectableValues); public ObjectMapper setLocale(Locale l); public ObjectMapper setTimeZone(TimeZone tz); public ObjectMapper configure(MapperFeature f, boolean state); public ObjectMapper configure(SerializationFeature f, boolean state); public ObjectMapper configure(DeserializationFeature f, boolean state); public ObjectMapper configure(JsonParser.Feature f, boolean state); public ObjectMapper configure(JsonGenerator.Feature f, boolean state); public ObjectMapper enable(MapperFeature... f); public ObjectMapper disable(MapperFeature... f); public ObjectMapper enable(DeserializationFeature feature); public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper disable(DeserializationFeature feature); public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f); public ObjectMapper enable(SerializationFeature f); public ObjectMapper enable(SerializationFeature first, SerializationFeature... f); public ObjectMapper disable(SerializationFeature f); public ObjectMapper disable(SerializationFeature first, SerializationFeature... f); public boolean isEnabled(MapperFeature f); public boolean isEnabled(SerializationFeature f); public boolean isEnabled(DeserializationFeature f); public boolean isEnabled(JsonFactory.Feature f); public boolean isEnabled(JsonParser.Feature f); public boolean isEnabled(JsonGenerator.Feature f); public JsonNodeFactory getNodeFactory(); public T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public final T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readTree(JsonParser jp) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException; public MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException; public JsonNode readTree(Reader r) throws IOException, JsonProcessingException; public JsonNode readTree(String content) throws IOException, JsonProcessingException; public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException; public JsonNode readTree(File file) throws IOException, JsonProcessingException; public JsonNode readTree(URL source) throws IOException, JsonProcessingException; public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException; public ObjectNode createObjectNode(); public ArrayNode createArrayNode(); public JsonParser treeAsTokens(TreeNode n); public T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException; public T valueToTree(Object fromValue) throws IllegalArgumentException; public boolean canSerialize(Class<?> type); public boolean canDeserialize(JavaType type); public T readValue(File src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException; public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException; public String writeValueAsString(Object value) throws JsonProcessingException; public byte[] writeValueAsBytes(Object value) throws JsonProcessingException; public ObjectWriter writer(); public ObjectWriter writer(SerializationFeature feature); public ObjectWriter writer(SerializationFeature first, SerializationFeature... other); public ObjectWriter writer(DateFormat df); public ObjectWriter writerWithView(Class<?> serializationView); public ObjectWriter writerWithType(Class<?> rootType); public ObjectWriter writerWithType(TypeReference<?> rootType); public ObjectWriter writerWithType(JavaType rootType); public ObjectWriter writer(PrettyPrinter pp); public ObjectWriter writerWithDefaultPrettyPrinter(); public ObjectWriter writer(FilterProvider filterProvider); public ObjectWriter writer(FormatSchema schema); public ObjectWriter writer(Base64Variant defaultBase64); public ObjectReader reader(); public ObjectReader reader(DeserializationFeature feature); public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other); public ObjectReader readerForUpdating(Object valueToUpdate); public ObjectReader reader(JavaType type); public ObjectReader reader(Class<?> type); public ObjectReader reader(TypeReference<?> type); public ObjectReader reader(JsonNodeFactory f); public ObjectReader reader(FormatSchema schema); public ObjectReader reader(InjectableValues injectableValues); public ObjectReader readerWithView(Class<?> view); public ObjectReader reader(Base64Variant defaultBase64); public T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException; public T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException; public T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException; protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException; public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException; public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException; protected DefaultSerializerProvider _serializerProvider(SerializationConfig config); protected PrettyPrinter _defaultPrettyPrinter(); protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException; protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass) throws IOException, JsonGenerationException, JsonMappingException; private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException; protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg); protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException; protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException; protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException; protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException; protected void _verifySchemaType(FormatSchema schema); long serialVersionUID=Optional[1L]; JavaType JSON_NODE_TYPE=Optional[SimpleType.constructUnsafe(JsonNode.class)]; ClassIntrospector DEFAULT_INTROSPECTOR=Optional[BasicClassIntrospector.instance]; AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR=Optional[new JacksonAnnotationIntrospector()]; VisibilityChecker<?> STD_VISIBILITY_CHECKER=Optional[VisibilityChecker.Std.defaultInstance()]; PrettyPrinter _defaultPrettyPrinter=Optional[new DefaultPrettyPrinter()]; BaseSettings DEFAULT_BASE=Optional[new BaseSettings(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(), null, StdDateFormat.instance, null, Locale.getDefault(), // TimeZone.getDefault(); TimeZone.getTimeZone(\\\"GMT\\\"), // 2.1; Base64Variants.getDefaultVariant())]; JsonFactory _jsonFactory; TypeFactory _typeFactory; InjectableValues _injectableValues; SubtypeResolver _subtypeResolver; RootNameLookup _rootNames; HashMap<ClassKey, Class<?>> _mixInAnnotations=Optional[new HashMap<ClassKey, Class<?>>()]; SerializationConfig _serializationConfig; DefaultSerializerProvider _serializerProvider; SerializerFactory _serializerFactory; DeserializationConfig _deserializationConfig; DefaultDeserializationContext _deserializationContext; ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers=Optional[new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2)]"}
{"code": "public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, \\\"Unrecognized field \\\\\"foo\\\\\"\\\"); [EOL]     } [EOL] }", "nl": "[LINE] if (len == 1) { [LINE] @Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(\\\" (one known property: \\\\\"\\\"); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('\\\"'); [EOL]         } else { [EOL]             sb.append(\\\" (\\\").append(len).append(\\\" known properties: \\\"); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(\\\", \\\\\"\\\"); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('\\\"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(\\\" [truncated]\\\"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append(\\\"])\\\"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] } public UnrecognizedPropertyException(String msg, JsonLocation loc, Class<?> referringClass, String propName, Collection<Object> propertyIds); public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName, Collection<Object> propertyIds); public String getMessageSuffix(); public Class<?> getReferringClass(); public String getUnrecognizedPropertyName(); public Collection<Object> getKnownPropertyIds(); long serialVersionUID=Optional[1L]; Class<?> _referringClass; String _unrecognizedPropertyName; Collection<Object> _propertyIds; String _propertiesAsString; int MAX_DESC_LENGTH=Optional[200]"}
{"code": "public void testIntPrimitive() throws Exception { [EOL]     IntBean result = MAPPER.readValue(new StringReader(\\\"{\\\\\"v\\\\\":3}\\\"), IntBean.class); [EOL]     assertEquals(3, result._v); [EOL]     result = MAPPER.readValue(new StringReader(\\\"{\\\\\"v\\\\\":null}\\\"), IntBean.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(0, result._v); [EOL]     int[] array = MAPPER.readValue(new StringReader(\\\"[ null ]\\\"), int[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(0, array[0]); [EOL] }", "nl": "[LINE] return 0; [LINE] protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, \\\"Overflow: numeric value (\\\" + text + \\\") out of range of int (\\\" + Integer.MIN_VALUE + \\\" - \\\" + Integer.MAX_VALUE + \\\")\\\"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, \\\"not a valid int value\\\"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } protected StdDeserializer(Class<?> vc); protected StdDeserializer(JavaType valueType); public Class<?> getValueClass(); public JavaType getValueType(); protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer); protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser); public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException; protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected static final double parseDouble(String numStr) throws NumberFormatException; protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException; protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException; protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]; Class<?> _valueClass"}
{"code": "public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = \\\"mouse\\\"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = \\\"mickey\\\"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }", "nl": "[LINE] if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [LINE] @Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromArray(jp, ctxt); [EOL]     } [EOL]     return deserializeTypedFromObject(jp, ctxt); [EOL] } public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl); public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property); public TypeDeserializer forProperty(BeanProperty prop); public As getTypeInclusion(); public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException; protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException; public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException; long serialVersionUID=Optional[1L]"}
{"code": "public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\\\"{\\\\\"enumA\\\\\":\\\\\"value\\\\\"}\\\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\\\"value\\\", value.get(EnumWithCreator.A)); [EOL] }", "nl": "[LINE] return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [LINE] private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException(\\\"Parameter #0 type for factory method (\\\" + factory + \\\") not suitable, must be java.lang.String\\\"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException(\\\"Unsuitable method (\\\" + factory + \\\") decorated with @JsonCreator (for Enum type \\\" + enumClass.getName() + \\\")\\\"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] } protected BasicDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactoryConfig getFactoryConfig(); protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); public final DeserializerFactory withAdditionalDeserializers(Deserializers additional); public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional); public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier); public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver); public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators); public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException; private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException; public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException; public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException; protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException; protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException; protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException; protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException; public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException; protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config); protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException; public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException; public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException; public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException; public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException; public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException; protected T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException; protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException; protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod); protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType); Class<?> CLASS_OBJECT=Optional[Object.class]; Class<?> CLASS_STRING=Optional[String.class]; Class<?> CLASS_CHAR_BUFFER=Optional[CharSequence.class]; Class<?> CLASS_ITERABLE=Optional[Iterable.class]; HashMap<String, Class<? extends Map>> _mapFallbacks=Optional[new HashMap<String, Class<? extends Map>>()]; HashMap<String, Class<? extends Collection>> _collectionFallbacks=Optional[new HashMap<String, Class<? extends Collection>>()]; DeserializerFactoryConfig _factoryConfig"}
{"code": "public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals(\\\"a\\\", props.get(0).getName()); [EOL]     assertEquals(\\\"b\\\", props.get(1).getName()); [EOL]     assertEquals(\\\"c\\\", props.get(2).getName()); [EOL]     assertEquals(\\\"d\\\", props.get(3).getName()); [EOL] }", "nl": "[LINE] sort = alpha.booleanValue(); [LINE] protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] } protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix); public MapperConfig<?> getConfig(); public JavaType getType(); public AnnotatedClass getClassDef(); public AnnotationIntrospector getAnnotationIntrospector(); public List<BeanPropertyDefinition> getProperties(); public Map<Object, AnnotatedMember> getInjectables(); public AnnotatedMethod getJsonValueMethod(); public AnnotatedMember getAnyGetter(); public AnnotatedMethod getAnySetterMethod(); public Set<String> getIgnoredPropertyNames(); public ObjectIdInfo getObjectIdInfo(); public Class<?> findPOJOBuilderClass(); protected Map<String, POJOPropertyBuilder> getPropertyMap(); public POJOPropertiesCollector collect(); protected void _sortProperties(); protected void _addFields(); protected void _addCreators(); protected void _addMethods(); protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai); protected void _addInjectables(); protected void _doAddInjectable(Object id, AnnotatedMember m); protected void _removeUnwantedProperties(); private void _addIgnored(String name); protected void _renameProperties(); protected void _renameUsing(PropertyNamingStrategy naming); protected void _renameWithWrappers(); protected void reportProblem(String msg); protected POJOPropertyBuilder _property(String implName); private PropertyNamingStrategy _findNamingStrategy(); MapperConfig<?> _config; boolean _forSerialization; JavaType _type; AnnotatedClass _classDef; VisibilityChecker<?> _visibilityChecker; AnnotationIntrospector _annotationIntrospector; String _mutatorPrefix; LinkedHashMap<String, POJOPropertyBuilder> _properties=Optional[new LinkedHashMap<String, POJOPropertyBuilder>()]; LinkedList<POJOPropertyBuilder> _creatorProperties=Optional[null]; LinkedList<AnnotatedMember> _anyGetters=Optional[null]; LinkedList<AnnotatedMethod> _anySetters=Optional[null]; LinkedList<AnnotatedMethod> _jsonValueGetters=Optional[null]; HashSet<String> _ignoredPropertyNames; LinkedHashMap<Object, AnnotatedMember> _injectables"}
{"code": "public void testNonNullByClass() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new NoNullsBean()); [EOL]     assertEquals(1, result.size()); [EOL]     assertFalse(result.containsKey(\\\"a\\\")); [EOL]     assertNull(result.get(\\\"a\\\")); [EOL]     assertTrue(result.containsKey(\\\"b\\\")); [EOL]     assertNull(result.get(\\\"b\\\")); [EOL] }", "nl": "[LINE] return JsonInclude.Include.NON_NULL; [LINE] @Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings(\\\"deprecation\\\") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] } public JacksonAnnotationIntrospector(); public Version version(); public boolean isHandled(Annotation ann); public boolean isAnnotationBundle(Annotation ann); public PropertyName findRootName(AnnotatedClass ac); public String[] findPropertiesToIgnore(Annotated ac); public Boolean findIgnoreUnknownProperties(AnnotatedClass ac); public Boolean isIgnorableType(AnnotatedClass ac); public Object findFilterId(AnnotatedClass ac); public Object findNamingStrategy(AnnotatedClass ac); public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker); public ReferenceProperty findReferenceType(AnnotatedMember member); public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member); public boolean hasIgnoreMarker(AnnotatedMember m); public Boolean hasRequiredMarker(AnnotatedMember m); public Object findInjectableValueId(AnnotatedMember m); public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType); public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType); public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType); public List<NamedType> findSubtypes(Annotated a); public String findTypeName(AnnotatedClass ac); public Object findSerializer(Annotated a); public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a); public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a); public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue); public Class<?> findSerializationType(Annotated am); public Class<?> findSerializationKeyType(Annotated am, JavaType baseType); public Class<?> findSerializationContentType(Annotated am, JavaType baseType); public JsonSerialize.Typing findSerializationTyping(Annotated a); public Object findSerializationConverter(Annotated a); public Object findSerializationContentConverter(AnnotatedMember a); public Class<?>[] findViews(Annotated a); public Boolean isTypeId(AnnotatedMember member); public ObjectIdInfo findObjectIdInfo(Annotated ann); public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo); public JsonFormat.Value findFormat(AnnotatedMember member); public JsonFormat.Value findFormat(Annotated annotated); public String[] findSerializationPropertyOrder(AnnotatedClass ac); public Boolean findSerializationSortAlphabetically(AnnotatedClass ac); public PropertyName findNameForSerialization(Annotated a); public String findSerializationName(AnnotatedField af); public String findSerializationName(AnnotatedMethod am); public boolean hasAsValueAnnotation(AnnotatedMethod am); public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a); public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a); public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a); public Class<?> findDeserializationType(Annotated am, JavaType baseType); public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType); public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType); public Object findDeserializationConverter(Annotated a); public Object findDeserializationContentConverter(AnnotatedMember a); public Object findValueInstantiator(AnnotatedClass ac); public Class<?> findPOJOBuilder(AnnotatedClass ac); public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac); public PropertyName findNameForDeserialization(Annotated a); public String findDeserializationName(AnnotatedMethod am); public String findDeserializationName(AnnotatedField af); public String findDeserializationName(AnnotatedParameter param); public boolean hasAnySetterAnnotation(AnnotatedMethod am); public boolean hasAnyGetterAnnotation(AnnotatedMethod am); public boolean hasCreatorAnnotation(Annotated a); protected boolean _isIgnorable(Annotated a); protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType); protected StdTypeResolverBuilder _constructStdTypeResolverBuilder(); protected StdTypeResolverBuilder _constructNoTypeResolverBuilder(); long serialVersionUID=Optional[1L]"}
{"code": "public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\\\"\\\\\"foo\\\\\"\\\", json); [EOL] }", "nl": "[LINE] if (Number.class.isAssignableFrom(raw)) { [LINE] protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] } protected BasicSerializerFactory(SerializerFactoryConfig config); public SerializerFactoryConfig getFactoryConfig(); public abstract SerializerFactory withConfig(SerializerFactoryConfig config); public final SerializerFactory withAdditionalSerializers(Serializers additional); public final SerializerFactory withAdditionalKeySerializers(Serializers additional); public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier); public abstract JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType type) throws JsonMappingException; public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl); public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType); public final JsonSerializer<?> getNullSerializer(); protected abstract Iterable<Serializers> customSerializers(); protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping); protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException; protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected final JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected boolean isIndexedList(Class<?> cls); protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException; protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException; protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type); protected static T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type); protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException; protected final boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property); protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer); protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass); HashMap<String, JsonSerializer<?>> _concrete=Optional[new HashMap<String, JsonSerializer<?>>()]; HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy=Optional[new HashMap<String, Class<? extends JsonSerializer<?>>>()]; SerializerFactoryConfig _factoryConfig"}
{"code": "public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }", "nl": "[LINE] return _currentObject(); [LINE] @Override [EOL] public Object getEmbeddedObject() { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return _currentObject(); [EOL]     } [EOL]     return null; [EOL] } public TokenBuffer(ObjectCodec codec); public Parser(Segment firstSeg, ObjectCodec codec); public Segment(); public Version version(); public JsonParser asParser(); public JsonParser asParser(ObjectCodec codec); public JsonParser asParser(JsonParser src); public JsonToken firstToken(); public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException; public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException; public String toString(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public boolean isEnabled(Feature f); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; public final void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeNumber(short i) throws IOException, JsonGenerationException; public void writeNumber(int i) throws IOException, JsonGenerationException; public void writeNumber(long l) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength); public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected final void _append(JsonToken type); protected final void _append(JsonToken type, Object value); protected final void _appendRaw(int rawType, Object value); protected void _reportUnsupportedOperation(); public void setLocation(JsonLocation l); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public Version version(); public JsonToken peekNextToken() throws IOException, JsonParseException; public void close() throws IOException; public JsonToken nextToken() throws IOException, JsonParseException; public boolean isClosed(); public JsonStreamContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public String getCurrentName(); public void overrideCurrentName(String name); public String getText(); public char[] getTextCharacters(); public int getTextLength(); public int getTextOffset(); public boolean hasTextCharacters(); public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public final Number getNumberValue() throws IOException, JsonParseException; public Object getEmbeddedObject(); public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected final Object _currentObject(); protected final void _checkIsNumber() throws JsonParseException; protected void _handleEOF() throws JsonParseException; public JsonToken type(int index); public int rawType(int index); public Object get(int index); public Segment next(); public Segment append(int index, JsonToken tokenType); public Segment append(int index, JsonToken tokenType, Object value); public Segment appendRaw(int index, int rawTokenType, Object value); public void set(int index, JsonToken tokenType); public void set(int index, JsonToken tokenType, Object value); private void set(int index, int rawTokenType, Object value); int DEFAULT_PARSER_FEATURES=Optional[JsonParser.Feature.collectDefaults()]; ObjectCodec _objectCodec; int _generatorFeatures; boolean _closed; Segment _first; Segment _last; int _appendOffset; JsonWriteContext _writeContext"}
