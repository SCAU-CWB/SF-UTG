{"code": "public void testArArchiveCreation() throws Exception { [EOL]     final File output = new File(dir, \\\"bla.ar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final File file2 = getFile(\\\"test2.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"ar\\\", out); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test1.xml\\\", file1.length())); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test2.xml\\\", file2.length())); [EOL]     IOUtils.copy(new FileInputStream(file2), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL] }", "nl": "[LINE] if (prevEntry.getLength() != entryOffset) { [LINE] public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException { [EOL]     ArArchiveEntry pArEntry = (ArArchiveEntry) pEntry; [EOL]     if (prevEntry == null) { [EOL]         archiveOffset += writeArchiveHeader(); [EOL]     } else { [EOL]         if (prevEntry.getLength() != entryOffset) { [EOL]             throw new IOException(\\\"length does not match entry (\\\" + prevEntry.getLength() + \\\" != \\\" + entryOffset); [EOL]         } [EOL]         closeArchiveEntry(); [EOL]     } [EOL]     prevEntry = pArEntry; [EOL]     archiveOffset += writeEntryHeader(pArEntry); [EOL]     entryOffset = 0; [EOL] } public ArArchiveOutputStream(final OutputStream pOut); private long writeArchiveHeader() throws IOException; public void closeArchiveEntry() throws IOException; public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException; private long fill(final long pOffset, final long pNewOffset, final char pFill) throws IOException; private long write(final String data) throws IOException; private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException; public void write(int b) throws IOException; public void write(byte[] b, int off, int len) throws IOException; public void write(byte[] b) throws IOException; public void close() throws IOException; OutputStream out; long archiveOffset=Optional[0]; long entryOffset=Optional[0]; ArArchiveEntry prevEntry"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] last++; [LINE] private void writeRun() throws IOException { [EOL]     if (last < allowableBlockSize) { [EOL]         inUse[currentChar] = true; [EOL]         for (int i = 0; i < runLength; i++) { [EOL]             mCrc.updateCRC((char) currentChar); [EOL]         } [EOL]         switch(runLength) { [EOL]             case 1: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 2: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 3: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             default: [EOL]                 inUse[runLength - 4] = true; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) (runLength - 4); [EOL]                 break; [EOL]         } [EOL]     } else { [EOL]         endBlock(); [EOL]         initBlock(); [EOL]         writeRun(); [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] zptr[j] = v; [LINE] private void simpleSort(int lo, int hi, int d) { [EOL]     int i, j, h, bigN, hp; [EOL]     int v; [EOL]     bigN = hi - lo + 1; [EOL]     if (bigN < 2) { [EOL]         return; [EOL]     } [EOL]     hp = 0; [EOL]     while (incs[hp] < bigN) { [EOL]         hp++; [EOL]     } [EOL]     hp--; [EOL]     for (; hp >= 0; hp--) { [EOL]         h = incs[hp]; [EOL]         i = lo + h; [EOL]         while (true) { [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (workDone > workLimit && firstAttempt) { [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] while (curr < len[t][i]) { [LINE] private void sendMTFValues() throws IOException { [EOL]     char[][] len = new char[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int v, t, i, j, gs, ge, totc, bt, bc, iter; [EOL]     int nSelectors = 0, alphaSize, minLen, maxLen, selCtr; [EOL]     int nGroups; [EOL]     alphaSize = nInUse + 2; [EOL]     for (t = 0; t < N_GROUPS; t++) { [EOL]         for (v = 0; v < alphaSize; v++) { [EOL]             len[t][v] = (char) GREATER_ICOST; [EOL]         } [EOL]     } [EOL]     if (nMTF <= 0) { [EOL]         panic(); [EOL]     } [EOL]     if (nMTF < 200) { [EOL]         nGroups = 2; [EOL]     } else if (nMTF < 600) { [EOL]         nGroups = 3; [EOL]     } else if (nMTF < 1200) { [EOL]         nGroups = 4; [EOL]     } else if (nMTF < 2400) { [EOL]         nGroups = 5; [EOL]     } else { [EOL]         nGroups = 6; [EOL]     } [EOL]     { [EOL]         int nPart, remF, tFreq, aFreq; [EOL]         nPart = nGroups; [EOL]         remF = nMTF; [EOL]         gs = 0; [EOL]         while (nPart > 0) { [EOL]             tFreq = remF / nPart; [EOL]             ge = gs - 1; [EOL]             aFreq = 0; [EOL]             while (aFreq < tFreq && ge < alphaSize - 1) { [EOL]                 ge++; [EOL]                 aFreq += mtfFreq[ge]; [EOL]             } [EOL]             if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 != 0)) { [EOL]                 aFreq -= mtfFreq[ge]; [EOL]                 ge--; [EOL]             } [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 if (v >= gs && v <= ge) { [EOL]                     len[nPart - 1][v] = (char) LESSER_ICOST; [EOL]                 } else { [EOL]                     len[nPart - 1][v] = (char) GREATER_ICOST; [EOL]                 } [EOL]             } [EOL]             nPart--; [EOL]             gs = ge + 1; [EOL]             remF -= aFreq; [EOL]         } [EOL]     } [EOL]     int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int[] fave = new int[N_GROUPS]; [EOL]     short[] cost = new short[N_GROUPS]; [EOL]     for (iter = 0; iter < N_ITERS; iter++) { [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             fave[t] = 0; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 rfreq[t][v] = 0; [EOL]             } [EOL]         } [EOL]         nSelectors = 0; [EOL]         totc = 0; [EOL]         gs = 0; [EOL]         while (true) { [EOL]             if (gs >= nMTF) { [EOL]                 break; [EOL]             } [EOL]             ge = gs + G_SIZE - 1; [EOL]             if (ge >= nMTF) { [EOL]                 ge = nMTF - 1; [EOL]             } [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 cost[t] = 0; [EOL]             } [EOL]             if (nGroups == 6) { [EOL]                 short cost0, cost1, cost2, cost3, cost4, cost5; [EOL]                 cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0; [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     cost0 += len[0][icv]; [EOL]                     cost1 += len[1][icv]; [EOL]                     cost2 += len[2][icv]; [EOL]                     cost3 += len[3][icv]; [EOL]                     cost4 += len[4][icv]; [EOL]                     cost5 += len[5][icv]; [EOL]                 } [EOL]                 cost[0] = cost0; [EOL]                 cost[1] = cost1; [EOL]                 cost[2] = cost2; [EOL]                 cost[3] = cost3; [EOL]                 cost[4] = cost4; [EOL]                 cost[5] = cost5; [EOL]             } else { [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     for (t = 0; t < nGroups; t++) { [EOL]                         cost[t] += len[t][icv]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             bc = 999999999; [EOL]             bt = -1; [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 if (cost[t] < bc) { [EOL]                     bc = cost[t]; [EOL]                     bt = t; [EOL]                 } [EOL]             } [EOL]             totc += bc; [EOL]             fave[bt]++; [EOL]             selector[nSelectors] = (char) bt; [EOL]             nSelectors++; [EOL]             for (i = gs; i <= ge; i++) { [EOL]                 rfreq[bt][szptr[i]]++; [EOL]             } [EOL]             gs = ge + 1; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20); [EOL]         } [EOL]     } [EOL]     rfreq = null; [EOL]     fave = null; [EOL]     cost = null; [EOL]     if (!(nGroups < 8)) { [EOL]         panic(); [EOL]     } [EOL]     if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) { [EOL]         panic(); [EOL]     } [EOL]     { [EOL]         char[] pos = new char[N_GROUPS]; [EOL]         char ll_i, tmp2, tmp; [EOL]         for (i = 0; i < nGroups; i++) { [EOL]             pos[i] = (char) i; [EOL]         } [EOL]         for (i = 0; i < nSelectors; i++) { [EOL]             ll_i = selector[i]; [EOL]             j = 0; [EOL]             tmp = pos[j]; [EOL]             while (ll_i != tmp) { [EOL]                 j++; [EOL]                 tmp2 = tmp; [EOL]                 tmp = pos[j]; [EOL]                 pos[j] = tmp2; [EOL]             } [EOL]             pos[0] = tmp; [EOL]             selectorMtf[i] = (char) j; [EOL]         } [EOL]     } [EOL]     int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         minLen = 32; [EOL]         maxLen = 0; [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             if (len[t][i] > maxLen) { [EOL]                 maxLen = len[t][i]; [EOL]             } [EOL]             if (len[t][i] < minLen) { [EOL]                 minLen = len[t][i]; [EOL]             } [EOL]         } [EOL]         if (maxLen > 20) { [EOL]             panic(); [EOL]         } [EOL]         if (minLen < 1) { [EOL]             panic(); [EOL]         } [EOL]         hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize); [EOL]     } [EOL]     { [EOL]         boolean[] inUse16 = new boolean[16]; [EOL]         for (i = 0; i < 16; i++) { [EOL]             inUse16[i] = false; [EOL]             for (j = 0; j < 16; j++) { [EOL]                 if (inUse[i * 16 + j]) { [EOL]                     inUse16[i] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 bsW(1, 1); [EOL]             } else { [EOL]                 bsW(1, 0); [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 for (j = 0; j < 16; j++) { [EOL]                     if (inUse[i * 16 + j]) { [EOL]                         bsW(1, 1); [EOL]                     } else { [EOL]                         bsW(1, 0); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     bsW(3, nGroups); [EOL]     bsW(15, nSelectors); [EOL]     for (i = 0; i < nSelectors; i++) { [EOL]         for (j = 0; j < selectorMtf[i]; j++) { [EOL]             bsW(1, 1); [EOL]         } [EOL]         bsW(1, 0); [EOL]     } [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         int curr = len[t][0]; [EOL]         bsW(5, curr); [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             while (curr < len[t][i]) { [EOL]                 bsW(2, 2); [EOL]                 curr++; [EOL]             } [EOL]             while (curr > len[t][i]) { [EOL]                 bsW(2, 3); [EOL]                 curr--; [EOL]             } [EOL]             bsW(1, 0); [EOL]         } [EOL]     } [EOL]     selCtr = 0; [EOL]     gs = 0; [EOL]     while (true) { [EOL]         if (gs >= nMTF) { [EOL]             break; [EOL]         } [EOL]         ge = gs + G_SIZE - 1; [EOL]         if (ge >= nMTF) { [EOL]             ge = nMTF - 1; [EOL]         } [EOL]         for (i = gs; i <= ge; i++) { [EOL]             bsW(len[selector[selCtr]][szptr[i]], code[selector[selCtr]][szptr[i]]); [EOL]         } [EOL]         gs = ge + 1; [EOL]         selCtr++; [EOL]     } [EOL]     if (!(selCtr == nSelectors)) { [EOL]         panic(); [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testFileSystemRoot() { [EOL]     TarArchiveEntry t = new TarArchiveEntry(new File(ROOT)); [EOL]     assertEquals(\\\"/\\\", t.getName()); [EOL] }", "nl": "[LINE] String osname = System.getProperty(\\\"os.name\\\").toLowerCase(Locale.US); [LINE] private static String normalizeFileName(String fileName) { [EOL]     String osname = System.getProperty(\\\"os.name\\\").toLowerCase(Locale.US); [EOL]     if (osname != null) { [EOL]         if (osname.startsWith(\\\"windows\\\")) { [EOL]             if (fileName.length() > 2) { [EOL]                 char ch1 = fileName.charAt(0); [EOL]                 char ch2 = fileName.charAt(1); [EOL]                 if (ch2 == ':' && ((ch1 >= 'a' && ch1 <= 'z') || (ch1 >= 'A' && ch1 <= 'Z'))) { [EOL]                     fileName = fileName.substring(2); [EOL]                 } [EOL]             } [EOL]         } else if (osname.indexOf(\\\"netware\\\") > -1) { [EOL]             int colon = fileName.indexOf(':'); [EOL]             if (colon != -1) { [EOL]                 fileName = fileName.substring(colon + 1); [EOL]             } [EOL]         } [EOL]     } [EOL]     fileName = fileName.replace(File.separatorChar, '/'); [EOL]     while (fileName.startsWith(\\\"/\\\")) { [EOL]         fileName = fileName.substring(1); [EOL]     } [EOL]     return fileName; [EOL] } private TarArchiveEntry(); public TarArchiveEntry(String name); public TarArchiveEntry(String name, byte linkFlag); public TarArchiveEntry(File file); public TarArchiveEntry(byte[] headerBuf); public boolean equals(TarArchiveEntry it); public boolean equals(Object it); public int hashCode(); public boolean isDescendent(TarArchiveEntry desc); public String getName(); public void setName(String name); public void setMode(int mode); public String getLinkName(); public int getUserId(); public void setUserId(int userId); public int getGroupId(); public void setGroupId(int groupId); public String getUserName(); public void setUserName(String userName); public String getGroupName(); public void setGroupName(String groupName); public void setIds(int userId, int groupId); public void setNames(String userName, String groupName); public void setModTime(long time); public void setModTime(Date time); public Date getModTime(); public File getFile(); public int getMode(); public long getSize(); public void setSize(long size); public boolean isGNULongNameEntry(); public boolean isDirectory(); public TarArchiveEntry[] getDirectoryEntries(); public void writeEntryHeader(byte[] outbuf); public void parseTarHeader(byte[] header); private static String normalizeFileName(String fileName); StringBuffer name; int mode; int userId; int groupId; long size; long modTime; byte linkFlag; StringBuffer linkName; StringBuffer magic; StringBuffer userName; StringBuffer groupName; int devMajor; int devMinor; File file; int MAX_NAMELEN=Optional[31]; int DEFAULT_DIR_MODE=Optional[040755]; int DEFAULT_FILE_MODE=Optional[0100644]; int MILLIS_PER_SECOND=Optional[1000]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] if (s1 != s2) { [LINE] private boolean fullGtU(int i1, int i2) { [EOL]     int k; [EOL]     char c1, c2; [EOL]     int s1, s2; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     k = last + 1; [EOL]     do { [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         if (i1 > last) { [EOL]             i1 -= last; [EOL]             i1--; [EOL]         } [EOL]         if (i2 > last) { [EOL]             i2 -= last; [EOL]             i2--; [EOL]         } [EOL]         k -= 4; [EOL]         workDone++; [EOL]     } while (k >= 0); [EOL]     return false; [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)]; [LINE] private void allocateCompressStructures() { [EOL]     int n = baseBlockSize * blockSize100k; [EOL]     block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)]; [EOL]     quadrant = new int[(n + NUM_OVERSHOOT_BYTES)]; [EOL]     zptr = new int[n]; [EOL]     ftab = new int[65537]; [EOL]     if (block == null || quadrant == null || zptr == null || ftab == null) { [EOL]     } [EOL]     szptr = new short[2 * n]; [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] int temp = (globalCrc >> 24) ^ inCh; [LINE] void updateCRC(int inCh) { [EOL]     int temp = (globalCrc >> 24) ^ inCh; [EOL]     if (temp < 0) { [EOL]         temp = 256 + temp; [EOL]     } [EOL]     globalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp]; [EOL] }  CRC();  void initialiseCRC();  int getFinalCRC();  int getGlobalCRC();  void setGlobalCRC(int newCrc);  void updateCRC(int inCh);  void updateCRC(int inCh, int repeat); int[] crc32Table=Optional[{ 0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba, 0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec, 0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4 }]; int globalCrc"}
{"code": "public void testTarFileWithFSRoot() throws IOException { [EOL]     File f = File.createTempFile(\\\"taetest\\\", \\\".tar\\\"); [EOL]     f.deleteOnExit(); [EOL]     TarArchiveOutputStream tout = null; [EOL]     TarArchiveInputStream tin = null; [EOL]     try { [EOL]         tout = new TarArchiveOutputStream(new FileOutputStream(f)); [EOL]         TarArchiveEntry t = new TarArchiveEntry(new File(ROOT)); [EOL]         tout.putNextEntry(t); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"foo.txt\\\")); [EOL]         t.setSize(6); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'h', 'e', 'l', 'l', 'o', ' ' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"bar.txt\\\").getAbsolutePath()); [EOL]         t.setSize(5); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'w', 'o', 'r', 'l', 'd' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(\\\"dummy\\\"); [EOL]         t.setName(new File(new File(ROOT), \\\"baz.txt\\\").getAbsolutePath()); [EOL]         t.setSize(1); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { '!' }); [EOL]         tout.closeEntry(); [EOL]         tout.close(); [EOL]         tout = null; [EOL]         tin = new TarArchiveInputStream(new FileInputStream(f)); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"/\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"foo.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"bar.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"baz.txt\\\", t.getName()); [EOL]     } finally { [EOL]         if (tin != null) { [EOL]             tin.close(); [EOL]         } [EOL]         if (tout != null) { [EOL]             tout.close(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] size = TarUtils.parseOctal(header, offset, SIZELEN); [LINE] public void parseTarHeader(byte[] header) { [EOL]     int offset = 0; [EOL]     name = TarUtils.parseName(header, offset, NAMELEN); [EOL]     offset += NAMELEN; [EOL]     mode = (int) TarUtils.parseOctal(header, offset, MODELEN); [EOL]     offset += MODELEN; [EOL]     userId = (int) TarUtils.parseOctal(header, offset, UIDLEN); [EOL]     offset += UIDLEN; [EOL]     groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN); [EOL]     offset += GIDLEN; [EOL]     size = TarUtils.parseOctal(header, offset, SIZELEN); [EOL]     offset += SIZELEN; [EOL]     modTime = TarUtils.parseOctal(header, offset, MODTIMELEN); [EOL]     offset += MODTIMELEN; [EOL]     offset += CHKSUMLEN; [EOL]     linkFlag = header[offset++]; [EOL]     linkName = TarUtils.parseName(header, offset, NAMELEN); [EOL]     offset += NAMELEN; [EOL]     magic = TarUtils.parseName(header, offset, MAGICLEN); [EOL]     offset += MAGICLEN; [EOL]     userName = TarUtils.parseName(header, offset, UNAMELEN); [EOL]     offset += UNAMELEN; [EOL]     groupName = TarUtils.parseName(header, offset, GNAMELEN); [EOL]     offset += GNAMELEN; [EOL]     devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN); [EOL]     offset += DEVLEN; [EOL]     devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN); [EOL] } private TarArchiveEntry(); public TarArchiveEntry(String name); public TarArchiveEntry(String name, byte linkFlag); public TarArchiveEntry(File file); public TarArchiveEntry(byte[] headerBuf); public boolean equals(TarArchiveEntry it); public boolean equals(Object it); public int hashCode(); public boolean isDescendent(TarArchiveEntry desc); public String getName(); public void setName(String name); public void setMode(int mode); public String getLinkName(); public int getUserId(); public void setUserId(int userId); public int getGroupId(); public void setGroupId(int groupId); public String getUserName(); public void setUserName(String userName); public String getGroupName(); public void setGroupName(String groupName); public void setIds(int userId, int groupId); public void setNames(String userName, String groupName); public void setModTime(long time); public void setModTime(Date time); public Date getModTime(); public File getFile(); public int getMode(); public long getSize(); public void setSize(long size); public boolean isGNULongNameEntry(); public boolean isDirectory(); public TarArchiveEntry[] getDirectoryEntries(); public void writeEntryHeader(byte[] outbuf); public void parseTarHeader(byte[] header); private static String normalizeFileName(String fileName); StringBuffer name; int mode; int userId; int groupId; long size; long modTime; byte linkFlag; StringBuffer linkName; StringBuffer magic; StringBuffer userName; StringBuffer groupName; int devMajor; int devMinor; File file; int MAX_NAMELEN=Optional[31]; int DEFAULT_DIR_MODE=Optional[040755]; int DEFAULT_FILE_MODE=Optional[0100644]; int MILLIS_PER_SECOND=Optional[1000]"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] this.charset = charset; [LINE] public NioZipEncoding(Charset charset) { [EOL]     this.charset = charset; [EOL] } public NioZipEncoding(Charset charset); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; Charset charset"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] this.bsBuff = bsBuffShadow; [LINE] private int bsR(final int n) throws IOException { [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     if (bsLiveShadow < n) { [EOL]         final InputStream inShadow = this.in; [EOL]         do { [EOL]             int thech = inShadow.read(); [EOL]             if (thech < 0) { [EOL]                 throw new IOException(\\\"unexpected end of stream\\\"); [EOL]             } [EOL]             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]             bsLiveShadow += 8; [EOL]         } while (bsLiveShadow < n); [EOL]         this.bsBuff = bsBuffShadow; [EOL]     } [EOL]     this.bsLive = bsLiveShadow - n; [EOL]     return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] int zn = minLens_zt; [LINE] private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] void initialiseCRC() { [LINE] void initialiseCRC() { [EOL]     globalCrc = 0xffffffff; [EOL] }  CRC();  void initialiseCRC();  int getFinalCRC();  int getGlobalCRC();  void setGlobalCRC(int newCrc);  void updateCRC(int inCh);  void updateCRC(int inCh, int repeat); int[] crc32Table=Optional[{ 0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba, 0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec, 0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4 }]; int globalCrc"}
{"code": "public void testTarFileWithFSRoot() throws IOException { [EOL]     File f = File.createTempFile(\\\"taetest\\\", \\\".tar\\\"); [EOL]     f.deleteOnExit(); [EOL]     TarArchiveOutputStream tout = null; [EOL]     TarArchiveInputStream tin = null; [EOL]     try { [EOL]         tout = new TarArchiveOutputStream(new FileOutputStream(f)); [EOL]         TarArchiveEntry t = new TarArchiveEntry(new File(ROOT)); [EOL]         tout.putNextEntry(t); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"foo.txt\\\")); [EOL]         t.setSize(6); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'h', 'e', 'l', 'l', 'o', ' ' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"bar.txt\\\").getAbsolutePath()); [EOL]         t.setSize(5); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'w', 'o', 'r', 'l', 'd' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(\\\"dummy\\\"); [EOL]         t.setName(new File(new File(ROOT), \\\"baz.txt\\\").getAbsolutePath()); [EOL]         t.setSize(1); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { '!' }); [EOL]         tout.closeEntry(); [EOL]         tout.close(); [EOL]         tout = null; [EOL]         tin = new TarArchiveInputStream(new FileInputStream(f)); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"/\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"foo.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"bar.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"baz.txt\\\", t.getName()); [EOL]     } finally { [EOL]         if (tin != null) { [EOL]             tin.close(); [EOL]         } [EOL]         if (tout != null) { [EOL]             tout.close(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] return size; [LINE] public long getSize() { [EOL]     return size; [EOL] } private TarArchiveEntry(); public TarArchiveEntry(String name); public TarArchiveEntry(String name, byte linkFlag); public TarArchiveEntry(File file); public TarArchiveEntry(byte[] headerBuf); public boolean equals(TarArchiveEntry it); public boolean equals(Object it); public int hashCode(); public boolean isDescendent(TarArchiveEntry desc); public String getName(); public void setName(String name); public void setMode(int mode); public String getLinkName(); public int getUserId(); public void setUserId(int userId); public int getGroupId(); public void setGroupId(int groupId); public String getUserName(); public void setUserName(String userName); public String getGroupName(); public void setGroupName(String groupName); public void setIds(int userId, int groupId); public void setNames(String userName, String groupName); public void setModTime(long time); public void setModTime(Date time); public Date getModTime(); public File getFile(); public int getMode(); public long getSize(); public void setSize(long size); public boolean isGNULongNameEntry(); public boolean isDirectory(); public TarArchiveEntry[] getDirectoryEntries(); public void writeEntryHeader(byte[] outbuf); public void parseTarHeader(byte[] header); private static String normalizeFileName(String fileName); StringBuffer name; int mode; int userId; int groupId; long size; long modTime; byte linkFlag; StringBuffer linkName; StringBuffer magic; StringBuffer userName; StringBuffer groupName; int devMajor; int devMinor; File file; int MAX_NAMELEN=Optional[31]; int DEFAULT_DIR_MODE=Optional[040755]; int DEFAULT_FILE_MODE=Optional[0100644]; int MILLIS_PER_SECOND=Optional[1000]"}
{"code": "public void testReparse() throws Exception { [EOL]     byte[] data = { (byte) 0xC6, 0x02, 0x78, (byte) 0xB6, 0123, (byte) 0x80, 0, 0, 0, 0, 5, 0, 6, 0 }; [EOL]     AsiExtraField a = new AsiExtraField(); [EOL]     a.parseFromLocalFileData(data, 0, data.length); [EOL]     assertEquals(\\\"length plain file\\\", data.length, a.getLocalFileDataLength().getValue()); [EOL]     assertTrue(\\\"plain file, no link\\\", !a.isLink()); [EOL]     assertTrue(\\\"plain file, no dir\\\", !a.isDirectory()); [EOL]     assertEquals(\\\"mode plain file\\\", FILE_FLAG | 0123, a.getMode()); [EOL]     assertEquals(\\\"uid plain file\\\", 5, a.getUserId()); [EOL]     assertEquals(\\\"gid plain file\\\", 6, a.getGroupId()); [EOL]     data = new byte[] { 0x75, (byte) 0x8E, 0x41, (byte) 0xFD, 0123, (byte) 0xA0, 4, 0, 0, 0, 5, 0, 6, 0, (byte) 't', (byte) 'e', (byte) 's', (byte) 't' }; [EOL]     a = new AsiExtraField(); [EOL]     a.parseFromLocalFileData(data, 0, data.length); [EOL]     assertEquals(\\\"length link\\\", data.length, a.getLocalFileDataLength().getValue()); [EOL]     assertTrue(\\\"link, is link\\\", a.isLink()); [EOL]     assertTrue(\\\"link, no dir\\\", !a.isDirectory()); [EOL]     assertEquals(\\\"mode link\\\", LINK_FLAG | 0123, a.getMode()); [EOL]     assertEquals(\\\"uid link\\\", 5, a.getUserId()); [EOL]     assertEquals(\\\"gid link\\\", 6, a.getGroupId()); [EOL]     assertEquals(\\\"test\\\", a.getLinkedFile()); [EOL]     data = new byte[] { (byte) 0x8E, 0x01, (byte) 0xBF, (byte) 0x0E, 0123, (byte) 0x40, 0, 0, 0, 0, 5, 0, 6, 0 }; [EOL]     a = new AsiExtraField(); [EOL]     a.parseFromLocalFileData(data, 0, data.length); [EOL]     assertEquals(\\\"length dir\\\", data.length, a.getLocalFileDataLength().getValue()); [EOL]     assertTrue(\\\"dir, no link\\\", !a.isLink()); [EOL]     assertTrue(\\\"dir, is dir\\\", a.isDirectory()); [EOL]     assertEquals(\\\"mode dir\\\", DIR_FLAG | 0123, a.getMode()); [EOL]     assertEquals(\\\"uid dir\\\", 5, a.getUserId()); [EOL]     assertEquals(\\\"gid dir\\\", 6, a.getGroupId()); [EOL]     data = new byte[] { 0, 0, 0, 0, 0123, (byte) 0x40, 0, 0, 0, 0, 5, 0, 6, 0 }; [EOL]     a = new AsiExtraField(); [EOL]     try { [EOL]         a.parseFromLocalFileData(data, 0, data.length); [EOL]         fail(\\\"should raise bad CRC exception\\\"); [EOL]     } catch (Exception e) { [EOL]         assertEquals(\\\"bad CRC checksum 0 instead of ebf018e\\\", e.getMessage()); [EOL]     } [EOL] }", "nl": "[LINE] link = new String(linkArray); [LINE] public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException { [EOL]     long givenChecksum = ZipLong.getValue(data, offset); [EOL]     byte[] tmp = new byte[length - WORD]; [EOL]     System.arraycopy(data, offset + WORD, tmp, 0, length - WORD); [EOL]     crc.reset(); [EOL]     crc.update(tmp); [EOL]     long realChecksum = crc.getValue(); [EOL]     if (givenChecksum != realChecksum) { [EOL]         throw new ZipException(\\\"bad CRC checksum \\\" + Long.toHexString(givenChecksum) + \\\" instead of \\\" + Long.toHexString(realChecksum)); [EOL]     } [EOL]     int newMode = ZipShort.getValue(tmp, 0); [EOL]     byte[] linkArray = new byte[(int) ZipLong.getValue(tmp, 2)]; [EOL]     uid = ZipShort.getValue(tmp, 6); [EOL]     gid = ZipShort.getValue(tmp, 8); [EOL]     if (linkArray.length == 0) { [EOL]         link = \\\"\\\"; [EOL]     } else { [EOL]         System.arraycopy(tmp, 10, linkArray, 0, linkArray.length); [EOL]         link = new String(linkArray); [EOL]     } [EOL]     setDirectory((newMode & DIR_FLAG) != 0); [EOL]     setMode(newMode); [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[\\\"\\\"]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] writeRun(); [LINE] public void write(int bv) throws IOException { [EOL]     int b = (256 + bv) % 256; [EOL]     if (currentChar != -1) { [EOL]         if (currentChar == b) { [EOL]             runLength++; [EOL]             if (runLength > 254) { [EOL]                 writeRun(); [EOL]                 currentChar = -1; [EOL]                 runLength = 0; [EOL]             } [EOL]         } else { [EOL]             writeRun(); [EOL]             runLength = 1; [EOL]             currentChar = b; [EOL]         } [EOL]     } else { [EOL]         currentChar = b; [EOL]         runLength++; [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] zPend = 0; [LINE] private void generateMTFValues() { [EOL]     char[] yy = new char[256]; [EOL]     int i, j; [EOL]     char tmp; [EOL]     char tmp2; [EOL]     int zPend; [EOL]     int wr; [EOL]     int EOB; [EOL]     makeMaps(); [EOL]     EOB = nInUse + 1; [EOL]     for (i = 0; i <= EOB; i++) { [EOL]         mtfFreq[i] = 0; [EOL]     } [EOL]     wr = 0; [EOL]     zPend = 0; [EOL]     for (i = 0; i < nInUse; i++) { [EOL]         yy[i] = (char) i; [EOL]     } [EOL]     for (i = 0; i <= last; i++) { [EOL]         char ll_i; [EOL]         ll_i = unseqToSeq[block[zptr[i]]]; [EOL]         j = 0; [EOL]         tmp = yy[j]; [EOL]         while (ll_i != tmp) { [EOL]             j++; [EOL]             tmp2 = tmp; [EOL]             tmp = yy[j]; [EOL]             yy[j] = tmp2; [EOL]         } [EOL]         yy[0] = tmp; [EOL]         if (j == 0) { [EOL]             zPend++; [EOL]         } else { [EOL]             if (zPend > 0) { [EOL]                 zPend--; [EOL]                 while (true) { [EOL]                     switch(zPend % 2) { [EOL]                         case 0: [EOL]                             szptr[wr] = (short) RUNA; [EOL]                             wr++; [EOL]                             mtfFreq[RUNA]++; [EOL]                             break; [EOL]                         case 1: [EOL]                             szptr[wr] = (short) RUNB; [EOL]                             wr++; [EOL]                             mtfFreq[RUNB]++; [EOL]                             break; [EOL]                     } [EOL]                     if (zPend < 2) { [EOL]                         break; [EOL]                     } [EOL]                     zPend = (zPend - 2) / 2; [EOL]                 } [EOL]                 zPend = 0; [EOL]             } [EOL]             szptr[wr] = (short) (j + 1); [EOL]             wr++; [EOL]             mtfFreq[j + 1]++; [EOL]         } [EOL]     } [EOL]     if (zPend > 0) { [EOL]         zPend--; [EOL]         while (true) { [EOL]             switch(zPend % 2) { [EOL]                 case 0: [EOL]                     szptr[wr] = (short) RUNA; [EOL]                     wr++; [EOL]                     mtfFreq[RUNA]++; [EOL]                     break; [EOL]                 case 1: [EOL]                     szptr[wr] = (short) RUNB; [EOL]                     wr++; [EOL]                     mtfFreq[RUNB]++; [EOL]                     break; [EOL]             } [EOL]             if (zPend < 2) { [EOL]                 break; [EOL]             } [EOL]             zPend = (zPend - 2) / 2; [EOL]         } [EOL]     } [EOL]     szptr[wr] = (short) EOB; [EOL]     wr++; [EOL]     mtfFreq[EOB]++; [EOL]     nMTF = wr; [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] static ZipEncoding getZipEncoding(String name) { [LINE] static ZipEncoding getZipEncoding(String name) { [EOL]     if (isUTF8(name)) { [EOL]         return UTF8_ZIP_ENCODING; [EOL]     } [EOL]     if (name == null) { [EOL]         return new FallbackZipEncoding(); [EOL]     } [EOL]     SimpleEncodingHolder h = (SimpleEncodingHolder) simpleEncodings.get(name); [EOL]     if (h != null) { [EOL]         return h.getEncoding(); [EOL]     } [EOL]     try { [EOL]         Charset cs = Charset.forName(name); [EOL]         return new NioZipEncoding(cs); [EOL]     } catch (UnsupportedCharsetException e) { [EOL]         return new FallbackZipEncoding(name); [EOL]     } [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }]; String UTF8=Optional[\\\"UTF8\\\"]; ZipEncoding UTF8_ZIP_ENCODING=Optional[new FallbackZipEncoding(UTF8)]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] if (inUse[i]) { [LINE] private void makeMaps() { [EOL]     int i; [EOL]     nInUse = 0; [EOL]     for (i = 0; i < 256; i++) { [EOL]         if (inUse[i]) { [EOL]             seqToUnseq[nInUse] = (char) i; [EOL]             unseqToSeq[i] = (char) nInUse; [EOL]             nInUse++; [EOL]         } [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testContent() { [EOL]     AsiExtraField a = new AsiExtraField(); [EOL]     a.setMode(0123); [EOL]     a.setUserId(5); [EOL]     a.setGroupId(6); [EOL]     byte[] b = a.getLocalFileDataData(); [EOL]     byte[] expect = { (byte) 0xC6, 0x02, 0x78, (byte) 0xB6, 0123, (byte) 0x80, 0, 0, 0, 0, 5, 0, 6, 0 }; [EOL]     assertEquals(\\\"no link\\\", expect.length, b.length); [EOL]     for (int i = 0; i < expect.length; i++) { [EOL]         assertEquals(\\\"no link, byte \\\" + i, expect[i], b[i]); [EOL]     } [EOL]     a.setLinkedFile(\\\"test\\\"); [EOL]     expect = new byte[] { 0x75, (byte) 0x8E, 0x41, (byte) 0xFD, 0123, (byte) 0xA0, 4, 0, 0, 0, 5, 0, 6, 0, (byte) 't', (byte) 'e', (byte) 's', (byte) 't' }; [EOL]     b = a.getLocalFileDataData(); [EOL]     assertEquals(\\\"no link\\\", expect.length, b.length); [EOL]     for (int i = 0; i < expect.length; i++) { [EOL]         assertEquals(\\\"no link, byte \\\" + i, expect[i], b[i]); [EOL]     } [EOL] }", "nl": "[LINE] byte[] result = new byte[data.length + WORD]; [LINE] public byte[] getLocalFileDataData() { [EOL]     byte[] data = new byte[getLocalFileDataLength().getValue() - WORD]; [EOL]     System.arraycopy(ZipShort.getBytes(getMode()), 0, data, 0, 2); [EOL]     byte[] linkArray = getLinkedFile().getBytes(); [EOL]     System.arraycopy(ZipLong.getBytes(linkArray.length), 0, data, 2, WORD); [EOL]     System.arraycopy(ZipShort.getBytes(getUserId()), 0, data, 6, 2); [EOL]     System.arraycopy(ZipShort.getBytes(getGroupId()), 0, data, 8, 2); [EOL]     System.arraycopy(linkArray, 0, data, 10, linkArray.length); [EOL]     crc.reset(); [EOL]     crc.update(data); [EOL]     long checksum = crc.getValue(); [EOL]     byte[] result = new byte[data.length + WORD]; [EOL]     System.arraycopy(ZipLong.getBytes(checksum), 0, result, 0, WORD); [EOL]     System.arraycopy(data, 0, result, WORD, data.length); [EOL]     return result; [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[\\\"\\\"]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] heap[1] = heap[nHeap]; [LINE] protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) { [EOL]     int nNodes, nHeap, n1, n2, i, j, k; [EOL]     boolean tooLong; [EOL]     int[] heap = new int[MAX_ALPHA_SIZE + 2]; [EOL]     int[] weight = new int[MAX_ALPHA_SIZE * 2]; [EOL]     int[] parent = new int[MAX_ALPHA_SIZE * 2]; [EOL]     for (i = 0; i < alphaSize; i++) { [EOL]         weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8; [EOL]     } [EOL]     while (true) { [EOL]         nNodes = alphaSize; [EOL]         nHeap = 0; [EOL]         heap[0] = 0; [EOL]         weight[0] = 0; [EOL]         parent[0] = -2; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             parent[i] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = i; [EOL]             { [EOL]                 int zz, tmp; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nHeap < (MAX_ALPHA_SIZE + 2))) { [EOL]             panic(); [EOL]         } [EOL]         while (nHeap > 1) { [EOL]             n1 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             n2 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             nNodes++; [EOL]             parent[n1] = parent[n2] = nNodes; [EOL]             weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); [EOL]             parent[nNodes] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = nNodes; [EOL]             { [EOL]                 int zz = 0, tmp = 0; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nNodes < (MAX_ALPHA_SIZE * 2))) { [EOL]             panic(); [EOL]         } [EOL]         tooLong = false; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             j = 0; [EOL]             k = i; [EOL]             while (parent[k] >= 0) { [EOL]                 k = parent[k]; [EOL]                 j++; [EOL]             } [EOL]             len[i - 1] = (char) j; [EOL]             if (j > maxLen) { [EOL]                 tooLong = true; [EOL]             } [EOL]         } [EOL]         if (!tooLong) { [EOL]             break; [EOL]         } [EOL]         for (i = 1; i < alphaSize; i++) { [EOL]             j = weight[i] >> 8; [EOL]             j = 1 + (j / 2); [EOL]             weight[i] = j << 8; [EOL]         } [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] bsLiveShadow--; [LINE] private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testCpioArchiveCreation() throws Exception { [EOL]     final File output = new File(dir, \\\"bla.cpio\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final File file2 = getFile(\\\"test2.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"cpio\\\", out); [EOL]     os.putArchiveEntry(new CpioArchiveEntry(\\\"test1.xml\\\", file1.length())); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.putArchiveEntry(new CpioArchiveEntry(\\\"test2.xml\\\", file2.length())); [EOL]     IOUtils.copy(new FileInputStream(file2), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL] }", "nl": "[LINE] return this.maj; [LINE] public long getDeviceMaj() { [EOL]     checkNewFormat(); [EOL]     return this.maj; [EOL] } public CpioArchiveEntry(final short format); public CpioArchiveEntry(final String name); public CpioArchiveEntry(final String name, final long size); private void checkNewFormat(); private void checkOldFormat(); public long getChksum(); public long getDevice(); public long getDeviceMaj(); public long getDeviceMin(); public long getSize(); public short getFormat(); public long getGID(); public long getHeaderSize(); public long getInode(); public long getMode(); public String getName(); public long getNumberOfLinks(); public long getRemoteDevice(); public long getRemoteDeviceMaj(); public long getRemoteDeviceMin(); public long getTime(); public long getUID(); public boolean isBlockDevice(); public boolean isCharacterDevice(); public boolean isDirectory(); public boolean isNetwork(); public boolean isPipe(); public boolean isRegularFile(); public boolean isSocket(); public boolean isSymbolicLink(); public void setChksum(final long chksum); public void setDevice(final long device); public void setDeviceMaj(final long maj); public void setDeviceMin(final long min); public void setSize(final long size);  final void setFormat(final short format); public void setGID(final long gid); public void setInode(final long inode); public void setMode(final long mode); public void setName(final String name); public void setNumberOfLinks(final long nlink); public void setRemoteDevice(final long device); public void setRemoteDeviceMaj(final long rmaj); public void setRemoteDeviceMin(final long rmin); public void setTime(final long time); public void setUID(final long uid); long chksum=Optional[0]; short fileFormat=Optional[-1]; long filesize=Optional[0]; long gid=Optional[0]; long headerSize=Optional[-1]; long inode=Optional[0]; long maj=Optional[0]; long min=Optional[0]; long mode=Optional[-1]; long mtime=Optional[-1]; String name; long nlink=Optional[0]; long rmaj=Optional[0]; long rmin=Optional[0]; long uid=Optional[0]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] while (true) { [LINE] private void sendMTFValues() throws IOException { [EOL]     char[][] len = new char[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int v, t, i, j, gs, ge, totc, bt, bc, iter; [EOL]     int nSelectors = 0, alphaSize, minLen, maxLen, selCtr; [EOL]     int nGroups; [EOL]     alphaSize = nInUse + 2; [EOL]     for (t = 0; t < N_GROUPS; t++) { [EOL]         for (v = 0; v < alphaSize; v++) { [EOL]             len[t][v] = (char) GREATER_ICOST; [EOL]         } [EOL]     } [EOL]     if (nMTF <= 0) { [EOL]         panic(); [EOL]     } [EOL]     if (nMTF < 200) { [EOL]         nGroups = 2; [EOL]     } else if (nMTF < 600) { [EOL]         nGroups = 3; [EOL]     } else if (nMTF < 1200) { [EOL]         nGroups = 4; [EOL]     } else if (nMTF < 2400) { [EOL]         nGroups = 5; [EOL]     } else { [EOL]         nGroups = 6; [EOL]     } [EOL]     { [EOL]         int nPart, remF, tFreq, aFreq; [EOL]         nPart = nGroups; [EOL]         remF = nMTF; [EOL]         gs = 0; [EOL]         while (nPart > 0) { [EOL]             tFreq = remF / nPart; [EOL]             ge = gs - 1; [EOL]             aFreq = 0; [EOL]             while (aFreq < tFreq && ge < alphaSize - 1) { [EOL]                 ge++; [EOL]                 aFreq += mtfFreq[ge]; [EOL]             } [EOL]             if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 != 0)) { [EOL]                 aFreq -= mtfFreq[ge]; [EOL]                 ge--; [EOL]             } [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 if (v >= gs && v <= ge) { [EOL]                     len[nPart - 1][v] = (char) LESSER_ICOST; [EOL]                 } else { [EOL]                     len[nPart - 1][v] = (char) GREATER_ICOST; [EOL]                 } [EOL]             } [EOL]             nPart--; [EOL]             gs = ge + 1; [EOL]             remF -= aFreq; [EOL]         } [EOL]     } [EOL]     int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int[] fave = new int[N_GROUPS]; [EOL]     short[] cost = new short[N_GROUPS]; [EOL]     for (iter = 0; iter < N_ITERS; iter++) { [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             fave[t] = 0; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 rfreq[t][v] = 0; [EOL]             } [EOL]         } [EOL]         nSelectors = 0; [EOL]         totc = 0; [EOL]         gs = 0; [EOL]         while (true) { [EOL]             if (gs >= nMTF) { [EOL]                 break; [EOL]             } [EOL]             ge = gs + G_SIZE - 1; [EOL]             if (ge >= nMTF) { [EOL]                 ge = nMTF - 1; [EOL]             } [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 cost[t] = 0; [EOL]             } [EOL]             if (nGroups == 6) { [EOL]                 short cost0, cost1, cost2, cost3, cost4, cost5; [EOL]                 cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0; [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     cost0 += len[0][icv]; [EOL]                     cost1 += len[1][icv]; [EOL]                     cost2 += len[2][icv]; [EOL]                     cost3 += len[3][icv]; [EOL]                     cost4 += len[4][icv]; [EOL]                     cost5 += len[5][icv]; [EOL]                 } [EOL]                 cost[0] = cost0; [EOL]                 cost[1] = cost1; [EOL]                 cost[2] = cost2; [EOL]                 cost[3] = cost3; [EOL]                 cost[4] = cost4; [EOL]                 cost[5] = cost5; [EOL]             } else { [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     for (t = 0; t < nGroups; t++) { [EOL]                         cost[t] += len[t][icv]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             bc = 999999999; [EOL]             bt = -1; [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 if (cost[t] < bc) { [EOL]                     bc = cost[t]; [EOL]                     bt = t; [EOL]                 } [EOL]             } [EOL]             totc += bc; [EOL]             fave[bt]++; [EOL]             selector[nSelectors] = (char) bt; [EOL]             nSelectors++; [EOL]             for (i = gs; i <= ge; i++) { [EOL]                 rfreq[bt][szptr[i]]++; [EOL]             } [EOL]             gs = ge + 1; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20); [EOL]         } [EOL]     } [EOL]     rfreq = null; [EOL]     fave = null; [EOL]     cost = null; [EOL]     if (!(nGroups < 8)) { [EOL]         panic(); [EOL]     } [EOL]     if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) { [EOL]         panic(); [EOL]     } [EOL]     { [EOL]         char[] pos = new char[N_GROUPS]; [EOL]         char ll_i, tmp2, tmp; [EOL]         for (i = 0; i < nGroups; i++) { [EOL]             pos[i] = (char) i; [EOL]         } [EOL]         for (i = 0; i < nSelectors; i++) { [EOL]             ll_i = selector[i]; [EOL]             j = 0; [EOL]             tmp = pos[j]; [EOL]             while (ll_i != tmp) { [EOL]                 j++; [EOL]                 tmp2 = tmp; [EOL]                 tmp = pos[j]; [EOL]                 pos[j] = tmp2; [EOL]             } [EOL]             pos[0] = tmp; [EOL]             selectorMtf[i] = (char) j; [EOL]         } [EOL]     } [EOL]     int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         minLen = 32; [EOL]         maxLen = 0; [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             if (len[t][i] > maxLen) { [EOL]                 maxLen = len[t][i]; [EOL]             } [EOL]             if (len[t][i] < minLen) { [EOL]                 minLen = len[t][i]; [EOL]             } [EOL]         } [EOL]         if (maxLen > 20) { [EOL]             panic(); [EOL]         } [EOL]         if (minLen < 1) { [EOL]             panic(); [EOL]         } [EOL]         hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize); [EOL]     } [EOL]     { [EOL]         boolean[] inUse16 = new boolean[16]; [EOL]         for (i = 0; i < 16; i++) { [EOL]             inUse16[i] = false; [EOL]             for (j = 0; j < 16; j++) { [EOL]                 if (inUse[i * 16 + j]) { [EOL]                     inUse16[i] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 bsW(1, 1); [EOL]             } else { [EOL]                 bsW(1, 0); [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 for (j = 0; j < 16; j++) { [EOL]                     if (inUse[i * 16 + j]) { [EOL]                         bsW(1, 1); [EOL]                     } else { [EOL]                         bsW(1, 0); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     bsW(3, nGroups); [EOL]     bsW(15, nSelectors); [EOL]     for (i = 0; i < nSelectors; i++) { [EOL]         for (j = 0; j < selectorMtf[i]; j++) { [EOL]             bsW(1, 1); [EOL]         } [EOL]         bsW(1, 0); [EOL]     } [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         int curr = len[t][0]; [EOL]         bsW(5, curr); [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             while (curr < len[t][i]) { [EOL]                 bsW(2, 2); [EOL]                 curr++; [EOL]             } [EOL]             while (curr > len[t][i]) { [EOL]                 bsW(2, 3); [EOL]                 curr--; [EOL]             } [EOL]             bsW(1, 0); [EOL]         } [EOL]     } [EOL]     selCtr = 0; [EOL]     gs = 0; [EOL]     while (true) { [EOL]         if (gs >= nMTF) { [EOL]             break; [EOL]         } [EOL]         ge = gs + G_SIZE - 1; [EOL]         if (ge >= nMTF) { [EOL]             ge = nMTF - 1; [EOL]         } [EOL]         for (i = gs; i <= ge; i++) { [EOL]             bsW(len[selector[selCtr]][szptr[i]], code[selector[selCtr]][szptr[i]]); [EOL]         } [EOL]         gs = ge + 1; [EOL]         selCtr++; [EOL]     } [EOL]     if (!(selCtr == nSelectors)) { [EOL]         panic(); [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testTarFileWithFSRoot() throws IOException { [EOL]     File f = File.createTempFile(\\\"taetest\\\", \\\".tar\\\"); [EOL]     f.deleteOnExit(); [EOL]     TarArchiveOutputStream tout = null; [EOL]     TarArchiveInputStream tin = null; [EOL]     try { [EOL]         tout = new TarArchiveOutputStream(new FileOutputStream(f)); [EOL]         TarArchiveEntry t = new TarArchiveEntry(new File(ROOT)); [EOL]         tout.putNextEntry(t); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"foo.txt\\\")); [EOL]         t.setSize(6); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'h', 'e', 'l', 'l', 'o', ' ' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"bar.txt\\\").getAbsolutePath()); [EOL]         t.setSize(5); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'w', 'o', 'r', 'l', 'd' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(\\\"dummy\\\"); [EOL]         t.setName(new File(new File(ROOT), \\\"baz.txt\\\").getAbsolutePath()); [EOL]         t.setSize(1); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { '!' }); [EOL]         tout.closeEntry(); [EOL]         tout.close(); [EOL]         tout = null; [EOL]         tin = new TarArchiveInputStream(new FileInputStream(f)); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"/\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"foo.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"bar.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"baz.txt\\\", t.getName()); [EOL]     } finally { [EOL]         if (tin != null) { [EOL]             tin.close(); [EOL]         } [EOL]         if (tout != null) { [EOL]             tout.close(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] return result; [LINE] public static StringBuffer parseName(byte[] header, int offset, int length) { [EOL]     StringBuffer result = new StringBuffer(length); [EOL]     int end = offset + length; [EOL]     for (int i = offset; i < end; ++i) { [EOL]         if (header[i] == 0) { [EOL]             break; [EOL]         } [EOL]         result.append((char) header[i]); [EOL]     } [EOL]     return result; [EOL] } public static long parseOctal(byte[] header, int offset, int length); public static StringBuffer parseName(byte[] header, int offset, int length); public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length); public static int getOctalBytes(long value, byte[] buf, int offset, int length); public static int getLongOctalBytes(long value, byte[] buf, int offset, int length); public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length); public static long computeCheckSum(byte[] buf); int BYTE_MASK=Optional[255]"}
{"code": "public void testDeletePlusAdd() throws Exception { [EOL]     File input = this.createArchive(\\\"zip\\\"); [EOL]     ArchiveOutputStream out = null; [EOL]     ArchiveInputStream ais = null; [EOL]     File result = File.createTempFile(\\\"test\\\", \\\".zip\\\"); [EOL]     try { [EOL]         final InputStream is = new FileInputStream(input); [EOL]         ais = new ArchiveStreamFactory().createArchiveInputStream(\\\"zip\\\", is); [EOL]         out = new ArchiveStreamFactory().createArchiveOutputStream(\\\"zip\\\", new FileOutputStream(result)); [EOL]         ChangeSet changes = new ChangeSet(); [EOL]         changes.delete(\\\"bla\\\"); [EOL]         final File file1 = getFile(\\\"test.txt\\\"); [EOL]         ArchiveEntry entry = new ZipArchiveEntry(\\\"bla/test.txt\\\"); [EOL]         changes.add(entry, new FileInputStream(file1)); [EOL]         changes.perform(ais, out); [EOL]     } finally { [EOL]         if (out != null) [EOL]             out.close(); [EOL]         if (ais != null) [EOL]             ais.close(); [EOL]     } [EOL]     List expected = new ArrayList(); [EOL]     expected.add(\\\"testdata/test1.xml\\\"); [EOL]     expected.add(\\\"testdata/test2.xml\\\"); [EOL]     expected.add(\\\"test/test3.xml\\\"); [EOL]     expected.add(\\\"test.txt\\\"); [EOL]     expected.add(\\\"something/bla\\\"); [EOL]     expected.add(\\\"bla/test.txt\\\"); [EOL]     expected.add(\\\"test with spaces.txt\\\"); [EOL]     this.checkArchiveContent(result, expected); [EOL] }", "nl": "[LINE] public Change(final String pFilename) { [LINE] public Change(final String pFilename) { [EOL]     if (pFilename == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     targetFile = pFilename; [EOL]     type = TYPE_DELETE; [EOL]     input = null; [EOL]     entry = null; [EOL] } public Change(final String pFilename); public Change(final ArchiveEntry pEntry, final InputStream pInput); public ArchiveEntry getEntry(); public InputStream getInput(); public String targetFile(); public int type(); String targetFile; ArchiveEntry entry; InputStream input; int type; int TYPE_DELETE=Optional[1]; int TYPE_ADD=Optional[2]; int TYPE_MOVE=Optional[3]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] case 3: [LINE] private void writeRun() throws IOException { [EOL]     if (last < allowableBlockSize) { [EOL]         inUse[currentChar] = true; [EOL]         for (int i = 0; i < runLength; i++) { [EOL]             mCrc.updateCRC((char) currentChar); [EOL]         } [EOL]         switch(runLength) { [EOL]             case 1: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 2: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 3: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             default: [EOL]                 inUse[runLength - 4] = true; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) (runLength - 4); [EOL]                 break; [EOL]         } [EOL]     } else { [EOL]         endBlock(); [EOL]         initBlock(); [EOL]         writeRun(); [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] case NO_RAND_PART_B_STATE: [LINE] private int read0() throws IOException { [EOL]     final int retChar = this.currentChar; [EOL]     switch(this.currentState) { [EOL]         case EOF: [EOL]             return -1; [EOL]         case START_BLOCK_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case RAND_PART_A_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case RAND_PART_B_STATE: [EOL]             setupRandPartB(); [EOL]             break; [EOL]         case RAND_PART_C_STATE: [EOL]             setupRandPartC(); [EOL]             break; [EOL]         case NO_RAND_PART_A_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case NO_RAND_PART_B_STATE: [EOL]             setupNoRandPartB(); [EOL]             break; [EOL]         case NO_RAND_PART_C_STATE: [EOL]             setupNoRandPartC(); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException(); [EOL]     } [EOL]     return retChar; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testArArchiveCreation() throws Exception { [EOL]     final File output = new File(dir, \\\"bla.ar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final File file2 = getFile(\\\"test2.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"ar\\\", out); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test1.xml\\\", file1.length())); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test2.xml\\\", file2.length())); [EOL]     IOUtils.copy(new FileInputStream(file2), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL] }", "nl": "[LINE] offset += write(fm); [LINE] private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException { [EOL]     long offset = 0; [EOL]     final String n = pEntry.getName(); [EOL]     if (n.length() > 16) { [EOL]         throw new IOException(\\\"filename too long\\\"); [EOL]     } [EOL]     offset += write(n); [EOL]     offset = fill(offset, 16, ' '); [EOL]     final String m = \\\"\\\" + (pEntry.getLastModified() / 1000); [EOL]     if (m.length() > 12) { [EOL]         throw new IOException(\\\"modified too long\\\"); [EOL]     } [EOL]     offset += write(m); [EOL]     offset = fill(offset, 28, ' '); [EOL]     final String u = \\\"\\\" + pEntry.getUserId(); [EOL]     if (u.length() > 6) { [EOL]         throw new IOException(\\\"userid too long\\\"); [EOL]     } [EOL]     offset += write(u); [EOL]     offset = fill(offset, 34, ' '); [EOL]     final String g = \\\"\\\" + pEntry.getGroupId(); [EOL]     if (g.length() > 6) { [EOL]         throw new IOException(\\\"groupid too long\\\"); [EOL]     } [EOL]     offset += write(g); [EOL]     offset = fill(offset, 40, ' '); [EOL]     final String fm = \\\"\\\" + Integer.toString(pEntry.getMode(), 8); [EOL]     if (fm.length() > 8) { [EOL]         throw new IOException(\\\"filemode too long\\\"); [EOL]     } [EOL]     offset += write(fm); [EOL]     offset = fill(offset, 48, ' '); [EOL]     final String s = \\\"\\\" + pEntry.getLength(); [EOL]     if (s.length() > 10) { [EOL]         throw new IOException(\\\"size too long\\\"); [EOL]     } [EOL]     offset += write(s); [EOL]     offset = fill(offset, 58, ' '); [EOL]     offset += write(\\\"`\\012\\\"); [EOL]     return offset; [EOL] } public ArArchiveOutputStream(final OutputStream pOut); private long writeArchiveHeader() throws IOException; public void closeArchiveEntry() throws IOException; public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException; private long fill(final long pOffset, final long pNewOffset, final char pFill) throws IOException; private long write(final String data) throws IOException; private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException; public void write(int b) throws IOException; public void write(byte[] b, int off, int len) throws IOException; public void write(byte[] b) throws IOException; public void close() throws IOException; OutputStream out; long archiveOffset=Optional[0]; long entryOffset=Optional[0]; ArArchiveEntry prevEntry"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] written += entry.getCompressedSize(); [LINE] public void closeEntry() throws IOException { [EOL]     if (entry == null) { [EOL]         return; [EOL]     } [EOL]     long realCrc = crc.getValue(); [EOL]     crc.reset(); [EOL]     if (entry.getMethod() == DEFLATED) { [EOL]         def.finish(); [EOL]         while (!def.finished()) { [EOL]             deflate(); [EOL]         } [EOL]         entry.setSize(ZipUtil.adjustToLong(def.getTotalIn())); [EOL]         entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut())); [EOL]         entry.setCrc(realCrc); [EOL]         def.reset(); [EOL]         written += entry.getCompressedSize(); [EOL]     } else if (raf == null) { [EOL]         if (entry.getCrc() != realCrc) { [EOL]             throw new ZipException(\\\"bad CRC checksum for entry \\\" + entry.getName() + \\\": \\\" + Long.toHexString(entry.getCrc()) + \\\" instead of \\\" + Long.toHexString(realCrc)); [EOL]         } [EOL]         if (entry.getSize() != written - dataStart) { [EOL]             throw new ZipException(\\\"bad size for entry \\\" + entry.getName() + \\\": \\\" + entry.getSize() + \\\" instead of \\\" + (written - dataStart)); [EOL]         } [EOL]     } else { [EOL]         long size = written - dataStart; [EOL]         entry.setSize(size); [EOL]         entry.setCompressedSize(size); [EOL]         entry.setCrc(realCrc); [EOL]     } [EOL]     if (raf != null) { [EOL]         long save = raf.getFilePointer(); [EOL]         raf.seek(localDataStart); [EOL]         writeOut(ZipLong.getBytes(entry.getCrc())); [EOL]         writeOut(ZipLong.getBytes(entry.getCompressedSize())); [EOL]         writeOut(ZipLong.getBytes(entry.getSize())); [EOL]         raf.seek(save); [EOL]     } [EOL]     writeDataDescriptor(entry); [EOL]     entry = null; [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] closeEntry(); [LINE] public void putNextEntry(ZipArchiveEntry ze) throws IOException { [EOL]     closeEntry(); [EOL]     entry = ze; [EOL]     entries.add(entry); [EOL]     if (entry.getMethod() == -1) { [EOL]         entry.setMethod(method); [EOL]     } [EOL]     if (entry.getTime() == -1) { [EOL]         entry.setTime(System.currentTimeMillis()); [EOL]     } [EOL]     if (entry.getMethod() == STORED && raf == null) { [EOL]         if (entry.getSize() == -1) { [EOL]             throw new ZipException(\\\"uncompressed size is required for\\\" + \\\" STORED method when not writing to a\\\" + \\\" file\\\"); [EOL]         } [EOL]         if (entry.getCrc() == -1) { [EOL]             throw new ZipException(\\\"crc checksum is required for STORED\\\" + \\\" method when not writing to a file\\\"); [EOL]         } [EOL]         entry.setCompressedSize(entry.getSize()); [EOL]     } [EOL]     if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) { [EOL]         def.setLevel(level); [EOL]         hasCompressionLevelChanged = false; [EOL]     } [EOL]     writeLocalFileHeader(entry); [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] bsLiveShadow -= zn; [LINE] private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testCP437FileRoundtripImplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(CP437, false, false); [EOL] }", "nl": "[LINE] String comm = ze.getComment(); [LINE] protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException { [EOL]     boolean encodable = zipEncoding.canEncode(ze.getName()); [EOL]     final ZipEncoding entryEncoding; [EOL]     if (!encodable && fallbackToUTF8) { [EOL]         entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING; [EOL]     } else { [EOL]         entryEncoding = zipEncoding; [EOL]     } [EOL]     ByteBuffer name = entryEncoding.encode(ze.getName()); [EOL]     if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) { [EOL]         if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS || !encodable) { [EOL]             ze.addExtraField(new UnicodePathExtraField(ze.getName(), name.array(), name.arrayOffset(), name.limit())); [EOL]         } [EOL]         String comm = ze.getComment(); [EOL]         if (comm != null && !\\\"\\\".equals(comm)) { [EOL]             boolean commentEncodable = this.zipEncoding.canEncode(comm); [EOL]             if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS || !commentEncodable) { [EOL]                 ByteBuffer commentB = entryEncoding.encode(comm); [EOL]                 ze.addExtraField(new UnicodeCommentExtraField(comm, commentB.array(), commentB.arrayOffset(), commentB.limit())); [EOL]             } [EOL]         } [EOL]     } [EOL]     offsets.put(ze, ZipLong.getBytes(written)); [EOL]     writeOut(LFH_SIG); [EOL]     written += WORD; [EOL]     final int zipMethod = ze.getMethod(); [EOL]     writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8); [EOL]     written += WORD; [EOL]     writeOut(ZipShort.getBytes(zipMethod)); [EOL]     written += SHORT; [EOL]     writeOut(ZipUtil.toDosTime(ze.getTime())); [EOL]     written += WORD; [EOL]     localDataStart = written; [EOL]     if (zipMethod == DEFLATED || raf != null) { [EOL]         writeOut(LZERO); [EOL]         writeOut(LZERO); [EOL]         writeOut(LZERO); [EOL]     } else { [EOL]         writeOut(ZipLong.getBytes(ze.getCrc())); [EOL]         writeOut(ZipLong.getBytes(ze.getSize())); [EOL]         writeOut(ZipLong.getBytes(ze.getSize())); [EOL]     } [EOL]     written += 12; [EOL]     writeOut(ZipShort.getBytes(name.limit())); [EOL]     written += SHORT; [EOL]     byte[] extra = ze.getLocalFileDataExtra(); [EOL]     writeOut(ZipShort.getBytes(extra.length)); [EOL]     written += SHORT; [EOL]     writeOut(name.array(), name.arrayOffset(), name.limit()); [EOL]     written += name.limit(); [EOL]     writeOut(extra); [EOL]     written += extra.length; [EOL]     dataStart = written; [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testArArchiveCreation() throws Exception { [EOL]     final File output = new File(dir, \\\"bla.ar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final File file2 = getFile(\\\"test2.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"ar\\\", out); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test1.xml\\\", file1.length())); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.putArchiveEntry(new ArArchiveEntry(\\\"test2.xml\\\", file2.length())); [EOL]     IOUtils.copy(new FileInputStream(file2), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL] }", "nl": "[LINE] offset = fill(offset, 40, ' '); [LINE] private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException { [EOL]     long offset = 0; [EOL]     final String n = pEntry.getName(); [EOL]     if (n.length() > 16) { [EOL]         throw new IOException(\\\"filename too long\\\"); [EOL]     } [EOL]     offset += write(n); [EOL]     offset = fill(offset, 16, ' '); [EOL]     final String m = \\\"\\\" + (pEntry.getLastModified() / 1000); [EOL]     if (m.length() > 12) { [EOL]         throw new IOException(\\\"modified too long\\\"); [EOL]     } [EOL]     offset += write(m); [EOL]     offset = fill(offset, 28, ' '); [EOL]     final String u = \\\"\\\" + pEntry.getUserId(); [EOL]     if (u.length() > 6) { [EOL]         throw new IOException(\\\"userid too long\\\"); [EOL]     } [EOL]     offset += write(u); [EOL]     offset = fill(offset, 34, ' '); [EOL]     final String g = \\\"\\\" + pEntry.getGroupId(); [EOL]     if (g.length() > 6) { [EOL]         throw new IOException(\\\"groupid too long\\\"); [EOL]     } [EOL]     offset += write(g); [EOL]     offset = fill(offset, 40, ' '); [EOL]     final String fm = \\\"\\\" + Integer.toString(pEntry.getMode(), 8); [EOL]     if (fm.length() > 8) { [EOL]         throw new IOException(\\\"filemode too long\\\"); [EOL]     } [EOL]     offset += write(fm); [EOL]     offset = fill(offset, 48, ' '); [EOL]     final String s = \\\"\\\" + pEntry.getLength(); [EOL]     if (s.length() > 10) { [EOL]         throw new IOException(\\\"size too long\\\"); [EOL]     } [EOL]     offset += write(s); [EOL]     offset = fill(offset, 58, ' '); [EOL]     offset += write(\\\"`\\012\\\"); [EOL]     return offset; [EOL] } public ArArchiveOutputStream(final OutputStream pOut); private long writeArchiveHeader() throws IOException; public void closeArchiveEntry() throws IOException; public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException; private long fill(final long pOffset, final long pNewOffset, final char pFill) throws IOException; private long write(final String data) throws IOException; private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException; public void write(int b) throws IOException; public void write(byte[] b, int off, int len) throws IOException; public void write(byte[] b) throws IOException; public void close() throws IOException; OutputStream out; long archiveOffset=Optional[0]; long entryOffset=Optional[0]; ArArchiveEntry prevEntry"}
{"code": "public void testTarArchiveLongNameCreation() throws Exception { [EOL]     String name = \\\"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\\\"; [EOL]     byte[] bytes = name.getBytes(); [EOL]     assertEquals(bytes.length, 99); [EOL]     final File output = new File(dir, \\\"bla.tar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out); [EOL]     final TarArchiveEntry entry = new TarArchiveEntry(name); [EOL]     entry.setModTime(0); [EOL]     entry.setSize(file1.length()); [EOL]     entry.setUserId(0); [EOL]     entry.setGroupId(0); [EOL]     entry.setUserName(\\\"avalon\\\"); [EOL]     entry.setGroupName(\\\"excalibur\\\"); [EOL]     entry.setMode(0100000); [EOL]     os.putArchiveEntry(entry); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL]     ArchiveOutputStream os2 = null; [EOL]     try { [EOL]         String toLongName = \\\"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\\\"; [EOL]         final File output2 = new File(dir, \\\"bla.tar\\\"); [EOL]         final OutputStream out2 = new FileOutputStream(output2); [EOL]         os2 = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out2); [EOL]         final TarArchiveEntry entry2 = new TarArchiveEntry(toLongName); [EOL]         entry2.setModTime(0); [EOL]         entry2.setSize(file1.length()); [EOL]         entry2.setUserId(0); [EOL]         entry2.setGroupId(0); [EOL]         entry2.setUserName(\\\"avalon\\\"); [EOL]         entry2.setGroupName(\\\"excalibur\\\"); [EOL]         entry2.setMode(0100000); [EOL]         os.putArchiveEntry(entry); [EOL]         IOUtils.copy(new FileInputStream(file1), os2); [EOL]     } catch (IOException e) { [EOL]         assertTrue(true); [EOL]     } finally { [EOL]         if (os2 != null) { [EOL]             os2.closeArchiveEntry(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] this.recordSize = recordSize; [LINE] private void initialize(int blockSize, int recordSize) { [EOL]     this.debug = false; [EOL]     this.blockSize = blockSize; [EOL]     this.recordSize = recordSize; [EOL]     this.recsPerBlock = (this.blockSize / this.recordSize); [EOL]     this.blockBuffer = new byte[this.blockSize]; [EOL]     if (this.inStream != null) { [EOL]         this.currBlkIdx = -1; [EOL]         this.currRecIdx = this.recsPerBlock; [EOL]     } else { [EOL]         this.currBlkIdx = 0; [EOL]         this.currRecIdx = 0; [EOL]     } [EOL] } public TarBuffer(InputStream inStream); public TarBuffer(InputStream inStream, int blockSize); public TarBuffer(InputStream inStream, int blockSize, int recordSize); public TarBuffer(OutputStream outStream); public TarBuffer(OutputStream outStream, int blockSize); public TarBuffer(OutputStream outStream, int blockSize, int recordSize); private void initialize(int blockSize, int recordSize); public int getBlockSize(); public int getRecordSize(); public void setDebug(boolean debug); public boolean isEOFRecord(byte[] record); public void skipRecord() throws IOException; public byte[] readRecord() throws IOException; private boolean readBlock() throws IOException; public int getCurrentBlockNum(); public int getCurrentRecordNum(); public void writeRecord(byte[] record) throws IOException; public void writeRecord(byte[] buf, int offset) throws IOException; private void writeBlock() throws IOException; private void flushBlock() throws IOException; public void close() throws IOException; int DEFAULT_RCDSIZE=Optional[(512)]; int DEFAULT_BLKSIZE=Optional[(DEFAULT_RCDSIZE * 20)]; InputStream inStream; OutputStream outStream; byte[] blockBuffer; int currBlkIdx; int currRecIdx; int blockSize; int recordSize; int recsPerBlock; boolean debug"}
{"code": "public void testCpioArchiveCreation() throws Exception { [EOL]     final File output = new File(dir, \\\"bla.cpio\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final File file2 = getFile(\\\"test2.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"cpio\\\", out); [EOL]     os.putArchiveEntry(new CpioArchiveEntry(\\\"test1.xml\\\", file1.length())); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.putArchiveEntry(new CpioArchiveEntry(\\\"test2.xml\\\", file2.length())); [EOL]     IOUtils.copy(new FileInputStream(file2), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL] }", "nl": "[LINE] public long getTime() { [LINE] public long getTime() { [EOL]     return this.mtime; [EOL] } public CpioArchiveEntry(final short format); public CpioArchiveEntry(final String name); public CpioArchiveEntry(final String name, final long size); private void checkNewFormat(); private void checkOldFormat(); public long getChksum(); public long getDevice(); public long getDeviceMaj(); public long getDeviceMin(); public long getSize(); public short getFormat(); public long getGID(); public long getHeaderSize(); public long getInode(); public long getMode(); public String getName(); public long getNumberOfLinks(); public long getRemoteDevice(); public long getRemoteDeviceMaj(); public long getRemoteDeviceMin(); public long getTime(); public long getUID(); public boolean isBlockDevice(); public boolean isCharacterDevice(); public boolean isDirectory(); public boolean isNetwork(); public boolean isPipe(); public boolean isRegularFile(); public boolean isSocket(); public boolean isSymbolicLink(); public void setChksum(final long chksum); public void setDevice(final long device); public void setDeviceMaj(final long maj); public void setDeviceMin(final long min); public void setSize(final long size);  final void setFormat(final short format); public void setGID(final long gid); public void setInode(final long inode); public void setMode(final long mode); public void setName(final String name); public void setNumberOfLinks(final long nlink); public void setRemoteDevice(final long device); public void setRemoteDeviceMaj(final long rmaj); public void setRemoteDeviceMin(final long rmin); public void setTime(final long time); public void setUID(final long uid); long chksum=Optional[0]; short fileFormat=Optional[-1]; long filesize=Optional[0]; long gid=Optional[0]; long headerSize=Optional[-1]; long inode=Optional[0]; long maj=Optional[0]; long min=Optional[0]; long mode=Optional[-1]; long mtime=Optional[-1]; String name; long nlink=Optional[0]; long rmaj=Optional[0]; long rmin=Optional[0]; long uid=Optional[0]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] if (nextSym == RUNA) { [LINE] private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testTarArchiveLongNameCreation() throws Exception { [EOL]     String name = \\\"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\\\"; [EOL]     byte[] bytes = name.getBytes(); [EOL]     assertEquals(bytes.length, 99); [EOL]     final File output = new File(dir, \\\"bla.tar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out); [EOL]     final TarArchiveEntry entry = new TarArchiveEntry(name); [EOL]     entry.setModTime(0); [EOL]     entry.setSize(file1.length()); [EOL]     entry.setUserId(0); [EOL]     entry.setGroupId(0); [EOL]     entry.setUserName(\\\"avalon\\\"); [EOL]     entry.setGroupName(\\\"excalibur\\\"); [EOL]     entry.setMode(0100000); [EOL]     os.putArchiveEntry(entry); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL]     ArchiveOutputStream os2 = null; [EOL]     try { [EOL]         String toLongName = \\\"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\\\"; [EOL]         final File output2 = new File(dir, \\\"bla.tar\\\"); [EOL]         final OutputStream out2 = new FileOutputStream(output2); [EOL]         os2 = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out2); [EOL]         final TarArchiveEntry entry2 = new TarArchiveEntry(toLongName); [EOL]         entry2.setModTime(0); [EOL]         entry2.setSize(file1.length()); [EOL]         entry2.setUserId(0); [EOL]         entry2.setGroupId(0); [EOL]         entry2.setUserName(\\\"avalon\\\"); [EOL]         entry2.setGroupName(\\\"excalibur\\\"); [EOL]         entry2.setMode(0100000); [EOL]         os.putArchiveEntry(entry); [EOL]         IOUtils.copy(new FileInputStream(file1), os2); [EOL]     } catch (IOException e) { [EOL]         assertTrue(true); [EOL]     } finally { [EOL]         if (os2 != null) { [EOL]             os2.closeArchiveEntry(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] this.userId = userId; [LINE] public void setUserId(int userId) { [EOL]     this.userId = userId; [EOL] } private TarArchiveEntry(); public TarArchiveEntry(String name); public TarArchiveEntry(String name, byte linkFlag); public TarArchiveEntry(File file); public TarArchiveEntry(byte[] headerBuf); public boolean equals(TarArchiveEntry it); public boolean equals(Object it); public int hashCode(); public boolean isDescendent(TarArchiveEntry desc); public String getName(); public void setName(String name); public void setMode(int mode); public String getLinkName(); public int getUserId(); public void setUserId(int userId); public int getGroupId(); public void setGroupId(int groupId); public String getUserName(); public void setUserName(String userName); public String getGroupName(); public void setGroupName(String groupName); public void setIds(int userId, int groupId); public void setNames(String userName, String groupName); public void setModTime(long time); public void setModTime(Date time); public Date getModTime(); public File getFile(); public int getMode(); public long getSize(); public void setSize(long size); public boolean isGNULongNameEntry(); public boolean isDirectory(); public TarArchiveEntry[] getDirectoryEntries(); public void writeEntryHeader(byte[] outbuf); public void parseTarHeader(byte[] header); private static String normalizeFileName(String fileName); StringBuffer name; int mode; int userId; int groupId; long size; long modTime; byte linkFlag; StringBuffer linkName; StringBuffer magic; StringBuffer userName; StringBuffer groupName; int devMajor; int devMinor; File file; int MAX_NAMELEN=Optional[31]; int DEFAULT_DIR_MODE=Optional[040755]; int DEFAULT_FILE_MODE=Optional[0100644]; int MILLIS_PER_SECOND=Optional[1000]"}
{"code": "public void testBzipCreation() throws Exception { [EOL]     final File input = getFile(\\\"test.txt\\\"); [EOL]     final File output = new File(dir, \\\"test.txt.bz2\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\\\"bzip2\\\", out); [EOL]     IOUtils.copy(new FileInputStream(input), cos); [EOL]     cos.close(); [EOL] }", "nl": "[LINE] weight[0] = 0; [LINE] protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) { [EOL]     int nNodes, nHeap, n1, n2, i, j, k; [EOL]     boolean tooLong; [EOL]     int[] heap = new int[MAX_ALPHA_SIZE + 2]; [EOL]     int[] weight = new int[MAX_ALPHA_SIZE * 2]; [EOL]     int[] parent = new int[MAX_ALPHA_SIZE * 2]; [EOL]     for (i = 0; i < alphaSize; i++) { [EOL]         weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8; [EOL]     } [EOL]     while (true) { [EOL]         nNodes = alphaSize; [EOL]         nHeap = 0; [EOL]         heap[0] = 0; [EOL]         weight[0] = 0; [EOL]         parent[0] = -2; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             parent[i] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = i; [EOL]             { [EOL]                 int zz, tmp; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nHeap < (MAX_ALPHA_SIZE + 2))) { [EOL]             panic(); [EOL]         } [EOL]         while (nHeap > 1) { [EOL]             n1 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             n2 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             nNodes++; [EOL]             parent[n1] = parent[n2] = nNodes; [EOL]             weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); [EOL]             parent[nNodes] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = nNodes; [EOL]             { [EOL]                 int zz = 0, tmp = 0; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nNodes < (MAX_ALPHA_SIZE * 2))) { [EOL]             panic(); [EOL]         } [EOL]         tooLong = false; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             j = 0; [EOL]             k = i; [EOL]             while (parent[k] >= 0) { [EOL]                 k = parent[k]; [EOL]                 j++; [EOL]             } [EOL]             len[i - 1] = (char) j; [EOL]             if (j > maxLen) { [EOL]                 tooLong = true; [EOL]             } [EOL]         } [EOL]         if (!tooLong) { [EOL]             break; [EOL]         } [EOL]         for (i = 1; i < alphaSize; i++) { [EOL]             j = weight[i] >> 8; [EOL]             j = 1 + (j / 2); [EOL]             weight[i] = j << 8; [EOL]         } [EOL]     } [EOL] } public BZip2CompressorOutputStream(OutputStream inStream) throws IOException; public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException; private static void panic(); private void makeMaps(); protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen); public void write(int bv) throws IOException; private void writeRun() throws IOException; protected void finalize() throws Throwable; public void close() throws IOException; protected void finish() throws IOException; public void flush() throws IOException; private void initialize() throws IOException; private void initBlock(); private void endBlock() throws IOException; private void endCompression() throws IOException; private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize); private void bsSetStream(OutputStream f); private void bsFinishedWithStream() throws IOException; private void bsW(int n, int v) throws IOException; private void bsPutUChar(int c) throws IOException; private void bsPutint(int u) throws IOException; private void bsPutIntVS(int numBits, int c) throws IOException; private void sendMTFValues() throws IOException; private void moveToFrontCodeAndSend() throws IOException; private void simpleSort(int lo, int hi, int d); private void vswap(int p1, int p2, int n); private char med3(char a, char b, char c); private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack); private void mainSort(); private void randomiseBlock(); private void doReversibleTransformation(); private boolean fullGtU(int i1, int i2); private void allocateCompressStructures(); private void generateMTFValues(); int SETMASK=Optional[(1 << 21)]; int CLEARMASK=Optional[(~SETMASK)]; int GREATER_ICOST=Optional[15]; int LESSER_ICOST=Optional[0]; int SMALL_THRESH=Optional[20]; int DEPTH_THRESH=Optional[10]; int QSORT_STACK_SIZE=Optional[1000]; int last; int origPtr; int blockSize100k; boolean blockRandomised; int bytesOut; int bsBuff; int bsLive; CRC mCrc=Optional[new CRC()]; boolean[] inUse=Optional[new boolean[256]]; int nInUse; char[] seqToUnseq=Optional[new char[256]]; char[] unseqToSeq=Optional[new char[256]]; char[] selector=Optional[new char[MAX_SELECTORS]]; char[] selectorMtf=Optional[new char[MAX_SELECTORS]]; char[] block; int[] quadrant; int[] zptr; short[] szptr; int[] ftab; int nMTF; int[] mtfFreq=Optional[new int[MAX_ALPHA_SIZE]]; int workFactor; int workDone; int workLimit; boolean firstAttempt; int nBlocksRandomised; int currentChar=Optional[-1]; int runLength=Optional[0]; boolean closed=Optional[false]; int blockCRC; int combinedCRC; int allowableBlockSize; OutputStream bsStream; int[] incs=Optional[{ 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }]"}
{"code": "public void testTarArchiveLongNameCreation() throws Exception { [EOL]     String name = \\\"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\\\"; [EOL]     byte[] bytes = name.getBytes(); [EOL]     assertEquals(bytes.length, 99); [EOL]     final File output = new File(dir, \\\"bla.tar\\\"); [EOL]     final File file1 = getFile(\\\"test1.xml\\\"); [EOL]     final OutputStream out = new FileOutputStream(output); [EOL]     final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out); [EOL]     final TarArchiveEntry entry = new TarArchiveEntry(name); [EOL]     entry.setModTime(0); [EOL]     entry.setSize(file1.length()); [EOL]     entry.setUserId(0); [EOL]     entry.setGroupId(0); [EOL]     entry.setUserName(\\\"avalon\\\"); [EOL]     entry.setGroupName(\\\"excalibur\\\"); [EOL]     entry.setMode(0100000); [EOL]     os.putArchiveEntry(entry); [EOL]     IOUtils.copy(new FileInputStream(file1), os); [EOL]     os.closeArchiveEntry(); [EOL]     os.close(); [EOL]     ArchiveOutputStream os2 = null; [EOL]     try { [EOL]         String toLongName = \\\"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\\\"; [EOL]         final File output2 = new File(dir, \\\"bla.tar\\\"); [EOL]         final OutputStream out2 = new FileOutputStream(output2); [EOL]         os2 = new ArchiveStreamFactory().createArchiveOutputStream(\\\"tar\\\", out2); [EOL]         final TarArchiveEntry entry2 = new TarArchiveEntry(toLongName); [EOL]         entry2.setModTime(0); [EOL]         entry2.setSize(file1.length()); [EOL]         entry2.setUserId(0); [EOL]         entry2.setGroupId(0); [EOL]         entry2.setUserName(\\\"avalon\\\"); [EOL]         entry2.setGroupName(\\\"excalibur\\\"); [EOL]         entry2.setMode(0100000); [EOL]         os.putArchiveEntry(entry); [EOL]         IOUtils.copy(new FileInputStream(file1), os2); [EOL]     } catch (IOException e) { [EOL]         assertTrue(true); [EOL]     } finally { [EOL]         if (os2 != null) { [EOL]             os2.closeArchiveEntry(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] writeBlock(); [LINE] private void flushBlock() throws IOException { [EOL]     if (debug) { [EOL]         System.err.println(\\\"TarBuffer.flushBlock() called.\\\"); [EOL]     } [EOL]     if (outStream == null) { [EOL]         throw new IOException(\\\"writing to an input buffer\\\"); [EOL]     } [EOL]     if (currRecIdx > 0) { [EOL]         writeBlock(); [EOL]     } [EOL] } public TarBuffer(InputStream inStream); public TarBuffer(InputStream inStream, int blockSize); public TarBuffer(InputStream inStream, int blockSize, int recordSize); public TarBuffer(OutputStream outStream); public TarBuffer(OutputStream outStream, int blockSize); public TarBuffer(OutputStream outStream, int blockSize, int recordSize); private void initialize(int blockSize, int recordSize); public int getBlockSize(); public int getRecordSize(); public void setDebug(boolean debug); public boolean isEOFRecord(byte[] record); public void skipRecord() throws IOException; public byte[] readRecord() throws IOException; private boolean readBlock() throws IOException; public int getCurrentBlockNum(); public int getCurrentRecordNum(); public void writeRecord(byte[] record) throws IOException; public void writeRecord(byte[] buf, int offset) throws IOException; private void writeBlock() throws IOException; private void flushBlock() throws IOException; public void close() throws IOException; int DEFAULT_RCDSIZE=Optional[(512)]; int DEFAULT_BLKSIZE=Optional[(DEFAULT_RCDSIZE * 20)]; InputStream inStream; OutputStream outStream; byte[] blockBuffer; int currBlkIdx; int currRecIdx; int blockSize; int recordSize; int recsPerBlock; boolean debug"}
{"code": "public void testTarFileWithFSRoot() throws IOException { [EOL]     File f = File.createTempFile(\\\"taetest\\\", \\\".tar\\\"); [EOL]     f.deleteOnExit(); [EOL]     TarArchiveOutputStream tout = null; [EOL]     TarArchiveInputStream tin = null; [EOL]     try { [EOL]         tout = new TarArchiveOutputStream(new FileOutputStream(f)); [EOL]         TarArchiveEntry t = new TarArchiveEntry(new File(ROOT)); [EOL]         tout.putNextEntry(t); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"foo.txt\\\")); [EOL]         t.setSize(6); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'h', 'e', 'l', 'l', 'o', ' ' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(new File(new File(ROOT), \\\"bar.txt\\\").getAbsolutePath()); [EOL]         t.setSize(5); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { 'w', 'o', 'r', 'l', 'd' }); [EOL]         tout.closeEntry(); [EOL]         t = new TarArchiveEntry(\\\"dummy\\\"); [EOL]         t.setName(new File(new File(ROOT), \\\"baz.txt\\\").getAbsolutePath()); [EOL]         t.setSize(1); [EOL]         tout.putNextEntry(t); [EOL]         tout.write(new byte[] { '!' }); [EOL]         tout.closeEntry(); [EOL]         tout.close(); [EOL]         tout = null; [EOL]         tin = new TarArchiveInputStream(new FileInputStream(f)); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"/\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"foo.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"bar.txt\\\", t.getName()); [EOL]         t = tin.getNextTarEntry(); [EOL]         assertNotNull(t); [EOL]         assertEquals(\\\"baz.txt\\\", t.getName()); [EOL]     } finally { [EOL]         if (tin != null) { [EOL]             tin.close(); [EOL]         } [EOL]         if (tout != null) { [EOL]             tout.close(); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] this.initialize(blockSize, recordSize); [LINE] public TarBuffer(InputStream inStream, int blockSize, int recordSize) { [EOL]     this.inStream = inStream; [EOL]     this.outStream = null; [EOL]     this.initialize(blockSize, recordSize); [EOL] } public TarBuffer(InputStream inStream); public TarBuffer(InputStream inStream, int blockSize); public TarBuffer(InputStream inStream, int blockSize, int recordSize); public TarBuffer(OutputStream outStream); public TarBuffer(OutputStream outStream, int blockSize); public TarBuffer(OutputStream outStream, int blockSize, int recordSize); private void initialize(int blockSize, int recordSize); public int getBlockSize(); public int getRecordSize(); public void setDebug(boolean debug); public boolean isEOFRecord(byte[] record); public void skipRecord() throws IOException; public byte[] readRecord() throws IOException; private boolean readBlock() throws IOException; public int getCurrentBlockNum(); public int getCurrentRecordNum(); public void writeRecord(byte[] record) throws IOException; public void writeRecord(byte[] buf, int offset) throws IOException; private void writeBlock() throws IOException; private void flushBlock() throws IOException; public void close() throws IOException; int DEFAULT_RCDSIZE=Optional[(512)]; int DEFAULT_BLKSIZE=Optional[(DEFAULT_RCDSIZE * 20)]; InputStream inStream; OutputStream outStream; byte[] blockBuffer; int currBlkIdx; int currRecIdx; int blockSize; int recordSize; int recsPerBlock; boolean debug"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] OutputStream o = null; [LINE] public ZipArchiveOutputStream(File file) throws IOException { [EOL]     OutputStream o = null; [EOL]     RandomAccessFile _raf = null; [EOL]     try { [EOL]         _raf = new RandomAccessFile(file, \\\"rw\\\"); [EOL]         _raf.setLength(0); [EOL]     } catch (IOException e) { [EOL]         if (_raf != null) { [EOL]             try { [EOL]                 _raf.close(); [EOL]             } catch (IOException inner) { [EOL]             } [EOL]             _raf = null; [EOL]         } [EOL]         o = new FileOutputStream(file); [EOL]     } [EOL]     out = o; [EOL]     raf = _raf; [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testDeletePlusAdd() throws Exception { [EOL]     File input = this.createArchive(\\\"zip\\\"); [EOL]     ArchiveOutputStream out = null; [EOL]     ArchiveInputStream ais = null; [EOL]     File result = File.createTempFile(\\\"test\\\", \\\".zip\\\"); [EOL]     try { [EOL]         final InputStream is = new FileInputStream(input); [EOL]         ais = new ArchiveStreamFactory().createArchiveInputStream(\\\"zip\\\", is); [EOL]         out = new ArchiveStreamFactory().createArchiveOutputStream(\\\"zip\\\", new FileOutputStream(result)); [EOL]         ChangeSet changes = new ChangeSet(); [EOL]         changes.delete(\\\"bla\\\"); [EOL]         final File file1 = getFile(\\\"test.txt\\\"); [EOL]         ArchiveEntry entry = new ZipArchiveEntry(\\\"bla/test.txt\\\"); [EOL]         changes.add(entry, new FileInputStream(file1)); [EOL]         changes.perform(ais, out); [EOL]     } finally { [EOL]         if (out != null) [EOL]             out.close(); [EOL]         if (ais != null) [EOL]             ais.close(); [EOL]     } [EOL]     List expected = new ArrayList(); [EOL]     expected.add(\\\"testdata/test1.xml\\\"); [EOL]     expected.add(\\\"testdata/test2.xml\\\"); [EOL]     expected.add(\\\"test/test3.xml\\\"); [EOL]     expected.add(\\\"test.txt\\\"); [EOL]     expected.add(\\\"something/bla\\\"); [EOL]     expected.add(\\\"bla/test.txt\\\"); [EOL]     expected.add(\\\"test with spaces.txt\\\"); [EOL]     this.checkArchiveContent(result, expected); [EOL] }", "nl": "[LINE] public ArchiveInputStream createArchiveInputStream( [LINE] public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException(\\\"Archivername must not be null.\\\"); [EOL]     } [EOL]     if (\\\"ar\\\".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if (\\\"zip\\\".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if (\\\"tar\\\".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if (\\\"jar\\\".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if (\\\"cpio\\\".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException(\\\"Archiver: \\\" + archiverName + \\\" not found.\\\"); [EOL] } public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException; public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out) throws ArchiveException; public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] _raf = new RandomAccessFile(file, \\\"rw\\\"); [LINE] public ZipArchiveOutputStream(File file) throws IOException { [EOL]     OutputStream o = null; [EOL]     RandomAccessFile _raf = null; [EOL]     try { [EOL]         _raf = new RandomAccessFile(file, \\\"rw\\\"); [EOL]         _raf.setLength(0); [EOL]     } catch (IOException e) { [EOL]         if (_raf != null) { [EOL]             try { [EOL]                 _raf.close(); [EOL]             } catch (IOException inner) { [EOL]             } [EOL]             _raf = null; [EOL]         } [EOL]         o = new FileOutputStream(file); [EOL]     } [EOL]     out = o; [EOL]     raf = _raf; [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] bsLiveShadow += 8; [LINE] private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException(\\\"block overrun\\\"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException(\\\"unexpected end of stream\\\"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testCpioUnarchive() throws Exception { [EOL]     StringBuffer expected = new StringBuffer(); [EOL]     expected.append(\\\"./test1.xml<?xml version=\\\\\"1.0\\\\\"?>\\n\\\"); [EOL]     expected.append(\\\"<empty/>./test2.xml<?xml version=\\\\\"1.0\\\\\"?>\\n\\\"); [EOL]     expected.append(\\\"<empty/>\\n\\\"); [EOL]     CpioArchiveInputStream in = new CpioArchiveInputStream(new FileInputStream(getFile(\\\"bla.cpio\\\"))); [EOL]     CpioArchiveEntry entry = null; [EOL]     StringBuffer result = new StringBuffer(); [EOL]     while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) { [EOL]         result.append(entry.getName()); [EOL]         int tmp; [EOL]         while ((tmp = in.read()) != -1) { [EOL]             result.append((char) tmp); [EOL]         } [EOL]     } [EOL]     in.close(); [EOL]     assertEquals(result.toString(), expected.toString()); [EOL] }", "nl": "[LINE] return skip; [LINE] private long pad(final long count, final int border) throws IOException { [EOL]     long skip = count % border; [EOL]     if (skip > 0) { [EOL]         skip = this.in.skip(border - skip); [EOL]     } [EOL]     return skip; [EOL] } public CpioArchiveInputStream(final InputStream in); public int available() throws IOException; public void close() throws IOException; public void closeEntry() throws IOException; private void ensureOpen() throws IOException; public CpioArchiveEntry getNextCPIOEntry() throws IOException; private long pad(final long count, final int border) throws IOException; public int read() throws IOException; public int read(final byte[] b, final int off, final int len) throws IOException; private final int readFully(final byte[] b, final int off, final int len) throws IOException; private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException; private long readAsciiLong(final int length, final int radix) throws IOException; private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException; private CpioArchiveEntry readOldAsciiEntry() throws IOException; private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException; private String readCString(final int length) throws IOException; public long skip(final long n) throws IOException; public ArchiveEntry getNextEntry() throws IOException; public static boolean matches(byte[] signature, int length); boolean closed=Optional[false]; CpioArchiveEntry entry; long entryBytesRead=Optional[0]; boolean entryEOF=Optional[false]; byte[] singleByteBuf=Optional[new byte[1]]; byte[] tmpbuf=Optional[new byte[4096]]; long crc=Optional[0]; InputStream in"}
{"code": "public void testSign() { [EOL]     ZipLong zl = new ZipLong(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }); [EOL]     assertEquals(0x00000000FFFFFFFFl, zl.getValue()); [EOL] }", "nl": "[LINE] this(bytes, 0); [LINE] public ZipLong(byte[] bytes) { [EOL]     this(bytes, 0); [EOL] } public ZipLong(long value); public ZipLong(byte[] bytes); public ZipLong(byte[] bytes, int offset); public byte[] getBytes(); public long getValue(); public static byte[] getBytes(long value); public static long getValue(byte[] bytes, int offset); public static long getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int WORD=Optional[4]; int BYTE_MASK=Optional[0xFF]; int BYTE_1=Optional[1]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int BYTE_2=Optional[2]; int BYTE_2_MASK=Optional[0xFF0000]; int BYTE_2_SHIFT=Optional[16]; int BYTE_3=Optional[3]; long BYTE_3_MASK=Optional[0xFF000000L]; int BYTE_3_SHIFT=Optional[24]; long value"}
{"code": "public void testUnixMode() { [EOL]     ZipArchiveEntry ze = new ZipArchiveEntry(\\\"foo\\\"); [EOL]     assertEquals(0, ze.getPlatform()); [EOL]     ze.setUnixMode(0755); [EOL]     assertEquals(3, ze.getPlatform()); [EOL]     assertEquals(0755, (ze.getExternalAttributes() >> 16) & 0xFFFF); [EOL]     assertEquals(0, ze.getExternalAttributes() & 0xFFFF); [EOL]     ze.setUnixMode(0444); [EOL]     assertEquals(3, ze.getPlatform()); [EOL]     assertEquals(0444, (ze.getExternalAttributes() >> 16) & 0xFFFF); [EOL]     assertEquals(1, ze.getExternalAttributes() & 0xFFFF); [EOL]     ze = new ZipArchiveEntry(\\\"foo/\\\"); [EOL]     assertEquals(0, ze.getPlatform()); [EOL]     ze.setUnixMode(0777); [EOL]     assertEquals(3, ze.getPlatform()); [EOL]     assertEquals(0777, (ze.getExternalAttributes() >> 16) & 0xFFFF); [EOL]     assertEquals(0x10, ze.getExternalAttributes() & 0xFFFF); [EOL]     ze.setUnixMode(0577); [EOL]     assertEquals(3, ze.getPlatform()); [EOL]     assertEquals(0577, (ze.getExternalAttributes() >> 16) & 0xFFFF); [EOL]     assertEquals(0x11, ze.getExternalAttributes() & 0xFFFF); [EOL] }", "nl": "[LINE] public boolean isDirectory() { [LINE] public boolean isDirectory() { [EOL]     return getName().endsWith(\\\"/\\\"); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] makeMaps(); [LINE] private void recvDecodingTables() throws IOException { [EOL]     final Data dataShadow = this.data; [EOL]     final boolean[] inUse = dataShadow.inUse; [EOL]     final byte[] pos = dataShadow.recvDecodingTables_pos; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] selectorMtf = dataShadow.selectorMtf; [EOL]     int inUse16 = 0; [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if (bsGetBit()) { [EOL]             inUse16 |= 1 << i; [EOL]         } [EOL]     } [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         inUse[i] = false; [EOL]     } [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if ((inUse16 & (1 << i)) != 0) { [EOL]             final int i16 = i << 4; [EOL]             for (int j = 0; j < 16; j++) { [EOL]                 if (bsGetBit()) { [EOL]                     inUse[i16 + j] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     makeMaps(); [EOL]     final int alphaSize = this.nInUse + 2; [EOL]     final int nGroups = bsR(3); [EOL]     final int nSelectors = bsR(15); [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int j = 0; [EOL]         while (bsGetBit()) { [EOL]             j++; [EOL]         } [EOL]         selectorMtf[i] = (byte) j; [EOL]     } [EOL]     for (int v = nGroups; --v >= 0; ) { [EOL]         pos[v] = (byte) v; [EOL]     } [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int v = selectorMtf[i] & 0xff; [EOL]         final byte tmp = pos[v]; [EOL]         while (v > 0) { [EOL]             pos[v] = pos[v - 1]; [EOL]             v--; [EOL]         } [EOL]         pos[0] = tmp; [EOL]         selector[i] = tmp; [EOL]     } [EOL]     final char[][] len = dataShadow.temp_charArray2d; [EOL]     for (int t = 0; t < nGroups; t++) { [EOL]         int curr = bsR(5); [EOL]         final char[] len_t = len[t]; [EOL]         for (int i = 0; i < alphaSize; i++) { [EOL]             while (bsGetBit()) { [EOL]                 curr += bsGetBit() ? -1 : 1; [EOL]             } [EOL]             len_t[i] = (char) curr; [EOL]         } [EOL]     } [EOL]     createHuffmanDecodingTables(alphaSize, nGroups); [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testBzip2Unarchive() throws Exception { [EOL]     final File input = getFile(\\\"bla.txt.bz2\\\"); [EOL]     final File output = new File(dir, \\\"bla.txt\\\"); [EOL]     final InputStream is = new FileInputStream(input); [EOL]     final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\\\"bzip2\\\", is); [EOL]     IOUtils.copy(in, new FileOutputStream(output)); [EOL]     in.close(); [EOL] }", "nl": "[LINE] for (int i = 256; --i >= 0;) { [LINE] private void recvDecodingTables() throws IOException { [EOL]     final Data dataShadow = this.data; [EOL]     final boolean[] inUse = dataShadow.inUse; [EOL]     final byte[] pos = dataShadow.recvDecodingTables_pos; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] selectorMtf = dataShadow.selectorMtf; [EOL]     int inUse16 = 0; [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if (bsGetBit()) { [EOL]             inUse16 |= 1 << i; [EOL]         } [EOL]     } [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         inUse[i] = false; [EOL]     } [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if ((inUse16 & (1 << i)) != 0) { [EOL]             final int i16 = i << 4; [EOL]             for (int j = 0; j < 16; j++) { [EOL]                 if (bsGetBit()) { [EOL]                     inUse[i16 + j] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     makeMaps(); [EOL]     final int alphaSize = this.nInUse + 2; [EOL]     final int nGroups = bsR(3); [EOL]     final int nSelectors = bsR(15); [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int j = 0; [EOL]         while (bsGetBit()) { [EOL]             j++; [EOL]         } [EOL]         selectorMtf[i] = (byte) j; [EOL]     } [EOL]     for (int v = nGroups; --v >= 0; ) { [EOL]         pos[v] = (byte) v; [EOL]     } [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int v = selectorMtf[i] & 0xff; [EOL]         final byte tmp = pos[v]; [EOL]         while (v > 0) { [EOL]             pos[v] = pos[v - 1]; [EOL]             v--; [EOL]         } [EOL]         pos[0] = tmp; [EOL]         selector[i] = tmp; [EOL]     } [EOL]     final char[][] len = dataShadow.temp_charArray2d; [EOL]     for (int t = 0; t < nGroups; t++) { [EOL]         int curr = bsR(5); [EOL]         final char[] len_t = len[t]; [EOL]         for (int i = 0; i < alphaSize; i++) { [EOL]             while (bsGetBit()) { [EOL]                 curr += bsGetBit() ? -1 : 1; [EOL]             } [EOL]             len_t[i] = (char) curr; [EOL]         } [EOL]     } [EOL]     createHuffmanDecodingTables(alphaSize, nGroups); [EOL] } public BZip2CompressorInputStream(final InputStream in) throws IOException;  Data(int blockSize100k); public int read() throws IOException; public int read(final byte[] dest, final int offs, final int len) throws IOException; private void makeMaps(); private int read0() throws IOException; private void init() throws IOException; private void checkMagicChar(char expected, String position) throws IOException; private void initBlock() throws IOException; private void endBlock() throws IOException; private void complete() throws IOException; public void close() throws IOException; private int bsR(final int n) throws IOException; private boolean bsGetBit() throws IOException; private char bsGetUByte() throws IOException; private int bsGetInt() throws IOException; private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize); private void recvDecodingTables() throws IOException; private void createHuffmanDecodingTables(final int alphaSize, final int nGroups); private void getAndMoveToFrontDecode() throws IOException; private int getAndMoveToFrontDecode0(final int groupNo) throws IOException; private void setupBlock() throws IOException; private void setupRandPartA() throws IOException; private void setupNoRandPartA() throws IOException; private void setupRandPartB() throws IOException; private void setupRandPartC() throws IOException; private void setupNoRandPartB() throws IOException; private void setupNoRandPartC() throws IOException;  final int[] initTT(int length); int last; int origPtr; int blockSize100k; boolean blockRandomised; int bsBuff; int bsLive; CRC crc=Optional[new CRC()]; int nInUse; InputStream in; int currentChar=Optional[-1]; int EOF=Optional[0]; int START_BLOCK_STATE=Optional[1]; int RAND_PART_A_STATE=Optional[2]; int RAND_PART_B_STATE=Optional[3]; int RAND_PART_C_STATE=Optional[4]; int NO_RAND_PART_A_STATE=Optional[5]; int NO_RAND_PART_B_STATE=Optional[6]; int NO_RAND_PART_C_STATE=Optional[7]; int currentState=Optional[START_BLOCK_STATE]; int storedBlockCRC; int storedCombinedCRC; int computedBlockCRC; int computedCombinedCRC; int su_count; int su_ch2; int su_chPrev; int su_i2; int su_j2; int su_rNToGo; int su_rTPos; int su_tPos; char su_z; BZip2CompressorInputStream.Data data"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] writeOut(ZipLong.getBytes(entry.getSize())); [LINE] public void closeEntry() throws IOException { [EOL]     if (entry == null) { [EOL]         return; [EOL]     } [EOL]     long realCrc = crc.getValue(); [EOL]     crc.reset(); [EOL]     if (entry.getMethod() == DEFLATED) { [EOL]         def.finish(); [EOL]         while (!def.finished()) { [EOL]             deflate(); [EOL]         } [EOL]         entry.setSize(ZipUtil.adjustToLong(def.getTotalIn())); [EOL]         entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut())); [EOL]         entry.setCrc(realCrc); [EOL]         def.reset(); [EOL]         written += entry.getCompressedSize(); [EOL]     } else if (raf == null) { [EOL]         if (entry.getCrc() != realCrc) { [EOL]             throw new ZipException(\\\"bad CRC checksum for entry \\\" + entry.getName() + \\\": \\\" + Long.toHexString(entry.getCrc()) + \\\" instead of \\\" + Long.toHexString(realCrc)); [EOL]         } [EOL]         if (entry.getSize() != written - dataStart) { [EOL]             throw new ZipException(\\\"bad size for entry \\\" + entry.getName() + \\\": \\\" + entry.getSize() + \\\" instead of \\\" + (written - dataStart)); [EOL]         } [EOL]     } else { [EOL]         long size = written - dataStart; [EOL]         entry.setSize(size); [EOL]         entry.setCompressedSize(size); [EOL]         entry.setCrc(realCrc); [EOL]     } [EOL]     if (raf != null) { [EOL]         long save = raf.getFilePointer(); [EOL]         raf.seek(localDataStart); [EOL]         writeOut(ZipLong.getBytes(entry.getCrc())); [EOL]         writeOut(ZipLong.getBytes(entry.getCompressedSize())); [EOL]         writeOut(ZipLong.getBytes(entry.getSize())); [EOL]         raf.seek(save); [EOL]     } [EOL]     writeDataDescriptor(entry); [EOL]     entry = null; [EOL] } public ZipArchiveOutputStream(OutputStream out); public ZipArchiveOutputStream(File file) throws IOException; private UnicodeExtraFieldPolicy(String n); public boolean isSeekable(); public void setEncoding(final String encoding); public String getEncoding(); public void setUseLanguageEncodingFlag(boolean b); public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b); public void setFallbackToUTF8(boolean b); public void finish() throws IOException; public void closeEntry() throws IOException; public void putNextEntry(ZipArchiveEntry ze) throws IOException; public void setComment(String comment); public void setLevel(int level); public void setMethod(int method); public void write(byte[] b, int offset, int length) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void putArchiveEntry(ArchiveEntry entry) throws IOException; public void closeArchiveEntry(); public void write(byte[] b) throws IOException; protected final void deflate() throws IOException; protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException; protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException; protected void writeCentralDirectoryEnd() throws IOException; protected final void writeOut(byte[] data) throws IOException; protected final void writeOut(byte[] data, int offset, int length) throws IOException; private void deflateUntilInputIsNeeded() throws IOException; private void writeVersionNeededToExtractAndGeneralPurposeBits(final int zipMethod, final boolean utfFallback) throws IOException; public String toString(); int BYTE_MASK=Optional[0xFF]; int SHORT=Optional[2]; int WORD=Optional[4]; int BUFFER_SIZE=Optional[512]; int DEFLATER_BLOCK_SIZE=Optional[8192]; int DEFLATED=Optional[java.util.zip.ZipEntry.DEFLATED]; int DEFAULT_COMPRESSION=Optional[Deflater.DEFAULT_COMPRESSION]; int STORED=Optional[java.util.zip.ZipEntry.STORED]; String DEFAULT_ENCODING=Optional[ZipEncodingHelper.UTF8]; int EFS_FLAG=Optional[1 << 11]; ZipArchiveEntry entry; String comment=Optional[\\\"\\\"]; int level=Optional[DEFAULT_COMPRESSION]; boolean hasCompressionLevelChanged=Optional[false]; int method=Optional[java.util.zip.ZipEntry.DEFLATED]; List entries=Optional[new LinkedList()]; CRC32 crc=Optional[new CRC32()]; long written=Optional[0]; long dataStart=Optional[0]; long localDataStart=Optional[0]; long cdOffset=Optional[0]; long cdLength=Optional[0]; byte[] ZERO=Optional[{ 0, 0 }]; byte[] LZERO=Optional[{ 0, 0, 0, 0 }]; Map offsets=Optional[new HashMap()]; String encoding=Optional[DEFAULT_ENCODING]; ZipEncoding zipEncoding=Optional[ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING)]; Deflater def=Optional[new Deflater(level, true)]; byte[] buf=Optional[new byte[BUFFER_SIZE]]; RandomAccessFile raf; OutputStream out; boolean useEFS=Optional[true]; boolean fallbackToUTF8=Optional[false]; UnicodeExtraFieldPolicy createUnicodeExtraFields=Optional[UnicodeExtraFieldPolicy.NEVER]; byte[] LFH_SIG=Optional[ZipLong.getBytes(0X04034B50L)]; byte[] DD_SIG=Optional[ZipLong.getBytes(0X08074B50L)]; byte[] CFH_SIG=Optional[ZipLong.getBytes(0X02014B50L)]; byte[] EOCD_SIG=Optional[ZipLong.getBytes(0X06054B50L)]"}
{"code": "public void testASCIIFileRoundtripExplicitUnicodeExtra() throws IOException { [EOL]     testFileRoundtrip(US_ASCII, false, true); [EOL] }", "nl": "[LINE] } else if (res.isOverflow()) { [LINE] public ByteBuffer encode(String name) { [EOL]     CharsetEncoder enc = this.charset.newEncoder(); [EOL]     enc.onMalformedInput(CodingErrorAction.REPORT); [EOL]     enc.onUnmappableCharacter(CodingErrorAction.REPORT); [EOL]     CharBuffer cb = CharBuffer.wrap(name); [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + (name.length() + 1) / 2); [EOL]     while (cb.remaining() > 0) { [EOL]         CoderResult res = enc.encode(cb, out, true); [EOL]         if (res.isUnmappable() || res.isMalformed()) { [EOL]             if (res.length() * 6 > out.remaining()) { [EOL]                 out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6); [EOL]             } [EOL]             for (int i = 0; i < res.length(); ++i) { [EOL]                 ZipEncodingHelper.appendSurrogate(out, cb.get()); [EOL]             } [EOL]         } else if (res.isOverflow()) { [EOL]             out = ZipEncodingHelper.growBuffer(out, 0); [EOL]         } else if (res.isUnderflow()) { [EOL]             enc.flush(out); [EOL]             break; [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] } public NioZipEncoding(Charset charset); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; Charset charset"}
