{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] return _readBinary(b64variant, out, buf); [LINE] @Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { [EOL]         byte[] b = getBinaryValue(b64variant); [EOL]         out.write(b); [EOL]         return b.length; [EOL]     } [EOL]     byte[] buf = _ioContext.allocBase64Buffer(); [EOL]     try { [EOL]         return _readBinary(b64variant, out, buf); [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(buf); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] hash = (hash * HASH_MULT) + (int) buffer[i]; [LINE] public int calcHash(char[] buffer, int start, int len) { [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) buffer[i]; [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] public void setEncoding(JsonEncoding enc) { [LINE] public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] _dirty = false; [LINE] private void mergeChild(CharsToNameCanonicalizer child) { [EOL]     if (child.size() > MAX_ENTRIES_FOR_REUSE || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         synchronized (this) { [EOL]             initTables(DEFAULT_TABLE_SIZE); [EOL]             _dirty = false; [EOL]         } [EOL]     } else { [EOL]         if (child.size() <= size()) { [EOL]             return; [EOL]         } [EOL]         synchronized (this) { [EOL]             _symbols = child._symbols; [EOL]             _buckets = child._buckets; [EOL]             _size = child._size; [EOL]             _sizeThreshold = child._sizeThreshold; [EOL]             _indexMask = child._indexMask; [EOL]             _longestCollisionList = child._longestCollisionList; [EOL]             _dirty = false; [EOL]         } [EOL]     } [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] int qlen = 0; [LINE] protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException { [EOL]     if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(ch, \\\"was expecting double-quote to start field name\\\"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeUtf8JsNames(); [EOL]     if (codes[ch] != 0) { [EOL]         _reportUnexpectedChar(ch, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     while (true) { [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in field name\\\"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]         if (codes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] _buckets[bix] = newB; [LINE] public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return \\\"\\\"; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\\\"c\\\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\\\"abc\\\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }", "nl": "[LINE] if (size < 1) { [LINE] private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray"}
{"code": "public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }", "nl": "[LINE] ++currQuadBytes; [LINE] protected Name _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(\\\": was expecting closing '\\'' for name\\\"); [EOL]         } [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (ch == INT_APOSTROPHE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (ch == INT_APOSTROPHE) { [EOL]             break; [EOL]         } [EOL]         if (ch != INT_QUOTE && codes[ch] != 0) { [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, \\\"name\\\"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in field name\\\"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }", "nl": "[LINE] case '+': // note: '-' is taken as number [LINE] protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken(\\\"NaN\\\", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(\\\"NaN\\\", Double.NaN); [EOL]             } [EOL]             _reportError(\\\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken(\\\"Infinity\\\", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(\\\"Infinity\\\", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError(\\\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken(\\\"\\\" + ((char) i), \\\"('true', 'false' or 'null')\\\"); [EOL]     } [EOL]     _reportUnexpectedChar(i, \\\"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\\\"); [EOL]     return null; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] b = b.getNext(); [LINE] public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testAsInt() throws Exception { [EOL]     final String input = \\\"[ 1, -3, 4.98, true, false, null, \\\\\"-17\\\\\", \\\\\"foo\\\\\" ]\\\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] _parseSlowFloatValue(expType); [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError(\\\"Current token (\\\" + _currToken + \\\") not numeric, can not use numeric value accessors\\\"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail(\\\"Expected an exception for mismatched array/object write\\\"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, \\\"Current context not an array\\\"); [EOL]     } [EOL]     gen.close(); [EOL] }", "nl": "[LINE] return (char[]) HEX_CHARS.clone(); [LINE] public static char[] copyHexChars() { [EOL]     return (char[]) HEX_CHARS.clone(); [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional[\\\"0123456789ABCDEF\\\".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]"}
{"code": "public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \\\"{ \\\\\"a\\\\\" : 1, \\\\\"x\\\\\" : [ ] }\\\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }", "nl": "[LINE] public Name find(int hash, int firstQuad, int secondQuad) [LINE] public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
{"code": "public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }", "nl": "[LINE] if ((d & 0xC0) != 0x080) { [LINE] private void _skipUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }", "nl": "[LINE] outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [LINE] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser(\\\"[true]xyz\\\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     assertEquals(3, jp.releaseBuffered(sw)); [EOL]     assertEquals(\\\"xyz\\\", sw.toString()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] w.write(_inputBuffer, origPtr, count); [LINE] @Override [EOL] public int releaseBuffered(Writer w) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     w.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\\\"c\\\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\\\"abc\\\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }", "nl": "[LINE] _inputStart = -1; [LINE] private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray"}
{"code": "public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     byte[] first = ctxt.allocReadIOBuffer(); [EOL]     System.arraycopy(\\\"ABCDE\\\".getBytes(\\\"UTF-8\\\"), 0, first, 99, 5); [EOL]     byte[] second = \\\"FGHIJ\\\".getBytes(\\\"UTF-8\\\"); [EOL]     assertNull(ctxt.getSourceReference()); [EOL]     assertFalse(ctxt.isResourceManaged()); [EOL]     ctxt.setEncoding(JsonEncoding.UTF8); [EOL]     MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second), first, 99, 99 + 5); [EOL]     assertEquals(5, ms.available()); [EOL]     assertFalse(ms.markSupported()); [EOL]     ms.mark(1); [EOL]     assertEquals((byte) 'A', ms.read()); [EOL]     assertEquals(3, ms.skip(3)); [EOL]     byte[] buffer = new byte[5]; [EOL]     assertEquals(1, ms.read(buffer, 1, 3)); [EOL]     assertEquals((byte) 'E', buffer[1]); [EOL]     assertEquals(3, ms.read(buffer, 0, 3)); [EOL]     assertEquals((byte) 'F', buffer[0]); [EOL]     assertEquals((byte) 'G', buffer[1]); [EOL]     assertEquals((byte) 'H', buffer[2]); [EOL]     assertEquals(2, ms.available()); [EOL]     assertEquals(2, ms.skip(200)); [EOL]     ms.close(); [EOL] }", "nl": "[LINE] if (buf != null) { [LINE] private void freeMergedBuffer() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         if (_context != null) { [EOL]             _context.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] } public MergedStream(IOContext context, InputStream in, byte[] buf, int start, int end); public int available() throws IOException; public void close() throws IOException; public void mark(int readlimit); public boolean markSupported(); public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public void reset() throws IOException; public long skip(long n) throws IOException; private void freeMergedBuffer(); IOContext _context; InputStream _in; byte[] _buffer; int _ptr; int _end"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] if (_outputStream != null) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testObjectCount() throws Exception { [EOL]     final String EXP = \\\"{\\\\\"x\\\\\":{\\\\\"a\\\\\":1,\\\\\"b\\\\\":2(2)}(1)}\\\"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName(\\\"x\\\"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField(\\\"a\\\", 1); [EOL]         gen.writeNumberField(\\\"b\\\", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString(\\\"UTF-8\\\") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }", "nl": "[LINE] text.getChars(start, start+len2, buf, 0); [LINE] @Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int start = 0; [EOL]     int len = text.length(); [EOL]     while (len > 0) { [EOL]         char[] buf = _charBuffer; [EOL]         final int blen = buf.length; [EOL]         final int len2 = (len < blen) ? len : blen; [EOL]         text.getChars(start, start + len2, buf, 0); [EOL]         writeRaw(buf, 0, len2); [EOL]         start += len2; [EOL]         len -= len2; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] try { [LINE] private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError(\\\"Malformed numeric value '\\\" + numStr + \\\"'\\\", nex); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\\\"UTF-8\\\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] } while (totalLen > 0); [LINE] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         _writeUTF8Segment(utf8, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = \\\"{\\\\\"simple\\\\\":[1,true,{}]}\\\"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }", "nl": "[LINE] close(); [LINE] @Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting a colon to separate field name and value\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, \\\"expected a value\\\"); [EOL]         case INT_t: [EOL]             _matchToken(\\\"true\\\", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken(\\\"false\\\", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken(\\\"null\\\", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] if (i == INT_BACKSLASH) { [LINE] private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\": was expecting closing '\\\" + ((char) endChar) + \\\"' for name\\\"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, \\\"name\\\"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] hashSeed = _hashSeed; [LINE] public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern) { [EOL]     final String[] symbols; [EOL]     final Bucket[] buckets; [EOL]     final int size; [EOL]     final int hashSeed; [EOL]     final int longestCollisionList; [EOL]     synchronized (this) { [EOL]         symbols = _symbols; [EOL]         buckets = _buckets; [EOL]         size = _size; [EOL]         hashSeed = _hashSeed; [EOL]         longestCollisionList = _longestCollisionList; [EOL]     } [EOL]     return new CharsToNameCanonicalizer(this, canonicalize, intern, symbols, buckets, size, hashSeed, longestCollisionList); [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \\\"{ \\\\\"a\\\\\":1, \\\\\"b\\\\\":[{ \\\\\"c\\\\\" : null }] }\\\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\\\"{\\\\\"a\\\\\":1,\\\\\"b\\\\\":[{\\\\\"c\\\\\":null}]}\\\", sw.toString()); [EOL] }", "nl": "[LINE] writeFieldName(jp.getCurrentName()); [LINE] @Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed"}
{"code": "public void testLongerObjects() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useChars = (i == 0); [EOL]         JsonGenerator jgen; [EOL]         ByteArrayOutputStream bout = new ByteArrayOutputStream(200); [EOL]         if (useChars) { [EOL]             jgen = jf.createGenerator(new OutputStreamWriter(bout, \\\"UTF-8\\\")); [EOL]         } else { [EOL]             jgen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]         } [EOL]         jgen.writeStartObject(); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \\\"X\\\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \\\"\\\" + letter + index; [EOL]                     } else { [EOL]                         name = \\\"__\\\" + index + letter; [EOL]                     } [EOL]                     jgen.writeFieldName(name); [EOL]                     jgen.writeNumber(index - 1); [EOL]                 } [EOL]                 jgen.writeRaw('\\n'); [EOL]             } [EOL]         } [EOL]         jgen.writeEndObject(); [EOL]         jgen.close(); [EOL]         byte[] json = bout.toByteArray(); [EOL]         JsonParser jp = jf.createParser(json); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         for (int rounds = 0; rounds < 1500; ++rounds) { [EOL]             for (int letter = 'a'; letter <= 'z'; ++letter) { [EOL]                 for (int index = 0; index < 20; ++index) { [EOL]                     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]                     String name; [EOL]                     if (letter > 'f') { [EOL]                         name = \\\"X\\\" + letter + index; [EOL]                     } else if (letter > 'p') { [EOL]                         name = \\\"\\\" + letter + index; [EOL]                     } else { [EOL]                         name = \\\"__\\\" + index + letter; [EOL]                     } [EOL]                     assertEquals(name, jp.getCurrentName()); [EOL]                     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]                     assertEquals(index - 1, jp.getIntValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] return offset; [LINE] private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     char c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = (byte) c; [EOL]     } [EOL]     c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = (byte) c; [EOL]     } [EOL]     buffer[offset++] = (byte) LEADING_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { \\\"0\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\" }]; String[] sSmallIntStrs2=Optional[new String[] { \\\"-1\\\", \\\"-2\\\", \\\"-3\\\", \\\"-4\\\", \\\"-5\\\", \\\"-6\\\", \\\"-7\\\", \\\"-8\\\", \\\"-9\\\", \\\"-10\\\" }]"}
{"code": "public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }", "nl": "[LINE] ++_inputPtr; [LINE] protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError(\\\"Unrecognized token '\\\" + sb.toString() + \\\"': was expecting \\\"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \\\"\\\\\"text\\\\non two lines\\\\\" true false 2.0\\\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\\\"\\\\\"text\\\\non two lines\\\\\" true false 2.0\\\", sw.toString()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }", "nl": "[LINE] builder.appendThreeBytes(decodedData); [LINE] @SuppressWarnings(\\\"resource\\\") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\\\"[ \\\\\"abc\\\\\" ]\\\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\\\"Expected error trying to call getIntValue on non-numeric value\\\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"can not use numeric value accessors\\\"); [EOL]     } [EOL]     jp.close(); [EOL] }", "nl": "[LINE] protected final void _reportError(String msg) [LINE] protected final void _reportError(String msg) throws JsonParseException { [EOL]     throw _constructError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\\t']; int INT_LF=Optional['\\n']; int INT_CR=Optional['\\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['\\\"']; int INT_BACKSLASH=Optional['\\\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] ++ptr; [LINE] protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, \\\"was expecting double-quote to start field name\\\"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }", "nl": "[LINE] _numTypesValid = NR_LONG; [LINE] private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError(\\\"Malformed numeric value '\\\" + numStr + \\\"'\\\", nex); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] if (!inObject) { [LINE] @Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting a colon to separate field name and value\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, \\\"expected a value\\\"); [EOL]         case INT_t: [EOL]             _matchToken(\\\"true\\\", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken(\\\"false\\\", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken(\\\"null\\\", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] final String[] oldSyms = _symbols; [LINE] private void copyArrays() { [EOL]     final String[] oldSyms = _symbols; [EOL]     _symbols = Arrays.copyOf(oldSyms, oldSyms.length); [EOL]     final Bucket[] oldBuckets = _buckets; [EOL]     _buckets = Arrays.copyOf(oldBuckets, oldBuckets.length); [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testAboveAsciiEscapeWithReader() throws Exception { [EOL]     _testEscapeAboveAscii(false); [EOL] }", "nl": "[LINE] break escape_loop; [LINE] private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape"}
{"code": "public void testQuoting() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \\\"\\n\\\"); [EOL]     assertEquals(\\\"\\\\n\\\", sb.toString()); [EOL]     sb = new StringBuilder(); [EOL]     CharTypes.appendQuoted(sb, \\\"\\u0000\\\"); [EOL]     assertEquals(\\\"\\\\u0000\\\", sb.toString()); [EOL] }", "nl": "[LINE] int escCode = escCodes[c]; [LINE] public static void appendQuoted(StringBuilder sb, String content) { [EOL]     final int[] escCodes = sOutputEscapes128; [EOL]     int escLen = escCodes.length; [EOL]     for (int i = 0, len = content.length(); i < len; ++i) { [EOL]         char c = content.charAt(i); [EOL]         if (c >= escLen || escCodes[c] == 0) { [EOL]             sb.append(c); [EOL]             continue; [EOL]         } [EOL]         sb.append('\\\\'); [EOL]         int escCode = escCodes[c]; [EOL]         if (escCode < 0) { [EOL]             sb.append('u'); [EOL]             sb.append('0'); [EOL]             sb.append('0'); [EOL]             int value = c; [EOL]             sb.append(HEX_CHARS[value >> 4]); [EOL]             sb.append(HEX_CHARS[value & 0xF]); [EOL]         } else { [EOL]             sb.append((char) escCode); [EOL]         } [EOL]     } [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional[\\\"0123456789ABCDEF\\\".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]"}
{"code": "public void testBasicEscaping() throws Exception { [EOL]     doTestBasicEscaping(false); [EOL]     doTestBasicEscaping(true); [EOL] }", "nl": "[LINE] case INT_BACKSLASH: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(\\\" in character escape sequence\\\"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\\b'; [EOL]         case INT_t: [EOL]             return '\\t'; [EOL]         case INT_n: [EOL]             return '\\n'; [EOL]         case INT_f: [EOL]             return '\\f'; [EOL]         case INT_r: [EOL]             return '\\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in character escape sequence\\\"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, \\\"expected a hex-digit for character escape sequence\\\"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }", "nl": "[LINE] if ((_outputTail +  6 * (end - offset)) > _outputEnd) { [LINE] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "@SuppressWarnings(\\\"resource\\\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\\n')); [EOL]     assertEquals(-1, docStr.indexOf('\\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\\\"\\t\\\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\\n')); [EOL]     assertTrue(docStr.indexOf('\\t') >= 0); [EOL]     gen.close(); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('['); [EOL] } public MinimalPrettyPrinter(); public MinimalPrettyPrinter(String rootValueSeparator); public void setRootValueSeparator(String sep); public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException; public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeArrayValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException; long serialVersionUID=Optional[-562765100295218442L]; String DEFAULT_ROOT_VALUE_SEPARATOR=Optional[\\\" \\\"]; String _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]"}
{"code": "public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }", "nl": "[LINE] return MIME_NO_LINEFEEDS; [LINE] public static Base64Variant getDefaultVariant() { [EOL]     return MIME_NO_LINEFEEDS; [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional[\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, \\\"PEM\\\", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] _mainHashShared = true; [LINE] public void release() { [EOL]     if (_parent != null && maybeDirty()) { [EOL]         _parent.mergeChild(new TableInfo(this)); [EOL]         _mainHashShared = true; [EOL]         _mainNamesShared = true; [EOL]         _collListShared = true; [EOL]     } [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
{"code": "public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }", "nl": "[LINE] if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first [LINE] private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL]     int i; [EOL]     if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL]         i = _inputBuffer[++_inputPtr]; [EOL]         ++_inputPtr; [EOL]         if (i == INT_QUOTE) { [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LCURLY) { [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LBRACKET) { [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         } [EOL]         i &= 0xFF; [EOL]         if (i <= INT_SPACE || i == INT_SLASH) { [EOL]             --_inputPtr; [EOL]             i = _skipWS(); [EOL]         } [EOL]     } else { [EOL]         i = _skipColon(); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         case INT_LBRACKET: [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         case INT_LCURLY: [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, \\\"expected a value\\\"); [EOL]         case INT_t: [EOL]             _matchToken(\\\"true\\\", 1); [EOL]             _nextToken = JsonToken.VALUE_TRUE; [EOL]             return; [EOL]         case INT_f: [EOL]             _matchToken(\\\"false\\\", 1); [EOL]             _nextToken = JsonToken.VALUE_FALSE; [EOL]             return; [EOL]         case INT_n: [EOL]             _matchToken(\\\"null\\\", 1); [EOL]             _nextToken = JsonToken.VALUE_NULL; [EOL]             return; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             _nextToken = parseNumberText(i); [EOL]             return; [EOL]     } [EOL]     _nextToken = _handleUnexpectedValue(i); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes(\\\"UTF-8\\\"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 3) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     if (ch <= 0x7F) { [EOL]         bbuf[_outputTail++] = (byte) ch; [EOL]     } else if (ch < 0x800) { [EOL]         bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]         bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } else { [EOL]         _outputRawMultiByteChar(ch, null, 0, 0); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testNumbersAsJSONStrings() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertEquals(\\\"[1,2,1.25,2.25,3001,0.5,-1]\\\", _writeNumbers(jf)); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL]     assertEquals(\\\"[\\\\\"1\\\\\",\\\\\"2\\\\\",\\\\\"1.25\\\\\",\\\\\"2.25\\\\\",\\\\\"3001\\\\\",\\\\\"0.5\\\\\",\\\\\"-1\\\\\"]\\\", _writeNumbers(jf)); [EOL] }", "nl": "[LINE] _writeQuotedInt(i); [LINE] @Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite(\\\"write number\\\"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape"}
{"code": "public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }", "nl": "[LINE] } else if (checkUTF16(quad >>> 16)) { [LINE] public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException(\\\"Internal error\\\"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]"}
{"code": "public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \\\"\\\\\"JSON!\\\\\"\\\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\\\"UTF-8\\\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\\\"JSON\\\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\\\"JSON!\\\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] public DataFormatMatcher findFormat(InputStream in) throws IOException [LINE] public DataFormatMatcher findFormat(InputStream in) throws IOException { [EOL]     return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead])); [EOL] } public DataFormatDetector(JsonFactory... detectors); public DataFormatDetector(Collection<JsonFactory> detectors); private DataFormatDetector(JsonFactory[] detectors, MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead); public DataFormatDetector withOptimalMatch(MatchStrength optMatch); public DataFormatDetector withMinimalMatch(MatchStrength minMatch); public DataFormatDetector withMaxInputLookahead(int lookaheadBytes); public DataFormatMatcher findFormat(InputStream in) throws IOException; public DataFormatMatcher findFormat(byte[] fullInputData) throws IOException; public DataFormatMatcher findFormat(byte[] fullInputData, int offset, int len) throws IOException; public String toString(); private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException; int DEFAULT_MAX_INPUT_LOOKAHEAD=Optional[64]; JsonFactory[] _detectors; MatchStrength _optimalMatch; MatchStrength _minimalMatch; int _maxInputLookahead"}
{"code": "public void testSingleQuotesEnabled() throws Exception { [EOL]     _testSingleQuotesEnabled(false); [EOL]     _testSingleQuotesEnabled(true); [EOL]     _testSingleQuotesEscaped(false); [EOL]     _testSingleQuotesEscaped(true); [EOL] }", "nl": "[LINE] ch = _inputBuffer[_inputPtr++] & 0xFF; [LINE] protected Name _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(\\\": was expecting closing '\\'' for name\\\"); [EOL]         } [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (ch == INT_APOSTROPHE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (ch == INT_APOSTROPHE) { [EOL]             break; [EOL]         } [EOL]         if (ch != INT_QUOTE && codes[ch] != 0) { [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, \\\"name\\\"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in field name\\\"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append(\\\"c\\\", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals(\\\"abc\\\", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }", "nl": "[LINE] return; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] break; [LINE] @Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, \\\"was expecting a colon to separate field name and value\\\"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, \\\"expected a value\\\"); [EOL]         case INT_t: [EOL]             _matchToken(\\\"true\\\", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken(\\\"false\\\", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken(\\\"null\\\", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }", "nl": "[LINE] int ix = (hash & _mainHashMask); [LINE] public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
{"code": "public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \\\"SNAPSHOT\\\", \\\"foo.bar\\\", \\\"foo-bar\\\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \\\"foo.bar\\\", \\\"foo-bar\\\")); [EOL] }", "nl": "[LINE] String pomPropertiesGroupId = props.getProperty(\\\"groupId\\\"); [LINE] public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream(\\\"META-INF/maven/\\\" + groupId.replaceAll(\\\"\\\\.\\\", \\\"/\\\") + \\\"/\\\" + artifactId + \\\"/pom.properties\\\"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty(\\\"version\\\"); [EOL]             String pomPropertiesArtifactId = props.getProperty(\\\"artifactId\\\"); [EOL]             String pomPropertiesGroupId = props.getProperty(\\\"groupId\\\"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] } protected VersionUtil(); public Version version(); public static Version versionFor(Class<?> cls); public static Version packageVersionFor(Class<?> cls); private static Version doReadVersion(final Reader reader); public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId); public static Version parseVersion(String versionStr); public static Version parseVersion(String versionStr, String groupId, String artifactId); protected static int parseVersionPart(String partStr); public static final void throwInternal(); String VERSION_FILE=Optional[\\\"VERSION.txt\\\"]; String PACKAGE_VERSION_CLASS_NAME=Optional[\\\"PackageVersion\\\"]; Pattern VERSION_SEPARATOR=Optional[Pattern.compile(\\\"[-_./;:]\\\")]; Version _version"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] ch = _inputBuffer[_inputPtr] & 0xFF; [LINE] protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException { [EOL]     if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(ch, \\\"was expecting double-quote to start field name\\\"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeUtf8JsNames(); [EOL]     if (codes[ch] != 0) { [EOL]         _reportUnexpectedChar(ch, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     while (true) { [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in field name\\\"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]         if (codes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] if (_mainNames[ix] == null) { // primary empty? [LINE] private void _addSymbol(int hash, Name symbol) { [EOL]     if (_mainHashShared) { [EOL]         unshareMain(); [EOL]     } [EOL]     if (_needRehash) { [EOL]         rehash(); [EOL]     } [EOL]     ++_count; [EOL]     int ix = (hash & _mainHashMask); [EOL]     if (_mainNames[ix] == null) { [EOL]         _mainHash[ix] = (hash << 8); [EOL]         if (_mainNamesShared) { [EOL]             unshareNames(); [EOL]         } [EOL]         _mainNames[ix] = symbol; [EOL]     } else { [EOL]         if (_collListShared) { [EOL]             unshareCollision(); [EOL]         } [EOL]         ++_collCount; [EOL]         int entryValue = _mainHash[ix]; [EOL]         int bucket = entryValue & 0xFF; [EOL]         if (bucket == 0) { [EOL]             if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                 bucket = _collEnd; [EOL]                 ++_collEnd; [EOL]                 if (bucket >= _collList.length) { [EOL]                     expandCollision(); [EOL]                 } [EOL]             } else { [EOL]                 bucket = findBestBucket(); [EOL]             } [EOL]             _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL]         } else { [EOL]             --bucket; [EOL]         } [EOL]         Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]         _collList[bucket] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     { [EOL]         int hashSize = _mainHash.length; [EOL]         if (_count > (hashSize >> 1)) { [EOL]             int hashQuarter = (hashSize >> 2); [EOL]             if (_count > (hashSize - hashQuarter)) { [EOL]                 _needRehash = true; [EOL]             } else if (_collCount >= hashQuarter) { [EOL]                 _needRehash = true; [EOL]             } [EOL]         } [EOL]     } [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
{"code": "public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = \\\"123 [ 1, null, [ false ] ]\\\"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals(\\\"123 [1,null,[false]]\\\", sw.toString()); [EOL] }", "nl": "[LINE] break; [LINE] @Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError(\\\"No current event to copy\\\"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed"}
{"code": "public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\\\"\\u65e5\\u672c\\u8a9e\\\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }", "nl": "[LINE] char c; [LINE] private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] buffer[outputPtr++] = (byte) decodedData; [LINE] protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '\\\"') { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "@SuppressWarnings(\\\"resource\\\") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\\n')); [EOL]     assertEquals(-1, docStr.indexOf('\\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw(\\\"\\t\\\"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\\n')); [EOL]     assertTrue(docStr.indexOf('\\t') >= 0); [EOL]     gen.close(); [EOL] }", "nl": "[LINE] jg.writeRaw(','); [LINE] @Override [EOL] public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL] } public MinimalPrettyPrinter(); public MinimalPrettyPrinter(String rootValueSeparator); public void setRootValueSeparator(String sep); public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException; public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeArrayValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException; long serialVersionUID=Optional[-562765100295218442L]; String DEFAULT_ROOT_VALUE_SEPARATOR=Optional[\\\" \\\"]; String _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [LINE] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '\\\"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable"}
{"code": "public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }", "nl": "[LINE] int len = 10; [LINE] private static int calcLongStrLength(long posValue) { [EOL]     int len = 10; [EOL]     long comp = TEN_BILLION_L; [EOL]     while (posValue >= comp) { [EOL]         if (len == 19) { [EOL]             break; [EOL]         } [EOL]         ++len; [EOL]         comp = (comp << 3) + (comp << 1); [EOL]     } [EOL]     return len; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { \\\"0\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\" }]; String[] sSmallIntStrs2=Optional[new String[] { \\\"-1\\\", \\\"-2\\\", \\\"-3\\\", \\\"-4\\\", \\\"-5\\\", \\\"-6\\\", \\\"-7\\\", \\\"-8\\\", \\\"-9\\\", \\\"-10\\\" }]"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] public char[] getTextBuffer() [LINE] public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray"}
{"code": "public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }", "nl": "[LINE] if (Character.isJavaIdentifierPart(c)) { [LINE] protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidToken(matchStr.substring(0, i)); [EOL]             } [EOL]         } [EOL]         if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr]; [EOL]     if (c < '0' || c == ']' || c == '}') { [EOL]         return; [EOL]     } [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL]     return; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] if (_reader != null) { [LINE] @Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException(\\\"Reader returned 0 characters when trying to read \\\" + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testCRLF() throws Exception { [EOL]     _testLinefeeds(\\\"\\r\\n\\\", true); [EOL]     _testLinefeeds(\\\"\\r\\n\\\", false); [EOL] }", "nl": "[LINE] } else if (i == INT_CR) { [LINE] private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError(\\\"Unexpected end-of-input within/between \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSimple() throws Exception { [EOL]     BufferRecycler rec = new BufferRecycler(); [EOL]     IOContext ctxt = new IOContext(rec, null, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     UTF8Writer w = new UTF8Writer(ctxt, out); [EOL]     String str = \\\"AB\\u00A0\\u1AE9\\uFFFC\\\"; [EOL]     char[] ch = str.toCharArray(); [EOL]     w.write(str); [EOL]     w.append(ch[0]); [EOL]     w.write(ch[1]); [EOL]     w.write(ch, 2, 3); [EOL]     w.write(str, 0, str.length()); [EOL]     w.close(); [EOL]     byte[] data = out.toByteArray(); [EOL]     assertEquals(3 * 10, data.length); [EOL]     String act = out.toString(\\\"UTF-8\\\"); [EOL]     assertEquals(15, act.length()); [EOL]     assertEquals(3 * str.length(), act.length()); [EOL]     assertEquals(str + str + str, act); [EOL] }", "nl": "[LINE] byte[] outBuf = _outBuffer; [LINE] @Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] } public UTF8Writer(IOContext ctxt, OutputStream out); public Writer append(char c) throws IOException; public void close() throws IOException; public void flush() throws IOException; public void write(char[] cbuf) throws IOException; public void write(char[] cbuf, int off, int len) throws IOException; public void write(int c) throws IOException; public void write(String str) throws IOException; public void write(String str, int off, int len) throws IOException; protected int convertSurrogate(int secondPart) throws IOException; protected static void illegalSurrogate(int code) throws IOException; protected static String illegalSurrogateDesc(int code); int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; IOContext _context; OutputStream _out; byte[] _outBuffer; int _outBufferEnd; int _outPtr; int _surrogate=Optional[0]"}
{"code": "public void testMavenVersionParsing() { [EOL]     assertEquals(new Version(1, 2, 3, \\\"SNAPSHOT\\\", \\\"foo.bar\\\", \\\"foo-bar\\\"), VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \\\"foo.bar\\\", \\\"foo-bar\\\")); [EOL] }", "nl": "[LINE] InputStream pomPoperties = classLoader.getResourceAsStream(\\\"META-INF/maven/\\\" + groupId.replaceAll(\\\"\\\\.\\\", \\\"/\\\") [LINE] public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream(\\\"META-INF/maven/\\\" + groupId.replaceAll(\\\"\\\\.\\\", \\\"/\\\") + \\\"/\\\" + artifactId + \\\"/pom.properties\\\"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty(\\\"version\\\"); [EOL]             String pomPropertiesArtifactId = props.getProperty(\\\"artifactId\\\"); [EOL]             String pomPropertiesGroupId = props.getProperty(\\\"groupId\\\"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] } protected VersionUtil(); public Version version(); public static Version versionFor(Class<?> cls); public static Version packageVersionFor(Class<?> cls); private static Version doReadVersion(final Reader reader); public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId); public static Version parseVersion(String versionStr); public static Version parseVersion(String versionStr, String groupId, String artifactId); protected static int parseVersionPart(String partStr); public static final void throwInternal(); String VERSION_FILE=Optional[\\\"VERSION.txt\\\"]; String PACKAGE_VERSION_CLASS_NAME=Optional[\\\"PackageVersion\\\"]; Pattern VERSION_SEPARATOR=Optional[Pattern.compile(\\\"[-_./;:]\\\")]; Version _version"}
{"code": "public void testFieldValueWrites() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeNumberField(\\\"long\\\", 3L); [EOL]     gen.writeNumberField(\\\"double\\\", 0.25); [EOL]     gen.writeNumberField(\\\"float\\\", -0.25f); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     assertEquals(\\\"{\\\\\"long\\\\\":3,\\\\\"double\\\\\":0.25,\\\\\"float\\\\\":-0.25}\\\", sw.toString().trim()); [EOL] }", "nl": "[LINE] text.getChars(0, len, _outputBuffer, _outputTail); [LINE] private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape"}
{"code": "public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }", "nl": "[LINE] private void readObject(ObjectInputStream in) throws IOException { [LINE] private void readObject(ObjectInputStream in) throws IOException { [EOL]     _jdkSerializeValue = in.readUTF(); [EOL] } public SerializedString(String v); private void readObject(ObjectInputStream in) throws IOException; private void writeObject(ObjectOutputStream out) throws IOException; protected Object readResolve(); public final String getValue(); public final int charLength(); public final char[] asQuotedChars(); public final byte[] asUnquotedUTF8(); public final byte[] asQuotedUTF8(); public int appendQuotedUTF8(byte[] buffer, int offset); public int appendQuoted(char[] buffer, int offset); public int appendUnquotedUTF8(byte[] buffer, int offset); public int appendUnquoted(char[] buffer, int offset); public int writeQuotedUTF8(OutputStream out) throws IOException; public int writeUnquotedUTF8(OutputStream out) throws IOException; public int putQuotedUTF8(ByteBuffer buffer); public int putUnquotedUTF8(ByteBuffer buffer); public final String toString(); public final int hashCode(); public final boolean equals(Object o); String _value; byte[] _quotedUTF8Ref; byte[] _unquotedUTF8Ref; char[] _quotedChars; String _jdkSerializeValue"}
{"code": "public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\\\"'); [EOL]         sb2.append(\\\"\\\\\\\\\"\\\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }", "nl": "[LINE] break tight_loop; [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer"}
{"code": "public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }", "nl": "[LINE] return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(\\\" in character escape sequence\\\"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\\b'; [EOL]         case INT_t: [EOL]             return '\\t'; [EOL]         case INT_n: [EOL]             return '\\n'; [EOL]         case INT_f: [EOL]             return '\\f'; [EOL]         case INT_r: [EOL]             return '\\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\" in character escape sequence\\\"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, \\\"expected a hex-digit for character escape sequence\\\"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }", "nl": "[LINE] public String encode(byte[] input, boolean addQuotes) [LINE] public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     return sb.toString(); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength"}
{"code": "public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }", "nl": "[LINE] return addName(quads, qlen, lastQuadBytes); [LINE] private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }", "nl": "[LINE] b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [LINE] public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     return sb.toString(); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] outputPtr = 0; [LINE] protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "@SuppressWarnings(\\\"resource\\\") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(\\\" xyz foo\\\"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(\\\" and \\\\\"bar\\\\\"\\\"); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(\\\" [whatever].... \\\"); [EOL]         } else { [EOL]             sb.append(\\\" UTF-8-fu: try this {\\u00E2/\\u0BF8/\\uA123!} (look funny?)\\\"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\\r'); [EOL]             } else { [EOL]                 sb.append(\\\"\\r\\n\\\"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName(\\\"doc\\\"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes(\\\"UTF-8\\\")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(\\\"doc\\\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail(\\\"Expected length \\\" + VALUE.length() + \\\", got \\\" + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail(\\\"Long text differs\\\"); [EOL]         } [EOL]         assertEquals(\\\"doc\\\", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] cbuf[outPtr++] = (char) ch; [LINE] @Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, \\\"(above \\\" + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + \\\") \\\"); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] } public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian); public int read(char[] cbuf, int start, int len) throws IOException; private void reportUnexpectedEOF(int gotBytes, int needed) throws IOException; private void reportInvalid(int value, int offset, String msg) throws IOException; private boolean loadMore(int available) throws IOException; boolean _bigEndian; char _surrogate=Optional[NULL_CHAR]; int _charCount=Optional[0]; int _byteCount=Optional[0]; boolean _managedBuffers"}
{"code": "public void testFailedAccess() throws IOException { [EOL]     final String INPUT = \\\"Bit longer text\\\"; [EOL]     SerializableString sstr = new SerializedString(INPUT); [EOL]     final byte[] buffer = new byte[INPUT.length() - 2]; [EOL]     final char[] ch = new char[INPUT.length() - 2]; [EOL]     final ByteBuffer bbuf = ByteBuffer.allocate(INPUT.length() - 2); [EOL]     assertEquals(-1, sstr.appendQuotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendQuoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putQuotedUTF8(bbuf)); [EOL]     bbuf.rewind(); [EOL]     assertEquals(-1, sstr.appendUnquotedUTF8(buffer, 0)); [EOL]     assertEquals(-1, sstr.appendUnquoted(ch, 0)); [EOL]     assertEquals(-1, sstr.putUnquotedUTF8(bbuf)); [EOL] }", "nl": "[LINE] byte[] result = _quotedUTF8Ref; [LINE] @Override [EOL] public int appendQuotedUTF8(byte[] buffer, int offset) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] } public SerializedString(String v); private void readObject(ObjectInputStream in) throws IOException; private void writeObject(ObjectOutputStream out) throws IOException; protected Object readResolve(); public final String getValue(); public final int charLength(); public final char[] asQuotedChars(); public final byte[] asUnquotedUTF8(); public final byte[] asQuotedUTF8(); public int appendQuotedUTF8(byte[] buffer, int offset); public int appendQuoted(char[] buffer, int offset); public int appendUnquotedUTF8(byte[] buffer, int offset); public int appendUnquoted(char[] buffer, int offset); public int writeQuotedUTF8(OutputStream out) throws IOException; public int writeUnquotedUTF8(OutputStream out) throws IOException; public int putQuotedUTF8(ByteBuffer buffer); public int putUnquotedUTF8(ByteBuffer buffer); public final String toString(); public final int hashCode(); public final boolean equals(Object o); String _value; byte[] _quotedUTF8Ref; byte[] _unquotedUTF8Ref; char[] _quotedChars; String _jdkSerializeValue"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] int ch = _inputBuffer[ptr]; [LINE] @Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '\\\"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testEscapeCustomWithUTF8Stream() throws Exception { [EOL]     _testEscapeCustom(true); [EOL] }", "nl": "[LINE] return this; [LINE] @Override [EOL] public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { [EOL]     _characterEscapes = esc; [EOL]     if (esc == null) { [EOL]         _outputEscapes = sOutputEscapes; [EOL]     } else { [EOL]         _outputEscapes = esc.getEscapeCodesForAscii(); [EOL]     } [EOL]     return this; [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]"}
{"code": "public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }", "nl": "[LINE] if (_inputPtr >= _inputEnd) { [LINE] private int _skipColon() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++]; [EOL]     if (i == INT_COLON) { [EOL]         if (_inputPtr < _inputEnd) { [EOL]             i = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (i > INT_SPACE && i != INT_SLASH) { [EOL]                 ++_inputPtr; [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         i &= 0xFF; [EOL]         space_loop: while (true) { [EOL]             switch(i) { [EOL]                 case INT_SPACE: [EOL]                 case INT_TAB: [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_SLASH: [EOL]                     _skipComment(); [EOL]                     break; [EOL]                 default: [EOL]                     if (i < INT_SPACE) { [EOL]                         _throwInvalidSpace(i); [EOL]                     } [EOL]                     break space_loop; [EOL]             } [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting a colon to separate field name and value\\\"); [EOL]         } [EOL]     } [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError(\\\"Unexpected end-of-input within/between \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] return null; [LINE] public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] IOContext ctxt = _createContext(in, false); [LINE] public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional[\\\"JSON\\\"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]"}
{"code": "@SuppressWarnings(\\\"resource\\\") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = \\\"[ 1, 2, 3 ]\\\"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, \\\"UTF-8\\\") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }", "nl": "[LINE] case INT_LBRACKET: [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, \\\"expected a value\\\"); [EOL]         case INT_t: [EOL]             _matchToken(\\\"true\\\", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken(\\\"false\\\", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken(\\\"null\\\", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }", "nl": "[LINE] sb = new StringBuilder(outputLen); [LINE] public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     return sb.toString(); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength"}
{"code": "public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals(\\\"[1,-2,3,-4,0.25,-0.125,true]\\\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\\\"[1234,0.5]\\\", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals(\\\"[false,13,-127]\\\", act); [EOL] }", "nl": "[LINE] return; [LINE] protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]         return; [EOL]     } [EOL]     if (value instanceof String) { [EOL]         writeString((String) value); [EOL]         return; [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         Number n = (Number) value; [EOL]         if (n instanceof Integer) { [EOL]             writeNumber(n.intValue()); [EOL]             return; [EOL]         } else if (n instanceof Long) { [EOL]             writeNumber(n.longValue()); [EOL]             return; [EOL]         } else if (n instanceof Double) { [EOL]             writeNumber(n.doubleValue()); [EOL]             return; [EOL]         } else if (n instanceof Float) { [EOL]             writeNumber(n.floatValue()); [EOL]             return; [EOL]         } else if (n instanceof Short) { [EOL]             writeNumber(n.shortValue()); [EOL]             return; [EOL]         } else if (n instanceof Byte) { [EOL]             writeNumber(n.byteValue()); [EOL]             return; [EOL]         } else if (n instanceof BigInteger) { [EOL]             writeNumber((BigInteger) n); [EOL]             return; [EOL]         } else if (n instanceof BigDecimal) { [EOL]             writeNumber((BigDecimal) n); [EOL]             return; [EOL]         } else if (n instanceof AtomicInteger) { [EOL]             writeNumber(((AtomicInteger) n).get()); [EOL]             return; [EOL]         } else if (n instanceof AtomicLong) { [EOL]             writeNumber(((AtomicLong) n).get()); [EOL]             return; [EOL]         } [EOL]     } else if (value instanceof byte[]) { [EOL]         writeBinary((byte[]) value); [EOL]         return; [EOL]     } else if (value instanceof Boolean) { [EOL]         writeBoolean((Boolean) value); [EOL]         return; [EOL]     } else if (value instanceof AtomicBoolean) { [EOL]         writeBoolean(((AtomicBoolean) value).get()); [EOL]         return; [EOL]     } [EOL]     throw new IllegalStateException(\\\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \\\" + value.getClass().getName() + \\\")\\\"); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed"}
{"code": "public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }", "nl": "[LINE] if (_inputBuffer[end] == INT_QUOTE) { [LINE] @Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }", "nl": "[LINE] return false; [LINE] private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4(\\\"3412\\\"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4(\\\"2143\\\"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] _sizeThreshold = child._sizeThreshold; [LINE] private void mergeChild(CharsToNameCanonicalizer child) { [EOL]     if (child.size() > MAX_ENTRIES_FOR_REUSE || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         synchronized (this) { [EOL]             initTables(DEFAULT_TABLE_SIZE); [EOL]             _dirty = false; [EOL]         } [EOL]     } else { [EOL]         if (child.size() <= size()) { [EOL]             return; [EOL]         } [EOL]         synchronized (this) { [EOL]             _symbols = child._symbols; [EOL]             _buckets = child._buckets; [EOL]             _size = child._size; [EOL]             _sizeThreshold = child._sizeThreshold; [EOL]             _indexMask = child._indexMask; [EOL]             _longestCollisionList = child._longestCollisionList; [EOL]             _dirty = false; [EOL]         } [EOL]     } [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] bits = b64variant.decodeBase64Char(ch); [LINE] protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }", "nl": "[LINE] int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 [LINE] public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('\\\"'); [EOL]     } [EOL]     return sb.toString(); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] if (_inputPtr >= _inputEnd) { [LINE] private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(\\\": was expecting closing '\\\" + ((char) endChar) + \\\"' for name\\\"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, \\\"name\\\"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }", "nl": "[LINE] if (value == Long.MIN_VALUE) { [LINE] public static int outputLong(long value, char[] buffer, int offset) { [EOL]     if (value < 0L) { [EOL]         if (value > MIN_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]         if (value == Long.MIN_VALUE) { [EOL]             int len = SMALLEST_LONG.length(); [EOL]             SMALLEST_LONG.getChars(0, len, buffer, offset); [EOL]             return (offset + len); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } else { [EOL]         if (value <= MAX_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]     } [EOL]     int origOffset = offset; [EOL]     offset += calcLongStrLength(value); [EOL]     int ptr = offset; [EOL]     while (value > MAX_INT_AS_LONG) { [EOL]         ptr -= 3; [EOL]         long newValue = value / THOUSAND_L; [EOL]         int triplet = (int) (value - newValue * THOUSAND_L); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         value = newValue; [EOL]     } [EOL]     int ivalue = (int) value; [EOL]     while (ivalue >= 1000) { [EOL]         ptr -= 3; [EOL]         int newValue = ivalue / 1000; [EOL]         int triplet = ivalue - (newValue * 1000); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         ivalue = newValue; [EOL]     } [EOL]     outputLeadingTriplet(ivalue, buffer, origOffset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { \\\"0\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\", \\\"10\\\" }]; String[] sSmallIntStrs2=Optional[new String[] { \\\"-1\\\", \\\"-2\\\", \\\"-3\\\", \\\"-4\\\", \\\"-5\\\", \\\"-6\\\", \\\"-7\\\", \\\"-8\\\", \\\"-9\\\", \\\"-10\\\" }]"}
{"code": "public void testAsInt() throws Exception { [EOL]     final String input = \\\"[ 1, -3, 4.98, true, false, null, \\\\\"-17\\\\\", \\\\\"foo\\\\\" ]\\\"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, \\\"UTF-8\\\"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         jp.close(); [EOL]     } [EOL] }", "nl": "[LINE] return 0; [LINE] @Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\\t']; int INT_LF=Optional['\\n']; int INT_CR=Optional['\\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['\\\"']; int INT_BACKSLASH=Optional['\\\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken"}
{"code": "public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }", "nl": "[LINE] if (i < INT_SPACE) { [LINE] private int _skipColon() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++]; [EOL]     if (i == INT_COLON) { [EOL]         if (_inputPtr < _inputEnd) { [EOL]             i = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (i > INT_SPACE && i != INT_SLASH) { [EOL]                 ++_inputPtr; [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         i &= 0xFF; [EOL]         space_loop: while (true) { [EOL]             switch(i) { [EOL]                 case INT_SPACE: [EOL]                 case INT_TAB: [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_SLASH: [EOL]                     _skipComment(); [EOL]                     break; [EOL]                 default: [EOL]                     if (i < INT_SPACE) { [EOL]                         _throwInvalidSpace(i); [EOL]                     } [EOL]                     break space_loop; [EOL]             } [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, \\\"was expecting a colon to separate field name and value\\\"); [EOL]         } [EOL]     } [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError(\\\"Unexpected end-of-input within/between \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testSyntheticWithBytes() throws IOException { [EOL]     BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true); [EOL]     final int COUNT = 6000; [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         String id = fieldNameFor(i); [EOL]         int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\\\"UTF-8\\\")); [EOL]         symbols.addName(id, quads, quads.length); [EOL]     } [EOL]     assertEquals(COUNT, symbols.size()); [EOL]     assertEquals(8192, symbols.bucketCount()); [EOL]     assertEquals(1686, symbols.collisionCount()); [EOL]     assertEquals(9, symbols.maxCollisionLength()); [EOL] }", "nl": "[LINE] public int bucketCount() { return _mainHash.length; } [LINE] public int bucketCount() { [EOL]     return _mainHash.length; [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
{"code": "public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }", "nl": "[LINE] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [LINE] @SuppressWarnings(\\\"resource\\\") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '\\\"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }", "nl": "[LINE] if (!_arrayIndenter.isInline()) { [LINE] @Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfValues > 0) { [EOL]         _arrayIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw(']'); [EOL] } public DefaultPrettyPrinter(); public DefaultPrettyPrinter(String rootSeparator); public DefaultPrettyPrinter(SerializableString rootSeparator); public DefaultPrettyPrinter(DefaultPrettyPrinter base); public DefaultPrettyPrinter(DefaultPrettyPrinter base, SerializableString rootSeparator); public Lf2SpacesIndenter(); public Lf2SpacesIndenter(String lf);  void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException;  boolean isInline(); public DefaultPrettyPrinter withRootSeparator(SerializableString rootSeparator); public void indentArraysWith(Indenter i); public void indentObjectsWith(Indenter i); public void spacesInObjectEntries(boolean b); public DefaultPrettyPrinter withArrayIndenter(Indenter i); public DefaultPrettyPrinter withObjectIndenter(Indenter i); public DefaultPrettyPrinter withSpacesInObjectEntries(); public DefaultPrettyPrinter withoutSpacesInObjectEntries(); protected DefaultPrettyPrinter _withSpaces(boolean state); public DefaultPrettyPrinter createInstance(); public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException; public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException; public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeArrayValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException; public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException; public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException; public boolean isInline(); public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException; public boolean isInline(); public Lf2SpacesIndenter withLinefeed(String lf); public boolean isInline(); public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException; long serialVersionUID=Optional[-5512586643324525213L]; SerializedString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[new SerializedString(\\\" \\\")]; Indenter _arrayIndenter=Optional[FixedSpaceIndenter.instance]; Indenter _objectIndenter=Optional[Lf2SpacesIndenter.instance]; SerializableString _rootSeparator; boolean _spacesInObjectEntries=Optional[true]; int _nesting=Optional[0]"}
{"code": "public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }", "nl": "[LINE] if (_byteArrayBuilder == null) { [LINE] public ByteArrayBuilder _getByteArrayBuilder() { [EOL]     if (_byteArrayBuilder == null) { [EOL]         _byteArrayBuilder = new ByteArrayBuilder(); [EOL]     } else { [EOL]         _byteArrayBuilder.reset(); [EOL]     } [EOL]     return _byteArrayBuilder; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }", "nl": "[LINE] if (_inputPtr >= _inputEnd) { [LINE] protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '\\\"') { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '\\\"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser(\\\"[ 1, true ]\\\"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals(\\\"[\\\", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }", "nl": "[LINE] return new char[size]; [LINE] private char[] calloc(int size) { [EOL]     return new char[size]; [EOL] }  ByteBufferType(int size);  CharBufferType(int size); public BufferRecycler(); public final byte[] allocByteBuffer(ByteBufferType type); public final void releaseByteBuffer(ByteBufferType type, byte[] buffer); public final char[] allocCharBuffer(CharBufferType type); public final char[] allocCharBuffer(CharBufferType type, int minSize); public final void releaseCharBuffer(CharBufferType type, char[] buffer); private byte[] balloc(int size); private char[] calloc(int size); int DEFAULT_WRITE_CONCAT_BUFFER_LEN=Optional[2000]; byte[][] _byteBuffers=Optional[new byte[ByteBufferType.values().length][]]; char[][] _charBuffers=Optional[new char[CharBufferType.values().length][]]"}
{"code": "public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }", "nl": "[LINE] return parseLongFieldName(i); [LINE] protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(\\\"[ \\\\\"abc\\\\\" ]\\\"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail(\\\"Expected error trying to call getIntValue on non-numeric value\\\"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \\\"can not use numeric value accessors\\\"); [EOL]     } [EOL]     jp.close(); [EOL] }", "nl": "[LINE] if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError(\\\"Current token (\\\" + _currToken + \\\") not numeric, can not use numeric value accessors\\\"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength"}
{"code": "public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }", "nl": "[LINE] firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [LINE] protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, \\\"was expecting double-quote to start field name\\\"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }", "nl": "[LINE] case FIELD_NAME: [LINE] @Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]"}
{"code": "public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }", "nl": "[LINE] flags |= f.getMask(); [LINE] public static int collectDefaults() { [EOL]     int flags = 0; [EOL]     for (Feature f : values()) { [EOL]         if (f.enabledByDefault()) { [EOL]             flags |= f.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] } private Feature(boolean defaultState); protected JsonGenerator(); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); public abstract Version version(); public Object getOutputTarget(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state); public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); public abstract JsonGenerator setFeatureMask(int mask); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public JsonGenerator setPrettyPrinter(PrettyPrinter pp); public PrettyPrinter getPrettyPrinter(); public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public JsonGenerator setRootValueSeparator(SerializableString sep); public boolean canUseSchema(FormatSchema schema); public boolean canWriteObjectId(); public boolean canWriteTypeId(); public boolean canOmitFields(); public abstract void writeStartArray() throws IOException, JsonGenerationException; public abstract void writeEndArray() throws IOException, JsonGenerationException; public abstract void writeStartObject() throws IOException, JsonGenerationException; public abstract void writeEndObject() throws IOException, JsonGenerationException; public abstract void writeFieldName(String name) throws IOException, JsonGenerationException; public abstract void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public abstract void writeString(String text) throws IOException, JsonGenerationException; public abstract void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeString(SerializableString text) throws IOException, JsonGenerationException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeRaw(String text) throws IOException, JsonGenerationException; public abstract void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data) throws IOException, JsonGenerationException; public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException; public abstract int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short v) throws IOException, JsonGenerationException; public abstract void writeNumber(int v) throws IOException, JsonGenerationException; public abstract void writeNumber(long v) throws IOException, JsonGenerationException; public abstract void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public abstract void writeNumber(double d) throws IOException, JsonGenerationException; public abstract void writeNumber(float f) throws IOException, JsonGenerationException; public abstract void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public abstract void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException; public abstract void writeBoolean(boolean state) throws IOException, JsonGenerationException; public abstract void writeNull() throws IOException, JsonGenerationException; public void writeObjectId(Object id) throws IOException, JsonGenerationException; public void writeObjectRef(Object id) throws IOException, JsonGenerationException; public void writeTypeId(Object id) throws IOException, JsonGenerationException; public abstract void writeObject(Object pojo) throws IOException, JsonProcessingException; public abstract void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; public final void writeBooleanField(String fieldName, boolean value) throws IOException, JsonGenerationException; public final void writeNullField(String fieldName) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException; public final void writeBinaryField(String fieldName, byte[] data) throws IOException, JsonGenerationException; public final void writeArrayFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException; public void writeOmittedField(String fieldName) throws IOException, JsonGenerationException; public abstract void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public abstract void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; public abstract JsonStreamContext getOutputContext(); public abstract void flush() throws IOException; public abstract boolean isClosed(); public abstract void close() throws IOException; PrettyPrinter _cfgPrettyPrinter"}
{"code": "public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append(\\\"\\u65e5\\u672c\\u8a9e\\\"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }", "nl": "[LINE] if (ptr > 5 && ptr < end) { // fits, prepend to buffer [LINE] private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape"}
{"code": "public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }", "nl": "[LINE] sb.append(msg); [LINE] @Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = \\\"N/A\\\"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\\n'); [EOL]             sb.append(\\\" at \\\"); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] } protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause); protected JsonProcessingException(String msg); protected JsonProcessingException(String msg, JsonLocation loc); protected JsonProcessingException(String msg, Throwable rootCause); protected JsonProcessingException(Throwable rootCause); public JsonLocation getLocation(); public String getOriginalMessage(); protected String getMessageSuffix(); public String getMessage(); public String toString(); long serialVersionUID=Optional[123]; JsonLocation _location"}
{"code": "public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }", "nl": "[LINE] super._releaseBuffers(); [LINE] @Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     if (_bufferRecyclable) { [EOL]         byte[] buf = _inputBuffer; [EOL]         if (buf != null) { [EOL]             _inputBuffer = null; [EOL]             _ioContext.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable"}
{"code": "public void testReaderParser() throws Exception { [EOL]     _testWith(false); [EOL] }", "nl": "[LINE] _sizeThreshold = _thresholdSize(newSize); [LINE] private void rehash() { [EOL]     int size = _symbols.length; [EOL]     int newSize = size + size; [EOL]     if (newSize > MAX_TABLE_SIZE) { [EOL]         _size = 0; [EOL]         Arrays.fill(_symbols, null); [EOL]         Arrays.fill(_buckets, null); [EOL]         _dirty = true; [EOL]         return; [EOL]     } [EOL]     String[] oldSyms = _symbols; [EOL]     Bucket[] oldBuckets = _buckets; [EOL]     _symbols = new String[newSize]; [EOL]     _buckets = new Bucket[newSize >> 1]; [EOL]     _indexMask = newSize - 1; [EOL]     _sizeThreshold = _thresholdSize(newSize); [EOL]     int count = 0; [EOL]     int maxColl = 0; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         String symbol = oldSyms[i]; [EOL]         if (symbol != null) { [EOL]             ++count; [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     size >>= 1; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         Bucket b = oldBuckets[i]; [EOL]         while (b != null) { [EOL]             ++count; [EOL]             String symbol = b.getSymbol(); [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]             b = b.getNext(); [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (count != _size) { [EOL]         throw new Error(\\\"Internal error on SymbolTable.rehash(): had \\\" + _size + \\\" entries; now have \\\" + count + \\\".\\\"); [EOL]     } [EOL] } private CharsToNameCanonicalizer(); private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl); public Bucket(String symbol, Bucket next); public static CharsToNameCanonicalizer createRoot(); protected static CharsToNameCanonicalizer createRoot(int hashSeed); private void initTables(int initialSize); private static int _thresholdSize(int hashAreaSize); public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern); private CharsToNameCanonicalizer makeOrphan(int seed); private void mergeChild(CharsToNameCanonicalizer child); public void release(); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public String findSymbol(char[] buffer, int start, int len, int h); public int _hashToIndex(int rawHash); public int calcHash(char[] buffer, int start, int len); public int calcHash(String key); private void copyArrays(); private void rehash(); protected void reportTooManyCollisions(int maxLen); public String getSymbol(); public Bucket getNext(); public int length(); public String find(char[] buf, int start, int len); int HASH_MULT=Optional[33]; int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[12000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; CharsToNameCanonicalizer sBootstrapSymbolTable; CharsToNameCanonicalizer _parent; int _hashSeed; boolean _intern; boolean _canonicalize; String[] _symbols; Bucket[] _buckets; int _size; int _sizeThreshold; int _indexMask; int _longestCollisionList; boolean _dirty"}
{"code": "public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('\\\"'); [EOL]         sb2.append(\\\"\\\\\\\\\"\\\"); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }", "nl": "[LINE] char d = input.charAt(inPtr++); [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer"}
{"code": "public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = \\\"\\\\\"JSON!\\\\\"\\\"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\\\"UTF-8\\\"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals(\\\"JSON\\\", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals(\\\"JSON!\\\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }", "nl": "[LINE] if (count <= 0) { // EOF [LINE] @Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] } public Std(InputStream in, byte[] buffer); public Std(byte[] inputDocument); public Std(byte[] inputDocument, int start, int len);  boolean hasMoreBytes() throws IOException;  byte nextByte() throws IOException;  void reset(); public boolean hasMoreBytes() throws IOException; public byte nextByte() throws IOException; public void reset(); public DataFormatMatcher createMatcher(JsonFactory match, MatchStrength matchStrength)"}
{"code": "public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = \\\"{ \\\\\"a\\\\\" : 1, \\\\\"x\\\\\" : [ ] }\\\"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }", "nl": "[LINE] int symbolsSeen = 0; // let's do a sanity check [LINE] private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException(\\\"Internal error: count after rehash \\\" + symbolsSeen + \\\"; should be \\\" + _count); [EOL]     } [EOL] } private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed); private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state); public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList); public TableInfo(BytesToNameCanonicalizer src);  Bucket(Name name, Bucket next); private TableInfo initTableInfo(int hashSize); public static BytesToNameCanonicalizer createRoot(); protected static BytesToNameCanonicalizer createRoot(int hashSeed); public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern); public void release(); private void mergeChild(TableInfo childState); public int size(); public int bucketCount(); public boolean maybeDirty(); public int hashSeed(); public int collisionCount(); public int maxCollisionLength(); public static Name getEmptyName(); public Name findName(int firstQuad); public Name findName(int firstQuad, int secondQuad); public Name findName(int[] quads, int qlen); public Name addName(String symbolStr, int q1, int q2); public Name addName(String symbolStr, int[] quads, int qlen); public int calcHash(int firstQuad); public int calcHash(int firstQuad, int secondQuad); public int calcHash(int[] quads, int qlen); protected static int[] calcQuads(byte[] wordBytes); private void _addSymbol(int hash, Name symbol); private void rehash(); private void nukeSymbols(); private int findBestBucket(); private void unshareMain(); private void unshareCollision(); private void unshareNames(); private void expandCollision(); private static Name constructName(int hash, String name, int q1, int q2); private static Name constructName(int hash, String name, int[] quads, int qlen); protected void reportTooManyCollisions(int maxLen); public int length(); public Name find(int hash, int firstQuad, int secondQuad); public Name find(int hash, int[] quads, int qlen); int DEFAULT_TABLE_SIZE=Optional[64]; int MAX_TABLE_SIZE=Optional[0x10000]; int MAX_ENTRIES_FOR_REUSE=Optional[6000]; int MAX_COLL_CHAIN_LENGTH=Optional[255]; int MAX_COLL_CHAIN_FOR_REUSE=Optional[63]; int MIN_HASH_SIZE=Optional[16]; int INITIAL_COLLISION_LEN=Optional[32]; int LAST_VALID_BUCKET=Optional[0xFE]; BytesToNameCanonicalizer _parent; AtomicReference<TableInfo> _tableInfo; int _hashSeed; boolean _intern; int _count; int _longestCollisionList; int _mainHashMask; int[] _mainHash; Name[] _mainNames; Bucket[] _collList; int _collCount; int _collEnd; boolean _needRehash; boolean _mainHashShared; boolean _mainNamesShared; boolean _collListShared; int MULT=Optional[33]; int MULT2=Optional[65599]; int MULT3=Optional[31]"}
