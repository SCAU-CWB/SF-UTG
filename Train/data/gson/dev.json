{"code": "public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = \\\"'Dec 3, 2009'\\\"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }", "nl": "[LINE] public java.sql.Date deserialize(JsonElement json, Type typeOfT, [LINE] public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException(\\\"The date should be a string value\\\"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new java.sql.Date(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]"}
{"code": "public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }", "nl": "[LINE] public boolean shouldSkipField(FieldAttributes f) { [LINE] public boolean shouldSkipField(FieldAttributes f) { [EOL]     return skipSyntheticFields && f.isSynthetic(); [EOL] }  SyntheticFieldExclusionStrategy(boolean skipSyntheticFields); public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f); boolean skipSyntheticFields"}
{"code": "public void testLenientNameValueSeparator() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"{\\\\\"a\\\\\"=true}\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals(\\\"a\\\", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader(\\\"{\\\\\"a\\\\\"=>true}\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals(\\\"a\\\", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }", "nl": "[LINE] pos++; [LINE] private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError(\\\"Expected ':'\\\"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy(\\\"-\\\"); [EOL]     String translatedName = namingPolicy.translateName(\\\"testUsingDashesInstead\\\", CLASS, null); [EOL]     assertEquals(\\\"test-using-dashes-instead\\\", translatedName); [EOL] }", "nl": "[LINE] this.fieldPolicies = fieldNamingPolicies; [LINE] public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies) { [EOL]     if (fieldNamingPolicies == null) { [EOL]         throw new NullPointerException(\\\"naming policies can not be null.\\\"); [EOL]     } [EOL]     this.fieldPolicies = fieldNamingPolicies; [EOL] } public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies); protected String translateName(String target, Type fieldType, Collection<Annotation> annotations); RecursiveFieldNamingPolicy[] fieldPolicies"}
{"code": "public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = \\\"[1,'abc',[1,2],5]\\\"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail(\\\"This is crazy....how did we deserialize it!!!\\\"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }", "nl": "[LINE] case NUMBER: [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)"}
{"code": "public void testNumberSerialization() { [EOL]     Number expected = 1L; [EOL]     String json = gson.toJson(expected); [EOL]     assertEquals(expected.toString(), json); [EOL]     json = gson.toJson(expected, Number.class); [EOL]     assertEquals(expected.toString(), json); [EOL] }", "nl": "[LINE] public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [LINE] public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]"}
{"code": "public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals(\\\"[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]\\\", stringWriter.toString()); [EOL] }", "nl": "[LINE] replaceTop(JsonScope.NONEMPTY_DOCUMENT); [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException(\\\"JSON must start with an array or an object.\\\"); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException(\\\"JSON must have only one top-level value.\\\"); [EOL]         default: [EOL]             throw new IllegalStateException(\\\"Nesting problem: \\\" + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[\\\":\\\"]; boolean lenient; boolean htmlSafe"}
{"code": "public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"[true;true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }", "nl": "[LINE] if (value == null || token == JsonToken.STRING) { [LINE] public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException(\\\"Expected a boolean but was \\\" + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase(\\\"true\\\")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase(\\\"false\\\")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException(\\\"Not a boolean: \\\" + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testAddingBooleanProperties() throws Exception { [EOL]     String propertyName = \\\"property\\\"; [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     jsonObj.addProperty(propertyName, true); [EOL]     assertTrue(jsonObj.has(propertyName)); [EOL]     JsonElement jsonElement = jsonObj.get(propertyName); [EOL]     assertNotNull(jsonElement); [EOL]     assertTrue(jsonElement.getAsBoolean()); [EOL] }", "nl": "[LINE] private JsonElement createJsonElement(Object value) { [LINE] private JsonElement createJsonElement(Object value) { [EOL]     return value == null ? JsonNull.createJsonNull() : new JsonPrimitive(value); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members"}
{"code": "public void testDoubles() throws IOException { [EOL]     String json = \\\"[-0.0,\\\" + \\\"1.0,\\\" + \\\"1.7976931348623157E308,\\\" + \\\"4.9E-324,\\\" + \\\"0.0,\\\" + \\\"-0.5,\\\" + \\\"2.2250738585072014E-308,\\\" + \\\"3.141592653589793,\\\" + \\\"2.718281828459045]\\\"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }", "nl": "[LINE] try { [LINE] private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError(\\\"Expected JSON document to start with '[' or '{'\\\"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError(\\\"Expected EOF\\\"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException(\\\"JsonReader is closed\\\"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar(\\\"someString\\\", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put(\\\"key1\\\", arrayList); [EOL]     bar1.map.put(\\\"key2\\\", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }", "nl": "[LINE] } else if (typeToEvaluate instanceof TypeVariable<?>) { [LINE] private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException(\\\"Expecting parameterized type, got \\\" + parentType + \\\".\\n Are you missing the use of TypeToken idiom?\\n See \\\" + \\\"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\\\"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException(\\\"Type \\'\\\" + typeToEvaluate + \\\"\\' is not a Class, \\\" + \\\"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\\\"); [EOL]     } [EOL] } private TypeInfoFactory(); public static TypeInfoArray getTypeInfoForArray(Type type); public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF); private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass); private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate); private static Type[] extractRealTypes(Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass); private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type)"}
{"code": "public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(\\\"Some\\nEscaped\\nValue\\\"); [EOL]     assertEquals(\\\"\\\\\"Some\\\\nEscaped\\\\nValue\\\\\"\\\", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal(\\\"1.333\\\")); [EOL]     assertEquals(\\\"1.333\\\", json.toString()); [EOL] }", "nl": "[LINE] @Override [LINE] @Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     if (isString()) { [EOL]         sb.append('\\\"'); [EOL]         sb.append(escaper.escapeJsonString(value.toString())); [EOL]         sb.append('\\\"'); [EOL]     } else { [EOL]         sb.append(value.toString()); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value"}
{"code": "public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, \\\"one\\\"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \\\"two\\\"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals(\\\"one\\\", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals(\\\"two\\\", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }", "nl": "[LINE] Object object = fromJson(json, (Type) classOfT); [LINE] public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional[\\\"null\\\"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[\\\")]}'\\n\\\"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting"}
{"code": "public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name(\\\"a\\\"); [EOL]     try { [EOL]         jsonWriter.name(\\\"a\\\"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }", "nl": "[LINE] switch (c) { [LINE] private void string(String value) throws IOException { [EOL]     out.write(\\\"\\\\\"\\\"); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\\\"': [EOL]             case '\\\\': [EOL]                 out.write('\\\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\\t': [EOL]                 out.write(\\\"\\\\t\\\"); [EOL]                 break; [EOL]             case '\\b': [EOL]                 out.write(\\\"\\\\b\\\"); [EOL]                 break; [EOL]             case '\\n': [EOL]                 out.write(\\\"\\\\n\\\"); [EOL]                 break; [EOL]             case '\\r': [EOL]                 out.write(\\\"\\\\r\\\"); [EOL]                 break; [EOL]             case '\\f': [EOL]                 out.write(\\\"\\\\f\\\"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format(\\\"\\\\u%04x\\\", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format(\\\"\\\\u%04x\\\", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write(\\\"\\\\\"\\\"); [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[\\\":\\\"]; boolean lenient; boolean htmlSafe"}
{"code": "public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name(\\\"a\\\"); [EOL]     try { [EOL]         jsonWriter.name(\\\"a\\\"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }", "nl": "[LINE] char c = value.charAt(i); [LINE] private void string(String value) throws IOException { [EOL]     out.write(\\\"\\\\\"\\\"); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\\\"': [EOL]             case '\\\\': [EOL]                 out.write('\\\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\\t': [EOL]                 out.write(\\\"\\\\t\\\"); [EOL]                 break; [EOL]             case '\\b': [EOL]                 out.write(\\\"\\\\b\\\"); [EOL]                 break; [EOL]             case '\\n': [EOL]                 out.write(\\\"\\\\n\\\"); [EOL]                 break; [EOL]             case '\\r': [EOL]                 out.write(\\\"\\\\r\\\"); [EOL]                 break; [EOL]             case '\\f': [EOL]                 out.write(\\\"\\\\f\\\"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format(\\\"\\\\u%04x\\\", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format(\\\"\\\\u%04x\\\", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write(\\\"\\\\\"\\\"); [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[\\\":\\\"]; boolean lenient; boolean htmlSafe"}
{"code": "public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = \\\"{\\\\\"list\\\\\":[0,1,2,3],\\\\\"queue\\\\\":[0,1,2,3],\\\\\"set\\\\\":[0.1,0.2,0.3,0.4],\\\" + \\\"\\\\\"sortedSet\\\\\":[\\\\\"a\\\\\",\\\\\"b\\\\\",\\\\\"c\\\\\",\\\\\"d\\\\\"]\\\" + \\\"}\\\"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }", "nl": "[LINE] TypeInfo rawType = new TypeInfo(collectionType); [LINE] public TypeInfoCollection(Type collectionType) { [EOL]     if (!(collectionType instanceof ParameterizedType)) { [EOL]         throw new IllegalArgumentException(\\\"Collection objects need to be parameterized unless you use a custom serializer. \\\" + \\\"Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType.\\\"); [EOL]     } [EOL]     TypeInfo rawType = new TypeInfo(collectionType); [EOL]     Preconditions.checkArgument(Collection.class.isAssignableFrom(rawType.getRawClass())); [EOL]     this.collectionType = (ParameterizedType) collectionType; [EOL] } public TypeInfoCollection(Type collectionType); public Type getElementType(); ParameterizedType collectionType"}
{"code": "public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }", "nl": "[LINE] return new JsonDeserializerExceptionWrapper(deserializer); [LINE] @SuppressWarnings({ \\\"unchecked\\\", \\\"rawtypes\\\" }) [EOL] private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return new JsonDeserializerExceptionWrapper(deserializer); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]"}
{"code": "public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals(\\\"one\\\", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals(\\\"two\\\", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }", "nl": "[LINE] try { [LINE] public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException(\\\"Failed parsing JSON source to Json\\\", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException(\\\"Failed parsing JSON source to Json\\\", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] } public JsonStreamParser(String json); public JsonStreamParser(Reader reader); public JsonElement next() throws JsonParseException; public boolean hasNext(); public void remove(); JsonReader parser; Object lock"}
{"code": "public void testNullsInArraySerialization() { [EOL]     String[] array = { \\\"foo\\\", null, \\\"bar\\\" }; [EOL]     String expected = \\\"[\\\\\"foo\\\\\",null,\\\\\"bar\\\\\"]\\\"; [EOL]     String json = gson.toJson(array); [EOL]     assertEquals(expected, json); [EOL] }", "nl": "[LINE] root.getAsJsonArray().add(JsonNull.createJsonNull()); [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root"}
{"code": "public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name(\\\"a\\\"); [EOL]     try { [EOL]         jsonWriter.name(\\\"a\\\"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }", "nl": "[LINE] public JsonWriter name(String name) throws IOException { [LINE] public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException(\\\"name == null\\\"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[\\\":\\\"]; boolean lenient; boolean htmlSafe"}
{"code": "public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"[true,,true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader(\\\"[,true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader(\\\"[true,]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader(\\\"[,]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }", "nl": "[LINE] System.arraycopy(buffer, pos, buffer, 0, limit); [LINE] private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = \\\"{\\\\\"list\\\\\":[0,1,2,3],\\\\\"queue\\\\\":[0,1,2,3],\\\\\"set\\\\\":[0.1,0.2,0.3,0.4],\\\" + \\\"\\\\\"sortedSet\\\\\":[\\\\\"a\\\\\",\\\\\"b\\\\\",\\\\\"c\\\\\",\\\\\"d\\\\\"]\\\" + \\\"}\\\"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }", "nl": "[LINE] public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [LINE] public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException(\\\"Expecting object found: \\\" + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)"}
{"code": "public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }", "nl": "[LINE] map.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [LINE] private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() { [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>(); [EOL]     map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER)); [EOL]     map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER)); [EOL]     map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER)); [EOL]     map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER)); [EOL]     map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER)); [EOL]     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER)); [EOL]     map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER)); [EOL]     map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER)); [EOL]     map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER)); [EOL]     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER)); [EOL]     map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER)); [EOL]     map.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER)); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]"}
{"code": "public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }", "nl": "[LINE] return true; [LINE] public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root"}
{"code": "public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = \\\"{\\\\\"Some Constant String Instance Field\\\\\":\\\\\"someValue\\\\\"}\\\"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals(\\\"someValue\\\", deserializedObject.someConstantStringInstanceField); [EOL] }", "nl": "[LINE] private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) { [LINE] private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) { [EOL]     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional[\\\"null\\\"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[\\\")]}'\\n\\\"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting"}
{"code": "public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, \\\"one\\\"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \\\"two\\\"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals(\\\"one\\\", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals(\\\"two\\\", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }", "nl": "[LINE] parser = new JsonReader(reader); [LINE] public JsonStreamParser(Reader reader) { [EOL]     parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     lock = new Object(); [EOL] } public JsonStreamParser(String json); public JsonStreamParser(Reader reader); public JsonElement next() throws JsonParseException; public boolean hasNext(); public void remove(); JsonReader parser; Object lock"}
{"code": "public void testName() throws Exception { [EOL]     assertEquals(\\\"bar\\\", fieldAttributes.getName()); [EOL] }", "nl": "[LINE] public String getName() { [LINE] public String getName() { [EOL]     return name; [EOL] }  FieldAttributes(final Class<?> declaringClazz, final Field f); private static int getMaxCacheSize(); public Class<?> getDeclaringClass(); public String getName(); public Type getDeclaredType(); public Class<?> getDeclaredClass(); public T getAnnotation(Class<T> annotation); public Collection<Annotation> getAnnotations(); public boolean hasModifier(int modifier);  void set(Object instance, Object value) throws IllegalAccessException;  Object get(Object instance) throws IllegalAccessException;  boolean isSynthetic();  Field getFieldObject(); private static T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation); String MAX_CACHE_PROPERTY_NAME=Optional[\\\"com.google.gson.annotation_cache_size_hint\\\"]; Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE=Optional[new LruCache<Pair<Class<?>, String>, Collection<Annotation>>(getMaxCacheSize())]; Class<?> declaringClazz; Field field; Class<?> declaredType; boolean isSynthetic; int modifiers; String name; Type genericType; Collection<Annotation> annotations"}
{"code": "public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }", "nl": "[LINE] TypeInfoArray(Type type) { [LINE] TypeInfoArray(Type type) { [EOL]     super(type); [EOL]     Class<?> rootComponentType = rawClass; [EOL]     while (rootComponentType.isArray()) { [EOL]         rootComponentType = rootComponentType.getComponentType(); [EOL]     } [EOL]     this.componentRawType = rootComponentType; [EOL]     this.secondLevel = extractSecondLevelType(actualType, rawClass); [EOL] }  TypeInfoArray(Type type); private static Type extractSecondLevelType(Type actualType, Class<?> rawClass); public Type getSecondLevelType(); public Class<?> getComponentRawType(); Class<?> componentRawType; Type secondLevel"}
{"code": "public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }", "nl": "[LINE] instanceCreators.makeUnmodifiable(); [LINE] public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson"}
{"code": "public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals(\\\"-Infinity\\\", gson.toJson(negativeInfinity)); [EOL]     assertEquals(\\\"-Infinity\\\", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }", "nl": "[LINE] public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [LINE] public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] } public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value); public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair); private int getIndexOfAnOverriddenHandler(Class<?> type); public synchronized void register(Type typeOfT, T value); public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other); public synchronized void registerIfAbsent(Type typeOfT, T value); public synchronized void makeUnmodifiable(); public synchronized T getHandlerFor(Type type); private T getHandlerForTypeHierarchy(Class<?> type); public synchronized boolean hasSpecificHandlerFor(Type type); private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type); public synchronized ParameterizedTypeHandlerMap<T> copyOf(); public String toString(); private String typeToString(Type type); Logger logger=Optional[Logger.getLogger(ParameterizedTypeHandlerMap.class.getName())]; Map<Type, T> map=Optional[new HashMap<Type, T>()]; List<Pair<Class<?>, T>> typeHierarchyList=Optional[new ArrayList<Pair<Class<?>, T>>()]; boolean modifiable=Optional[true]"}
{"code": "public void testCharacterUnescaping() throws IOException { [EOL]     String json = \\\"[\\\\\"a\\\\\",\\\" + \\\"\\\\\"a\\\\\\\\\"\\\\\",\\\" + \\\"\\\\\"\\\\\\\\\"\\\\\",\\\" + \\\"\\\\\":\\\\\",\\\" + \\\"\\\\\",\\\\\",\\\" + \\\"\\\\\"\\\\b\\\\\",\\\" + \\\"\\\\\"\\\\f\\\\\",\\\" + \\\"\\\\\"\\\\n\\\\\",\\\" + \\\"\\\\\"\\\\r\\\\\",\\\" + \\\"\\\\\"\\\\t\\\\\",\\\" + \\\"\\\\\" \\\\\",\\\" + \\\"\\\\\"\\\\\\\\\\\\\",\\\" + \\\"\\\\\"{\\\\\",\\\" + \\\"\\\\\"}\\\\\",\\\" + \\\"\\\\\"[\\\\\",\\\" + \\\"\\\\\"]\\\\\",\\\" + \\\"\\\\\"\\\\u0000\\\\\",\\\" + \\\"\\\\\"\\\\u0019\\\\\",\\\" + \\\"\\\\\"\\\\u20AC\\\\\"\\\" + \\\"]\\\"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(\\\"a\\\", reader.nextString()); [EOL]     assertEquals(\\\"a\\\\\"\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\\\\"\\\", reader.nextString()); [EOL]     assertEquals(\\\":\\\", reader.nextString()); [EOL]     assertEquals(\\\",\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\b\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\f\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\n\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\r\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\t\\\", reader.nextString()); [EOL]     assertEquals(\\\" \\\", reader.nextString()); [EOL]     assertEquals(\\\"\\\\\\\", reader.nextString()); [EOL]     assertEquals(\\\"{\\\", reader.nextString()); [EOL]     assertEquals(\\\"}\\\", reader.nextString()); [EOL]     assertEquals(\\\"[\\\", reader.nextString()); [EOL]     assertEquals(\\\"]\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\0\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\u0019\\\", reader.nextString()); [EOL]     assertEquals(\\\"\\u20AC\\\", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }", "nl": "[LINE] pos += 4; [LINE] private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError(\\\"Unterminated escape sequence\\\"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError(\\\"Unterminated escape sequence\\\"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\\t'; [EOL]         case 'b': [EOL]             return '\\b'; [EOL]         case 'n': [EOL]             return '\\n'; [EOL]         case 'r': [EOL]             return '\\r'; [EOL]         case 'f': [EOL]             return '\\f'; [EOL]         case '\\'': [EOL]         case '\\\"': [EOL]         case '\\\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"[true;true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }", "nl": "[LINE] push(JsonScope.EMPTY_ARRAY); [LINE] private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\\'': [EOL]             checkLenient(); [EOL]         case '\\\"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }", "nl": "[LINE] Preconditions.checkArgument(primitive instanceof Number [LINE] void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value"}
{"code": "public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }", "nl": "[LINE] addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root"}
{"code": "public void testBigDecimalFieldDeserialization() { [EOL]     ClassWithBigDecimal expected = new ClassWithBigDecimal(\\\"-122.01e-21\\\"); [EOL]     String json = expected.getExpectedJson(); [EOL]     ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class); [EOL]     assertEquals(expected.value, actual.value); [EOL] }", "nl": "[LINE] return json.getAsBigDecimal(); [LINE] public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigDecimal(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]"}
{"code": "public void testLenientMultipleTopLevelValues() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"[] true {}\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.endArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.beginObject(); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }", "nl": "[LINE] return token; [LINE] private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError(\\\"Expected JSON document to start with '[' or '{'\\\"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError(\\\"Expected EOF\\\"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException(\\\"JsonReader is closed\\\"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar(\\\"someString\\\", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put(\\\"key1\\\", arrayList); [EOL]     bar1.map.put(\\\"key2\\\", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }", "nl": "[LINE] TypeVariable<?>[] classTypeVariables = [LINE] private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) { [EOL]     Class<?> rawParentType = null; [EOL]     if (parentType instanceof Class<?>) { [EOL]         rawParentType = (Class<?>) parentType; [EOL]     } else if (parentType instanceof ParameterizedType) { [EOL]         ParameterizedType parentTypeAsPT = (ParameterizedType) parentType; [EOL]         rawParentType = (Class<?>) parentTypeAsPT.getRawType(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Type superClass = rawParentType.getGenericSuperclass(); [EOL]     if (superClass instanceof ParameterizedType && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) { [EOL]         TypeVariable<?>[] classTypeVariables = ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters(); [EOL]         int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate); [EOL]         Type[] actualTypeArguments = null; [EOL]         if (parentType instanceof Class<?>) { [EOL]             actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments(); [EOL]         } else if (parentType instanceof ParameterizedType) { [EOL]             actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]         return actualTypeArguments[indexOfActualTypeArgument]; [EOL]     } [EOL]     Type searchedType = null; [EOL]     if (superClass != null) { [EOL]         searchedType = extractTypeForHierarchy(superClass, typeToEvaluate); [EOL]     } [EOL]     return searchedType; [EOL] } private TypeInfoFactory(); public static TypeInfoArray getTypeInfoForArray(Type type); public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF); private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass); private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate); private static Type[] extractRealTypes(Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass); private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type)"}
{"code": "public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader(\\\"[// comment \\n true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader(\\\"[# comment \\n true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader(\\\"[/* comment */ true]\\\")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }", "nl": "[LINE] char peek = buffer[pos]; [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\\t': [EOL]             case ' ': [EOL]             case '\\n': [EOL]             case '\\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo(\\\"*/\\\")) { [EOL]                             throw syntaxError(\\\"Unterminated comment\\\"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException(\\\"End of input\\\"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[\\\")]}'\\n\\\".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]"}
{"code": "public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = \\\"{\\\\\"list\\\\\":[0,1,2,3],\\\\\"queue\\\\\":[0,1,2,3],\\\\\"set\\\\\":[0.1,0.2,0.3,0.4],\\\" + \\\"\\\\\"sortedSet\\\\\":[\\\\\"a\\\\\",\\\\\"b\\\\\",\\\\\"c\\\\\",\\\\\"d\\\\\"]\\\" + \\\"}\\\"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }", "nl": "[LINE] return objectConstructor; [LINE] ObjectConstructor getObjectConstructor() { [EOL]     return objectConstructor; [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor"}
