public void testRootUsingExplicitConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer().withRootName(\"wrapper\"); [EOL]     String json = writer.writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"wrapper\\":{\\"a\\":3}}\", json); [EOL]     ObjectReader reader = mapper.reader(Bean.class).withRootName(\"wrapper\"); [EOL]     Bean bean = reader.readValue(json); [EOL]     assertNotNull(bean); [EOL]     ObjectMapper wrapping = rootMapper(); [EOL]     json = wrapping.writer().withRootName(\"something\").writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"something\\":{\\"a\\":3}}\", json); [EOL]     json = wrapping.writer().withRootName(\"\").writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"a\\":3}\", json); [EOL]     bean = wrapping.reader(Bean.class).withRootName(\"\").readValue(json); [EOL]     assertNotNull(bean); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testAnnotationsDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     AnnoBean bean = m.readValue(\"{ \\"y\\" : 0 }\", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     bean = m.readValue(\"{ \\"x\\" : 0 }\", AnnoBean.class); [EOL]     assertEquals(0, bean.value); [EOL] }
public void testBrokenWithDoubleAnnotations() throws Exception { [EOL]     try { [EOL]         @SuppressWarnings(\"unused\") [EOL]         Broken b = MAPPER.readValue(\"{ \\"a\\" : 3 }\", Broken.class); [EOL]         fail(\"Should have gotten an exception\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Multiple 'any-setters'\"); [EOL]     } [EOL] }
public void testInnerClassWithAnnotationsInCreator() throws Exception { [EOL]     BasicBeanDescription beanDesc; [EOL]     beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Issue701Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL]     beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue701Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\"c3VyZS4=\", byte[].class); [EOL]     byte[] exp = \"sure.\".getBytes(\"Ascii\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testSerialization() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(\"[{\\"doggy\\":{\\"name\\":\\"Spot\\",\\"ageInYears\\":3}}]\", m.writeValueAsString(new Animal[] { new Dog(\"Spot\", 3) })); [EOL]     assertEquals(\"[{\\"MaineCoon\\":{\\"name\\":\\"Belzebub\\",\\"purrs\\":true}}]\", m.writeValueAsString(new Animal[] { new MaineCoon(\"Belzebub\", true) })); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\")); [EOL]         fail(\"Should have failed\"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, \"Can not detect format from input\"); [EOL]     } [EOL] }
public void testLeafMixin() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Object> result; [EOL]     BaseClass bean = new BaseClass(\"a1\", \"b2\"); [EOL]     result = writeAndMap(mapper, bean); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\"b2\", result.get(\"b\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(BaseClass.class, MixIn.class); [EOL]     result = writeAndMap(mapper, bean); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(\"b2\", result.get(\"b2\")); [EOL]     assertEquals(\"a1\", result.get(\"a\")); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\"num\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add(\"xyz\"); [EOL]     assertEquals(quote(\"xyz\"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals(\"13\", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals(\"42\", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = \"{\\"values\\":\\"foo\\"}\"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList(\"foo\")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add(\"foo\"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals(\"true\", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals(\"true\", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals(\"3\", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote(\"foo\"), writer.writeValueAsString(new String[] { \"foo\" })); [EOL] }
public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"abc:\")); [EOL]     MyMap map = mapper.readValue(\"{\\"a\\":\\"b\\"}\", MyMap.class); [EOL]     assertEquals(\"{\\"KEY\\":\\"b\\"}\", mapper.writeValueAsString(map)); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get(\"value\"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get(\"x\")); [EOL] }
public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\"a\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\"{\\"a\\":{\\"a\\":3}}\", listJson); [EOL] }
public void testCharArrays() throws IOException { [EOL]     char[] chars = new char[] { 'a', 'b', 'c' }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(quote(\"abc\"), m.writeValueAsString(chars)); [EOL]     m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true); [EOL]     assertEquals(\"[\\"a\\",\\"b\\",\\"c\\"]\", m.writeValueAsString(chars)); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\"num\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testSuperInterfaces() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { BaseInt.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testEnumMap() throws Exception { [EOL]     EnumMap<Choice, String> map = new EnumMap<Choice, String>(Choice.class); [EOL]     map.put(Choice.NO, \"maybe\"); [EOL]     Object[] input = new Object[] { map }; [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     Object ob = output[0]; [EOL]     assertTrue(ob instanceof EnumMap<?, ?>); [EOL]     EnumMap<Choice, String> map2 = (EnumMap<Choice, String>) ob; [EOL]     assertEquals(1, map2.size()); [EOL]     assertEquals(\"maybe\", map2.get(Choice.NO)); [EOL]     assertNull(map2.get(Choice.YES)); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testSimple() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, \"stuffValue\").addValue(\"myId\", \"xyz\").addValue(Long.TYPE, Long.valueOf(37))); [EOL]     InjectedBean bean = mapper.readValue(\"{\\"value\\":3}\", InjectedBean.class); [EOL]     assertEquals(3, bean.value); [EOL]     assertEquals(\"stuffValue\", bean.stuff); [EOL]     assertEquals(\"xyz\", bean.otherStuff); [EOL]     assertEquals(37L, bean.third); [EOL] }
public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"abc:\")); [EOL]     MyMap map = mapper.readValue(\"{\\"a\\":\\"b\\"}\", MyMap.class); [EOL]     assertEquals(\"{\\"KEY\\":\\"b\\"}\", mapper.writeValueAsString(map)); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer(\"prefix\")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put(\"a\", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals(\"{\\"prefix:a\\":3}\", json); [EOL] }
public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\"\\"value1\\"\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\"value1\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"xyz:\")); [EOL]     assertEquals(quote(\"xyz:456\"), mapper.writeValueAsString(new MyBean(\"456\"))); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testObjectNodeEquality() { [EOL]     ObjectNode n1 = new ObjectNode(null); [EOL]     ObjectNode n2 = new ObjectNode(null); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL]     n1.set(\"x\", TextNode.valueOf(\"Test\")); [EOL]     assertFalse(n1.equals(n2)); [EOL]     assertFalse(n2.equals(n1)); [EOL]     n2.set(\"x\", TextNode.valueOf(\"Test\")); [EOL]     assertTrue(n1.equals(n2)); [EOL]     assertTrue(n2.equals(n1)); [EOL] }
public void testIssue811() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL]     om.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL]     om.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL]     om.setVisibility(PropertyAccessor.FIELD, Visibility.ANY); [EOL]     om.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     om.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, \"@class\"); [EOL]     Process p = new Process(); [EOL]     Scope s = new Scope(p, null); [EOL]     FaultHandler fh = new FaultHandler(p); [EOL]     Catch c = new Catch(p, s); [EOL]     fh.catchBlocks.add(c); [EOL]     s.faultHandlers.add(fh); [EOL]     String json = om.writeValueAsString(p); [EOL]     Process restored = om.readValue(json, Process.class); [EOL]     assertNotNull(restored); [EOL]     assertEquals(0, p.id); [EOL]     assertEquals(3, p.children.size()); [EOL]     assertSame(p, p.children.get(0).owner); [EOL]     assertSame(p, p.children.get(1).owner); [EOL]     assertSame(p, p.children.get(2).owner); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals(\"{\\"values\\":[[7,8],[8,7]]}\", json); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree(\"null\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree(\"null\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree(\"{\\"x\\":null}\"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get(\"x\"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testSpecialMap() throws IOException { [EOL]     final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class); [EOL]     _doTestUntyped(map); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\"{\\"enumA\\":\\"value\\"}\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\"value\", value.get(EnumWithCreator.A)); [EOL] }
public void testRootViaMapper() throws Exception { [EOL]     ObjectMapper mapper = rootMapper(); [EOL]     String json = mapper.writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"rudy\\":{\\"a\\":3}}\", json); [EOL]     Bean bean = mapper.readValue(json, Bean.class); [EOL]     assertNotNull(bean); [EOL]     json = mapper.writeValueAsString(new RootBeanWithEmpty()); [EOL]     assertEquals(\"{\\"RootBeanWithEmpty\\":{\\"a\\":2}}\", json); [EOL]     RootBeanWithEmpty bean2 = mapper.readValue(json, RootBeanWithEmpty.class); [EOL]     assertNotNull(bean2); [EOL]     assertEquals(2, bean2.a); [EOL] }
public void testIssue476() throws Exception { [EOL]     final String JSON = \"{\\"value1\\" : {\\"name\\" : \\"fruit\\", \\"value\\" : \\"apple\\"}, \\"value2\\" : {\\"name\\" : \\"color\\", \\"value\\" : \\"red\\"}}\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new Issue476Module()); [EOL]     mapper.readValue(JSON, Issue476Bean.class); [EOL]     assertEquals(2, Issue476Deserializer.propCount); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>(\"valueX\"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = \"xxxxxx\"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testIssue709() throws Exception { [EOL]     byte[] inputData = new byte[] { 1, 2, 3 }; [EOL]     ObjectNode node = MAPPER.createObjectNode(); [EOL]     node.put(\"data\", inputData); [EOL]     Issue709Bean result = MAPPER.treeToValue(node, Issue709Bean.class); [EOL]     String json = MAPPER.writeValueAsString(node); [EOL]     Issue709Bean resultFromString = MAPPER.readValue(json, Issue709Bean.class); [EOL]     Issue709Bean resultFromConvert = MAPPER.convertValue(node, Issue709Bean.class); [EOL]     Assert.assertArrayEquals(inputData, resultFromString.data); [EOL]     Assert.assertArrayEquals(inputData, resultFromConvert.data); [EOL]     Assert.assertArrayEquals(inputData, result.data); [EOL] }
public void testMapLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyCollectionLikeType result = mapper.readValue(\"[-37]\", MyCollectionLikeType.class); [EOL]     assertEquals(Integer.valueOf(-37), result.getValue()); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testSimpleArrayMethod() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     MethodWrapperBeanArray array = new MethodWrapperBeanArray(new MethodWrapperBean[] { new MethodWrapperBean(new StringWrapper(\"A\")) }); [EOL]     String json = mapper.writeValueAsString(array); [EOL]     MethodWrapperBeanArray result = mapper.readValue(json, MethodWrapperBeanArray.class); [EOL]     assertNotNull(result); [EOL]     MethodWrapperBean[] beans = result.beans; [EOL]     assertEquals(1, beans.length); [EOL]     MethodWrapperBean bean = beans[0]; [EOL]     assertEquals(StringWrapper.class, bean.value.getClass()); [EOL]     assertEquals(((StringWrapper) bean.value).str, \"A\"); [EOL] }
public void testDatesAsMapKeys() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<Date, Integer> map = new HashMap<Date, Integer>(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)); [EOL]     map.put(new Date(0L), Integer.valueOf(1)); [EOL]     assertEquals(\"{\\"1970-01-01T00:00:00.000+0000\\":1}\", mapper.writeValueAsString(map)); [EOL]     mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true); [EOL]     assertEquals(\"{\\"0\\":1}\", mapper.writeValueAsString(map)); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testOverflows() { [EOL]     try { [EOL]         mapper.convertValue(new int[] { 1000 }, byte[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG_BYTE); [EOL]     } [EOL]     try { [EOL]         mapper.convertValue(new int[] { -99999 }, short[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL]     try { [EOL]         mapper.convertValue(new long[] { Long.MAX_VALUE }, int[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL]     BigInteger biggie = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     biggie.add(BigInteger.ONE); [EOL]     List<BigInteger> l = new ArrayList<BigInteger>(); [EOL]     l.add(biggie); [EOL]     try { [EOL]         mapper.convertValue(l, int[].class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, OVERFLOW_MSG); [EOL]     } [EOL] }
public void testCustomPropertyForClass() throws Exception { [EOL]     IdentifiableWithProp src = new IdentifiableWithProp(123, -19); [EOL]     src.next = src; [EOL]     String json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL]     json = MAPPER.writeValueAsString(src); [EOL]     assertEquals(EXP_CUSTOM_PROP, json); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testJackson428() throws Exception { [EOL]     ObjectMapper serMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true)); [EOL]     serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     serMapper.setDefaultTyping(serializerTyper); [EOL]     MapHolder holder = new MapHolder(); [EOL]     holder.map = new HashMap<MapKey, List<Object>>(); [EOL]     List<Object> ints = new ArrayList<Object>(); [EOL]     ints.add(Integer.valueOf(3)); [EOL]     holder.map.put(new MapKey(\"key\"), ints); [EOL]     String json = serMapper.writeValueAsString(holder); [EOL]     ObjectMapper deserMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false)); [EOL]     deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     deserMapper.setDefaultTyping(deserializerTyper); [EOL]     MapHolder result = deserMapper.readValue(json, MapHolder.class); [EOL]     assertNotNull(result); [EOL]     Map<?, ?> map = result.map; [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(MapKey.class, key.getClass()); [EOL]     Object value = entry.getValue(); [EOL]     assertTrue(value instanceof List<?>); [EOL]     List<?> list = (List<?>) value; [EOL]     assertEquals(1, list.size()); [EOL]     assertEquals(Integer.class, list.get(0).getClass()); [EOL]     assertEquals(Integer.valueOf(3), list.get(0)); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode(\"root\"); [EOL]     FullTreeNode child1 = new FullTreeNode(\"kid1\"); [EOL]     FullTreeNode child2 = new FullTreeNode(\"kid2\"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals(\"root\", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals(\"kid1\", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals(\"kid2\", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll(\"\\"\", \"'\"); [EOL]     assertEquals(\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\", json); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testJackson428() throws Exception { [EOL]     ObjectMapper serMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true)); [EOL]     serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     serMapper.setDefaultTyping(serializerTyper); [EOL]     MapHolder holder = new MapHolder(); [EOL]     holder.map = new HashMap<MapKey, List<Object>>(); [EOL]     List<Object> ints = new ArrayList<Object>(); [EOL]     ints.add(Integer.valueOf(3)); [EOL]     holder.map.put(new MapKey(\"key\"), ints); [EOL]     String json = serMapper.writeValueAsString(holder); [EOL]     ObjectMapper deserMapper = new ObjectMapper(); [EOL]     TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false)); [EOL]     deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     deserMapper.setDefaultTyping(deserializerTyper); [EOL]     MapHolder result = deserMapper.readValue(json, MapHolder.class); [EOL]     assertNotNull(result); [EOL]     Map<?, ?> map = result.map; [EOL]     assertEquals(1, map.size()); [EOL]     Map.Entry<?, ?> entry = map.entrySet().iterator().next(); [EOL]     Object key = entry.getKey(); [EOL]     assertEquals(MapKey.class, key.getClass()); [EOL]     Object value = entry.getValue(); [EOL]     assertTrue(value instanceof List<?>); [EOL]     List<?> list = (List<?>) value; [EOL]     assertEquals(1, list.size()); [EOL]     assertEquals(Integer.class, list.get(0).getClass()); [EOL]     assertEquals(Integer.valueOf(3), list.get(0)); [EOL] }
public void testDeserializationWithArrayOfSize2() throws Exception { [EOL]     Inter inter = objectReader(Inter.class).readValue(\"[\\"a\\", \\"b\\"]\"); [EOL]     assertTrue(inter instanceof LegacyInter); [EOL]     assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testWithView() throws Exception { [EOL]     AsArrayWithView input = new AsArrayWithView(); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     input.c = 3; [EOL]     String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input); [EOL]     assertEquals(\"[1,null,3]\", json); [EOL]     AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class).readValue(\"[1,2,3]\"); [EOL]     assertEquals(3, output.c); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(0, output.a); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertEquals(\"2\", map.get(\"b\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertNull(map.get(\"b\")); [EOL] }
public void testClassKey() { [EOL]     ClassKey key = new ClassKey(String.class); [EOL]     assertEquals(0, key.compareTo(key)); [EOL]     assertTrue(key.equals(key)); [EOL]     assertFalse(key.equals(null)); [EOL]     assertFalse(key.equals(\"foo\")); [EOL]     assertFalse(key.equals(new ClassKey(Integer.class))); [EOL]     assertEquals(String.class.getName(), key.toString()); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testEmptyListOrArray() throws IOException { [EOL]     EmptyListBean list = new EmptyListBean(); [EOL]     EmptyArrayBean array = new EmptyArrayBean(); [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)); [EOL]     assertEquals(\"{\\"empty\\":[]}\", MAPPER.writeValueAsString(list)); [EOL]     assertEquals(\"{\\"empty\\":[]}\", MAPPER.writeValueAsString(array)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false); [EOL]     assertEquals(\"{}\", m.writeValueAsString(list)); [EOL]     assertEquals(\"{}\", m.writeValueAsString(array)); [EOL] }
public void testStringListAsObjectWrapper() throws Exception { [EOL]     TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>(); [EOL]     input.add(true); [EOL]     input.add(null); [EOL]     input.add(false); [EOL]     String expName = \"TestTypedArraySerialization$TypedListAsWrapper\"; [EOL]     assertEquals(\"{\\"\" + expName + \"\\":[true,null,false]}\", serializeAsString(input)); [EOL] }
public void testCollectionLikeDeserialization() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier())); [EOL]     mapper.registerModule(new ModifierModule()); [EOL]     MyMapLikeType result = mapper.readValue(\"{\\"a\\":13}\", MyMapLikeType.class); [EOL]     assertEquals(\"a\", result.getKey()); [EOL]     assertEquals(Integer.valueOf(13), result.getValue()); [EOL] }
public void testPropertyAnnotationForLists() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8)); [EOL]     assertEquals(\"{\\"values\\":[[7,8],[8,7]]}\", json); [EOL] }
public void testListAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = \"[\n\" + asJSONObjectValueString(m, \"@classy\", Cat.class.getName(), \"name\", \"Hello\", \"furColor\", \"white\") + \",\n\" + asJSONObjectValueString(m, \"boneCount\", Integer.valueOf(1), \"@classy\", Dog.class.getName(), \"name\", \"Bob\") + \",\n\" + asJSONObjectValueString(m, \"@classy\", Fish.class.getName()) + \", null\n]\"; [EOL]     JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class); [EOL]     List<Animal> animals = m.readValue(JSON, expType); [EOL]     assertNotNull(animals); [EOL]     assertEquals(4, animals.size()); [EOL]     Cat c = (Cat) animals.get(0); [EOL]     assertEquals(\"Hello\", c.name); [EOL]     assertEquals(\"white\", c.furColor); [EOL]     Dog d = (Dog) animals.get(1); [EOL]     assertEquals(\"Bob\", d.name); [EOL]     assertEquals(1, d.boneCount); [EOL]     Fish f = (Fish) animals.get(2); [EOL]     assertNotNull(f); [EOL]     assertNull(animals.get(3)); [EOL] }
public void testObjectReader() throws IOException { [EOL]     ObjectReader origReader = new ObjectMapper().reader(MyPojo.class); [EOL]     final String JSON = \"{\\"x\\":1,\\"y\\":2}\"; [EOL]     MyPojo p1 = origReader.readValue(JSON); [EOL]     assertEquals(2, p1.y); [EOL]     byte[] bytes = jdkSerialize(origReader); [EOL]     ObjectReader reader2 = jdkDeserialize(bytes); [EOL]     MyPojo p2 = reader2.readValue(JSON); [EOL]     assertEquals(2, p2.y); [EOL] }
public void testPolymorphicRoundtrip() throws Exception { [EOL]     Impl in1 = new Impl(123, 456); [EOL]     in1.next = new Impl(111, 222); [EOL]     in1.next.next = in1; [EOL]     String json = mapper.writeValueAsString(in1); [EOL]     Base result0 = mapper.readValue(json, Base.class); [EOL]     assertNotNull(result0); [EOL]     assertSame(Impl.class, result0.getClass()); [EOL]     Impl result = (Impl) result0; [EOL]     assertEquals(123, result.value); [EOL]     assertEquals(456, result.extra); [EOL]     Impl result2 = (Impl) result.next; [EOL]     assertEquals(111, result2.value); [EOL]     assertEquals(222, result2.extra); [EOL]     assertSame(result, result2.next); [EOL] }
public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \"root\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \"leaf\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\"{\\"id\\":1,\\"name\\":\\"root\\",\\"parent\\":null,\\"child\\":\" + \"{\\"id\\":2,\\"name\\":\\"leaf\\",\\"parent\\":1,\\"child\\":null}}\", json); [EOL] }
public void testModifyKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule(\"test\").setDeserializerModifier(new KeyDeserializerModifier())); [EOL]     Map<?, ?> result = mapper.readValue(\"{\\"a\\":1}\", Map.class); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\"foo\", result.entrySet().iterator().next().getKey()); [EOL] }
public void testInvalid() throws Exception { [EOL]     ObjectReader detecting = READER.withType(POJO.class); [EOL]     detecting = detecting.withFormatDetection(detecting); [EOL]     try { [EOL]         detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\")); [EOL]         fail(\"Should have failed\"); [EOL]     } catch (JsonProcessingException e) { [EOL]         verifyException(e, \"Can not detect format from input\"); [EOL]     } [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put(\"a\", 1); [EOL]     assertEquals(\"{\\"a\\":1}\", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty(\"line.separator\"); [EOL]     assertEquals(\"{\" + lf + \"  \\"a\\" : 1\" + lf + \"}\", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals(\"{\\"a\\":1}\", writer.writeValueAsString(data)); [EOL] }
public void testSerializedAsListWithClassAnnotations() throws IOException { [EOL]     SimpleValueList list = new SimpleValueList(); [EOL]     list.add(new ActualValue(\"foo\")); [EOL]     assertEquals(\"[{\\"value\\":\\"foo\\"}]\", MAPPER.writeValueAsString(list)); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\"a\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\"{\\"a\\":{\\"a\\":3}}\", listJson); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testSuperClass() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SubType bean = new SubType(); [EOL]     Map<String, Object> result = writeAndMap(mapper, bean); [EOL]     assertEquals(4, result.size()); [EOL]     assertEquals(\"a\", result.get(\"a\")); [EOL]     assertEquals(Integer.valueOf(3), result.get(\"b\")); [EOL]     assertEquals(\"x\", result.get(\"a2\")); [EOL]     assertEquals(Boolean.TRUE, result.get(\"b2\")); [EOL]     ObjectWriter w = mapper.writerWithType(BaseType.class); [EOL]     String json = w.writeValueAsString(bean); [EOL]     result = (Map<String, Object>) mapper.readValue(json, Map.class); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(\"a\", result.get(\"a\")); [EOL]     assertEquals(Integer.valueOf(3), result.get(\"b\")); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testSimpleSetterlessCollectionFailure() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)); [EOL]     m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false); [EOL]     assertFalse(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)); [EOL]     try { [EOL]         m.readValue(\"{\\"values\\":[ \\"abc\\", \\"def\\" ]}\", CollectionBean.class); [EOL]         fail(\"Expected an exception\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Unrecognized field\"); [EOL]     } [EOL] }
public void testHierarchicConfigSerialize() throws Exception { [EOL]     String json = mapper.writeValueAsString(new ConfigRoot(\"Fred\", 25)); [EOL]     assertEquals(\"{\\"general.names.name\\":\\"Fred\\",\\"misc.value\\":25}\", json); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testDateScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     long ts = 12345678L; [EOL]     assertEquals(\"[[\\"java.util.Date\\",\" + ts + \"]]\", m.writeValueAsString(new Object[] { new Date(ts) })); [EOL]     Calendar c = Calendar.getInstance(); [EOL]     c.setTimeInMillis(ts); [EOL]     String json = m.writeValueAsString(new Object[] { c }); [EOL]     assertEquals(\"[[\\"\" + c.getClass().getName() + \"\\",\" + ts + \"]]\", json); [EOL]     Object[] result = m.readValue(json, Object[].class); [EOL]     assertEquals(1, result.length); [EOL]     assertTrue(result[0] instanceof Calendar); [EOL]     assertEquals(ts, ((Calendar) result[0]).getTimeInMillis()); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals(\"Should deserialize to equal XMLGregorianCalendar ('\" + exp + \"')\", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\"{\\"bar\\":3}\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\"Should have failed binding\"); [EOL]     } [EOL]     assertEquals(\"bar\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \"propX\"); [EOL] }
public void testTreeRead() throws Exception { [EOL]     String JSON = \"{ }\"; [EOL]     JsonNode n = MAPPER.readTree(JSON); [EOL]     assertTrue(n instanceof ObjectNode); [EOL]     n = MAPPER.readTree(new StringReader(JSON)); [EOL]     assertTrue(n instanceof ObjectNode); [EOL]     n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\"))); [EOL]     assertTrue(n instanceof ObjectNode); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals(\"0.25\", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testSimpleMapField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanMap map = new FieldWrapperBeanMap(); [EOL]     map.put(\"foop\", new FieldWrapperBean(new IntWrapper(13))); [EOL]     String json = mapper.writeValueAsString(map); [EOL]     FieldWrapperBeanMap result = mapper.readValue(json, FieldWrapperBeanMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = result.get(\"foop\"); [EOL]     assertNotNull(bean); [EOL]     Object ob = bean.value; [EOL]     assertEquals(IntWrapper.class, ob.getClass()); [EOL]     assertEquals(((IntWrapper) ob).i, 13); [EOL] }
public void testDelegateListInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator())); [EOL]     MyList result = mapper.readValue(\"123\", MyList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(123), result.get(0)); [EOL] }
public void testRootWrapping() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true); [EOL]     String json = mapper.writeValueAsString(new StringWrapper(\"abc\")); [EOL]     assertEquals(\"{\\"StringWrapper\\":{\\"str\\":\\"abc\\"}}\", json); [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\"{\\"bar\\":3}\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\"Should have failed binding\"); [EOL]     } [EOL]     assertEquals(\"bar\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \"propX\"); [EOL] }
public void testFullRefs() throws Exception { [EOL]     FullTreeNode root = new FullTreeNode(\"root\"); [EOL]     FullTreeNode child1 = new FullTreeNode(\"kid1\"); [EOL]     FullTreeNode child2 = new FullTreeNode(\"kid2\"); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     root.firstChild = child1; [EOL]     child1.parent = root; [EOL]     child1.next = child2; [EOL]     child2.prev = child1; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class); [EOL]     assertEquals(\"root\", resultNode.name); [EOL]     FullTreeNode resultChild = resultNode.firstChild; [EOL]     assertNotNull(resultChild); [EOL]     assertEquals(\"kid1\", resultChild.name); [EOL]     assertSame(resultChild.parent, resultNode); [EOL]     assertNull(resultChild.prev); [EOL]     FullTreeNode resultChild2 = resultChild.next; [EOL]     assertNotNull(resultChild2); [EOL]     assertEquals(\"kid2\", resultChild2.name); [EOL]     assertSame(resultChild, resultChild2.prev); [EOL]     assertNull(resultChild2.next); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testWithoutModule() { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     try { [EOL]         mapper.writeValueAsString(new CustomBean(\"foo\", 3)); [EOL]         fail(\"Should have caused an exception\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \"No serializer found\"); [EOL]     } [EOL]     try { [EOL]         mapper.readValue(\"{\\"str\\":\\"ab\\",\\"num\\":2}\", CustomBean.class); [EOL]         fail(\"Should have caused an exception\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \"No suitable constructor found\"); [EOL]     } [EOL] }
public void testCustomContentSerializer() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MyObject object = new MyObject(); [EOL]     object.list = Arrays.asList(\"foo\"); [EOL]     String json = m.writeValueAsString(object); [EOL]     assertEquals(\"{\\"list\\":[\\"bar\\"]}\", json); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testArrayIdentityTransforms() throws Exception { [EOL]     verifyByteArrayConversion(bytes(), byte[].class); [EOL]     verifyShortArrayConversion(shorts(), short[].class); [EOL]     verifyIntArrayConversion(ints(), int[].class); [EOL]     verifyLongArrayConversion(longs(), long[].class); [EOL]     verifyFloatArrayConversion(floats(), float[].class); [EOL]     verifyDoubleArrayConversion(doubles(), float[].class); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get(\"value\"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get(\"x\")); [EOL] }
public void testTyped() { [EOL]     _testObjectBuffer(Integer.class); [EOL] }
public void testPolymorphicRoundtrip() throws Exception { [EOL]     Impl in1 = new Impl(123, 456); [EOL]     in1.next = new Impl(111, 222); [EOL]     in1.next.next = in1; [EOL]     String json = mapper.writeValueAsString(in1); [EOL]     Base result0 = mapper.readValue(json, Base.class); [EOL]     assertNotNull(result0); [EOL]     assertSame(Impl.class, result0.getClass()); [EOL]     Impl result = (Impl) result0; [EOL]     assertEquals(123, result.value); [EOL]     assertEquals(456, result.extra); [EOL]     Impl result2 = (Impl) result.next; [EOL]     assertEquals(111, result2.value); [EOL]     assertEquals(222, result2.extra); [EOL]     assertSame(result, result2.next); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testKeyDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"abc:\")); [EOL]     MyMap map = mapper.readValue(\"{\\"a\\":\\"b\\"}\", MyMap.class); [EOL]     assertEquals(\"{\\"KEY\\":\\"b\\"}\", mapper.writeValueAsString(map)); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testDelegating() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion()); [EOL]     module.addSerializer(new StdDelegatingSerializer(Immutable.class, new StdConverter<Immutable, Map<String, Integer>>() { [EOL]  [EOL]         @Override [EOL]         public Map<String, Integer> convert(Immutable value) { [EOL]             HashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]             map.put(\"x\", value.x()); [EOL]             map.put(\"y\", value.y()); [EOL]             return map; [EOL]         } [EOL]     })); [EOL]     mapper.registerModule(module); [EOL]     assertEquals(\"{\\"x\\":3,\\"y\\":7}\", mapper.writeValueAsString(new Immutable())); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testSimpleFields() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     String json = mapper.writeValueAsString(new FieldBean(999)); [EOL]     assertEquals(\"{\\"Field-key\\":999}\", json); [EOL]     FieldBean result = mapper.readValue(json, FieldBean.class); [EOL]     assertEquals(999, result.key); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\"num\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testSimpleObject() throws Exception { [EOL]     String JSON = \"{ \\"key\\" : 1, \\"b\\" : \\"x\\" }\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonNode root = mapper.readTree(JSON); [EOL]     assertFalse(root.isValueNode()); [EOL]     assertTrue(root.isContainerNode()); [EOL]     assertFalse(root.isArray()); [EOL]     assertTrue(root.isObject()); [EOL]     assertEquals(2, root.size()); [EOL]     Iterator<JsonNode> it = root.iterator(); [EOL]     assertNotNull(it); [EOL]     assertTrue(it.hasNext()); [EOL]     JsonNode n = it.next(); [EOL]     assertNotNull(n); [EOL]     assertEquals(IntNode.valueOf(1), n); [EOL]     assertTrue(it.hasNext()); [EOL]     n = it.next(); [EOL]     assertNotNull(n); [EOL]     assertEquals(TextNode.valueOf(\"x\"), n); [EOL]     assertFalse(it.hasNext()); [EOL]     ObjectNode obNode = (ObjectNode) root; [EOL]     Iterator<Map.Entry<String, JsonNode>> fit = obNode.fields(); [EOL]     assertTrue(fit.hasNext()); [EOL]     Map.Entry<String, JsonNode> en = fit.next(); [EOL]     assertEquals(\"key\", en.getKey()); [EOL]     assertEquals(IntNode.valueOf(1), en.getValue()); [EOL]     assertTrue(fit.hasNext()); [EOL]     en = fit.next(); [EOL]     assertEquals(\"b\", en.getKey()); [EOL]     assertEquals(TextNode.valueOf(\"x\"), en.getValue()); [EOL]     fit.remove(); [EOL]     assertEquals(1, obNode.size()); [EOL]     assertEquals(IntNode.valueOf(1), root.get(\"key\")); [EOL]     assertNull(root.get(\"b\")); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals(\"uri\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"url\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testNull\")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals(\"testString\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testBoolean\")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals(\"testEnum\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testInteger\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals(\"testLong\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals(\"testBigInteger\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals(\"testBigDecimal\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals(\"testCharacter\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testShort\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals(\"testByte\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals(\"testFloat\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals(\"testDouble\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals(\"testStringBuffer\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testError\")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals(\"cause\")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals(\"message\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals(\"localizedMessage\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals(\"stackTrace\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue(\"Probably run away loop in test. StackTrack Array was not properly closed.\", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals(\"suppressed\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail(\"Unexpected field name '\" + name + \"'\"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail(\"Unexpected field, name '\" + name + \"'\"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader(\"{\\"v\\":\\"\" + value + \"\\"}\"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader(\"[ \\"Infinity\\" ]\"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testCatchAndRethrow() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule(\"test-exceptions\", Version.unknownVersion()); [EOL]     module.addSerializer(Bean.class, new SerializerWithErrors()); [EOL]     mapper.registerModule(module); [EOL]     try { [EOL]         StringWriter sw = new StringWriter(); [EOL]         Bean[] b = { new Bean() }; [EOL]         List<Bean[]> l = new ArrayList<Bean[]>(); [EOL]         l.add(b); [EOL]         mapper.writeValue(sw, l); [EOL]         fail(\"Should have gotten an exception\"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, \"test string\"); [EOL]         Throwable root = e.getCause(); [EOL]         assertNotNull(root); [EOL]         if (!(root instanceof IllegalArgumentException)) { [EOL]             fail(\"Wrapped exception not IAE, but \" + root.getClass()); [EOL]         } [EOL]     } [EOL] }
public void testAnnotationsDisabled() throws Exception { [EOL]     assertTrue(MAPPER.isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     result = writeAndMap(m2, new AnnoBean()); [EOL]     assertEquals(1, result.size()); [EOL] }
public void testMergeWithRename() { [EOL]     POJOPropertiesCollector coll = collector(mapper, MergedProperties.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get(\"x\"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSuperTypeDetectionClass() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(2, _countSupers(sub)); [EOL]     assertSame(MyStringIntMap.class, sub.getRawClass()); [EOL]     HierarchicType sup = sub.getSuperType(); [EOL]     assertSame(MyStringXMap.class, sup.getRawClass()); [EOL]     HierarchicType sup2 = sup.getSuperType(); [EOL]     assertSame(HashMap.class, sup2.getRawClass()); [EOL]     assertNull(sup2.getSuperType()); [EOL] }
public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testListAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = \"[\n\" + asJSONObjectValueString(m, \"@classy\", Cat.class.getName(), \"name\", \"Hello\", \"furColor\", \"white\") + \",\n\" + asJSONObjectValueString(m, \"boneCount\", Integer.valueOf(1), \"@classy\", Dog.class.getName(), \"name\", \"Bob\") + \",\n\" + asJSONObjectValueString(m, \"@classy\", Fish.class.getName()) + \", null\n]\"; [EOL]     JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class); [EOL]     List<Animal> animals = m.readValue(JSON, expType); [EOL]     assertNotNull(animals); [EOL]     assertEquals(4, animals.size()); [EOL]     Cat c = (Cat) animals.get(0); [EOL]     assertEquals(\"Hello\", c.name); [EOL]     assertEquals(\"white\", c.furColor); [EOL]     Dog d = (Dog) animals.get(1); [EOL]     assertEquals(\"Bob\", d.name); [EOL]     assertEquals(1, d.boneCount); [EOL]     Fish f = (Fish) animals.get(2); [EOL]     assertNotNull(f); [EOL]     assertNull(animals.get(3)); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, \"Bob\").addValue(\"number\", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue(\"{ }\", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals(\"Bob\", bean.name); [EOL] }
public void testPropertyAnnotationSimple() throws Exception { [EOL]     String json = objectWriter().writeValueAsString(new PointWrapper(3, 4)); [EOL]     assertEquals(\"{\\"value\\":[3,4]}\", json); [EOL] }
public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\"); [EOL]     assertEquals(date, d); [EOL] }
public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \"{\\"id\\": 5, \\"defaultValue\\": { \\"value\\": \\"123\\" } }\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\"should have raised exception instead value was set to \" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"not numeric\"); [EOL]     } [EOL] }
public void testBeanAsObject() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String str = m.writeValueAsString(new Object[] { new StringBean(\"abc\") }); [EOL]     _verifySerializationAsMap(str); [EOL]     Object ob = m.readValue(str, Object[].class); [EOL]     assertNotNull(ob); [EOL]     Object[] result = (Object[]) ob; [EOL]     assertNotNull(result[0]); [EOL]     assertEquals(StringBean.class, result[0].getClass()); [EOL]     assertEquals(\"abc\", ((StringBean) result[0]).name); [EOL] }
public void testBinaryPojo() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 1, 2, 100 }; [EOL]     POJONode n = new POJONode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     Object pojo = jp.getEmbeddedObject(); [EOL]     assertSame(data, pojo); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testModifyCollectionDeserializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule(\"test\").setDeserializerModifier(new CollectionDeserializerModifier())); [EOL]     List<?> result = mapper.readValue(\"[1,2]\", List.class); [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(\"foo\", result.get(0)); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals(\"APs=\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testReadSimpleRootValue() throws Exception { [EOL]     String json = \"[false,\\"Bubba\\",1,2]\"; [EOL]     FlatPojo p = MAPPER.readValue(json, FlatPojo.class); [EOL]     assertFalse(p.complete); [EOL]     assertEquals(\"Bubba\", p.name); [EOL]     assertEquals(1, p.x); [EOL]     assertEquals(2, p.y); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testSimpleViaObjectMapper() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectNode n = mapper.getNodeFactory().objectNode(); [EOL]     n.put(\"number\", 15); [EOL]     n.put(\"string\", \"abc\"); [EOL]     ObjectNode n2 = n.putObject(\"ob\"); [EOL]     n2.putArray(\"arr\"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = mapper.getFactory().createGenerator(sw); [EOL]     mapper.writeTree(jg, n); [EOL]     Map<String, Object> result = (Map<String, Object>) mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals(\"abc\", result.get(\"string\")); [EOL]     assertEquals(Integer.valueOf(15), result.get(\"number\")); [EOL]     Map<String, Object> ob = (Map<String, Object>) result.get(\"ob\"); [EOL]     assertEquals(1, ob.size()); [EOL]     List<Object> list = (List<Object>) ob.get(\"arr\"); [EOL]     assertEquals(0, list.size()); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"xyz:\")); [EOL]     assertEquals(quote(\"xyz:456\"), mapper.writeValueAsString(new MyBean(\"456\"))); [EOL] }
public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \"root\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \"leaf\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\"{\\"id\\":1,\\"name\\":\\"root\\",\\"parent\\":null,\\"child\\":\" + \"{\\"id\\":2,\\"name\\":\\"leaf\\",\\"parent\\":1,\\"child\\":null}}\", json); [EOL] }
public void testFinalFieldIgnoral() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertTrue(mapper.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)); [EOL]     mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     try { [EOL]         mapper.readValue(\"{\\"x\\":2}\", FixedPoint.class); [EOL]         fail(\"Should not try to use final field\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"unrecognized field \\"x\\"\"); [EOL]     } [EOL] }
public void testSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setHandlerInstantiator(new MyInstantiator(\"xyz:\")); [EOL]     assertEquals(quote(\"xyz:456\"), mapper.writeValueAsString(new MyBean(\"456\"))); [EOL] }
public void testRootUsingExplicitConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer().withRootName(\"wrapper\"); [EOL]     String json = writer.writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"wrapper\\":{\\"a\\":3}}\", json); [EOL]     ObjectReader reader = mapper.reader(Bean.class).withRootName(\"wrapper\"); [EOL]     Bean bean = reader.readValue(json); [EOL]     assertNotNull(bean); [EOL]     ObjectMapper wrapping = rootMapper(); [EOL]     json = wrapping.writer().withRootName(\"something\").writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"something\\":{\\"a\\":3}}\", json); [EOL]     json = wrapping.writer().withRootName(\"\").writeValueAsString(new Bean()); [EOL]     assertEquals(\"{\\"a\\":3}\", json); [EOL]     bean = wrapping.reader(Bean.class).withRootName(\"\").readValue(json); [EOL]     assertNotNull(bean); [EOL] }
public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\"\\"value1\\"\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\"value1\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll(\"\\"\", \"'\"); [EOL]     assertEquals(\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\", json); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); [EOL]     TokenBuffer buf = new TokenBuffer(mapper); [EOL]     buf.writeStartObject(); [EOL]     buf.writeNumberField(\"num\", 42); [EOL]     buf.writeEndObject(); [EOL]     String json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     ObjectHolder holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     JsonParser jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeEndArray(); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf = new TokenBuffer(mapper); [EOL]     buf.writeNumber(321); [EOL]     json = mapper.writeValueAsString(new ObjectHolder(buf)); [EOL]     holder = mapper.readValue(json, ObjectHolder.class); [EOL]     assertNotNull(holder.value); [EOL]     assertSame(TokenBuffer.class, holder.value.getClass()); [EOL]     jp = ((TokenBuffer) holder.value).asParser(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(321, jp.getIntValue()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testEmptyCollection() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(SerializationFeature.INDENT_OUTPUT, true); [EOL]     List<User> friends = new ArrayList<User>(); [EOL]     friends.add(new DefaultUser(\"Joe Hildebrandt\", null)); [EOL]     friends.add(new DefaultEmployee(\"Richard Nasr\", null, \"MDA\")); [EOL]     User user = new DefaultEmployee(\"John Vanspronssen\", friends, \"MDA\"); [EOL]     String json = mapper.writeValueAsString(user); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.registerSubtypes(DefaultEmployee.class); [EOL]     mapper.registerSubtypes(DefaultUser.class); [EOL]     User result = mapper.readValue(json, User.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(DefaultEmployee.class, result.getClass()); [EOL]     friends = result.getFriends(); [EOL]     assertEquals(2, friends.size()); [EOL]     assertEquals(DefaultUser.class, friends.get(0).getClass()); [EOL]     assertEquals(DefaultEmployee.class, friends.get(1).getClass()); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals(\"APs=\", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testCopy() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     ObjectMapper m2 = m.copy(); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); [EOL]     assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)); [EOL]     assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL]     assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE)); [EOL]     assertNotSame(m.getFactory(), m2.getFactory()); [EOL]     assertEquals(0, m.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m.getDeserializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getDeserializationConfig().mixInCount()); [EOL]     m.addMixInAnnotations(String.class, Integer.class); [EOL]     assertEquals(1, m.getSerializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getSerializationConfig().mixInCount()); [EOL]     assertEquals(1, m.getDeserializationConfig().mixInCount()); [EOL]     assertEquals(0, m2.getDeserializationConfig().mixInCount()); [EOL] }
public void testParametricTypes() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructParametricType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     JavaType strC = tf.constructType(String.class); [EOL]     assertEquals(1, t.containedTypeCount()); [EOL]     assertEquals(strC, t.containedType(0)); [EOL]     assertNull(t.containedType(1)); [EOL]     JavaType t2 = tf.constructParametricType(Map.class, strC, t); [EOL]     assertEquals(MapType.class, t2.getClass()); [EOL]     assertEquals(2, t2.containedTypeCount()); [EOL]     assertEquals(strC, t2.containedType(0)); [EOL]     assertEquals(t, t2.containedType(1)); [EOL]     assertNull(t2.containedType(2)); [EOL]     JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class); [EOL]     assertEquals(SimpleType.class, custom.getClass()); [EOL]     assertEquals(1, custom.containedTypeCount()); [EOL]     assertEquals(strC, custom.containedType(0)); [EOL]     assertNull(custom.containedType(1)); [EOL]     assertEquals(\"X\", custom.containedTypeName(0)); [EOL]     try { [EOL]         tf.constructParametricType(Map.class, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \"Need exactly 2 parameter types for Map types\"); [EOL]     } [EOL]     try { [EOL]         tf.constructParametricType(SingleArgGeneric.class, strC, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \"expected 1 parameters, was given 2\"); [EOL]     } [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testSimpleBean() throws Exception { [EOL]     ArrayList<Object> misc = new ArrayList<Object>(); [EOL]     misc.add(\"xyz\"); [EOL]     misc.add(42); [EOL]     misc.add(null); [EOL]     misc.add(Boolean.TRUE); [EOL]     TestBean bean = new TestBean(13, -900L, \"\\"test\\"\", new URI(\"http://foobar.com\"), misc); [EOL]     String json = MAPPER.writeValueAsString(bean); [EOL]     TestBean result = MAPPER.readValue(json, TestBean.class); [EOL]     assertEquals(bean, result); [EOL] }
public void testNodeConvert() throws Exception { [EOL]     ObjectNode src = (ObjectNode) MAPPER.readTree(\"{}\"); [EOL]     TreeNode node = src; [EOL]     ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class); [EOL]     assertSame(src, result); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = \"{\\"c\\":3,\\"a\\":2,\\"b\\":-9}\"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\"\\"value1\\"\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\"value1\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\"{\\"enumA\\":\\"value\\"}\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\"value\", value.get(EnumWithCreator.A)); [EOL] }
public void testCustomMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator())); [EOL]     MyMap result = mapper.readValue(\"{ \\"a\\":\\"b\\" }\", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(MyMap.class, result.getClass()); [EOL]     assertEquals(1, result.size()); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader(\"{\\"v\\":\\"\" + value + \"\\"}\"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader(\"[ \\"Infinity\\" ]\"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testSpecialMap() throws IOException { [EOL]     final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class); [EOL]     _doTestUntyped(map); [EOL] }
public void testMixinMethodInheritance() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new Beano2()); [EOL]     assertEquals(2, result.size()); [EOL]     assertTrue(result.containsKey(\"id\")); [EOL]     assertTrue(result.containsKey(\"name\")); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue(\"{\\"booleanValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue(\"{\\"byteValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue(\"{\\"charValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue(\"{\\"shortValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue(\"{\\"intValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue(\"{\\"longValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue(\"{\\"floatValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue(\"{\\"doubleValue\\":\\"\\"}\", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertEquals(\"2\", map.get(\"b\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertNull(map.get(\"b\")); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, \"@class\"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println(\"deserialised list size = \" + result.size()); [EOL] }
public void testPOJO() { [EOL]     POJONode n = new POJONode(\"x\"); [EOL]     assertStandardEquals(n); [EOL]     assertEquals(n, new POJONode(\"x\")); [EOL]     assertEquals(\"x\", n.asText()); [EOL]     assertEquals(\"x\", n.toString()); [EOL]     assertEquals(new POJONode(null), new POJONode(null)); [EOL]     assertNodeNumbersForNonNumeric(n); [EOL]     assertNodeNumbers(new POJONode(Integer.valueOf(123)), 123, 123.0); [EOL] }
public void testGettersWithoutSetters() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     GettersWithoutSetters bean = new GettersWithoutSetters(123); [EOL]     assertFalse(m.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)); [EOL]     assertEquals(\"{\\"a\\":3,\\"b\\":4,\\"c\\":5,\\"d\\":6}\", m.writeValueAsString(bean)); [EOL]     m = new ObjectMapper(); [EOL]     m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS); [EOL]     assertEquals(\"{\\"a\\":3,\\"c\\":5,\\"d\\":6}\", m.writeValueAsString(bean)); [EOL] }
public void testSuperInterfaces() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { BaseInt.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\"); [EOL]     assertEquals(date, d); [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue(\"[ 1, 2 ]\", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail(\"Expected an exception, but got result value: \" + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, \"START_ARRAY\"); [EOL]     } [EOL] }
public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue(\"{\\"beans\\":[\\"x\\"]}\", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals(\"list=x\", bean.beans.get(0).value); [EOL]     bean = mapper.readValue(\"{\\"beans\\":[\\"x\\",\\"y\\",\\"z\\"]}\", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals(\"list=x\", bean.beans.get(0).value); [EOL]     assertEquals(\"list=y\", bean.beans.get(1).value); [EOL]     assertEquals(\"list=z\", bean.beans.get(2).value); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testForFactoryAndCtor() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     BaseClass result; [EOL]     result = m.readValue(\"\\"string\\"\", BaseClass.class); [EOL]     assertEquals(\"string...\", result._a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(BaseClass.class, MixIn.class); [EOL]     result = m.readValue(\"\\"string\\"\", BaseClass.class); [EOL]     assertEquals(\"stringX\", result._a); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testJackson744() throws Exception { [EOL]     BasicBeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue744Bean.class)); [EOL]     assertNotNull(beanDesc); [EOL]     AnnotatedMethod setter = beanDesc.findAnySetter(); [EOL]     assertNotNull(setter); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(\" { \\"values\\" : { \\"a\\": 1, \\"b\\":2 } } \", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get(\"a\").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get(\"a\"))._a); [EOL]     assertEquals(ValueClass.class, map.get(\"b\").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get(\"b\"))._a); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testEmptyStringForWrappers() throws IOException { [EOL]     WrappersBean bean; [EOL]     bean = mapper.readValue(\"{\\"booleanValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.booleanValue); [EOL]     bean = mapper.readValue(\"{\\"byteValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.byteValue); [EOL]     bean = mapper.readValue(\"{\\"charValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.charValue); [EOL]     bean = mapper.readValue(\"{\\"shortValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.shortValue); [EOL]     bean = mapper.readValue(\"{\\"intValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.intValue); [EOL]     bean = mapper.readValue(\"{\\"longValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.longValue); [EOL]     bean = mapper.readValue(\"{\\"floatValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.floatValue); [EOL]     bean = mapper.readValue(\"{\\"doubleValue\\":\\"\\"}\", WrappersBean.class); [EOL]     assertNull(bean.doubleValue); [EOL] }
public void testWithNaturalScalar118() throws Exception { [EOL]     ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13)); [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Integer); [EOL]     input = new ExternalTypeWithNonPOJO(Boolean.TRUE); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof Boolean); [EOL]     input = new ExternalTypeWithNonPOJO(\"foobar\"); [EOL]     json = MAPPER.writeValueAsString(input); [EOL]     assertNotNull(json); [EOL]     result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class); [EOL]     assertNotNull(result.value); [EOL]     assertTrue(result.value instanceof String); [EOL]     assertEquals(\"foobar\", result.value); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testSimpleNumberBean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     NumberBean result = mapper.readValue(\"{\\"number\\":17}\", NumberBean.class); [EOL]     assertEquals(17, result._number); [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue(\"{\\"intValue\\":null, \\"booleanValue\\":null, \\"doubleValue\\":null}\", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue(\"{\\"byteValue\\":null, \\"longValue\\":null, \\"floatValue\\":null}\", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue(\"{\\"booleanValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for boolean + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type boolean\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"byteValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for byte + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type byte\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"charValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for char + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type char\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"shortValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for short + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type short\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"intValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for int + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type int\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"longValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for long + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type long\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"floatValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for float + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type float\"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue(\"{\\"doubleValue\\":null}\", PrimitivesBean.class); [EOL]         fail(\"Expected failure for double + null\"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, \"Can not map JSON null into type double\"); [EOL]     } [EOL] }
public void testListOfNumbers() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0)); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals(\"{\\"nums\\":[\\"java.util.ArrayList\\",[[\\"java.lang.Long\\",1],2,3.0]]}\", json); [EOL]     ListOfNumbers output = m.readValue(json, ListOfNumbers.class); [EOL]     assertNotNull(output.nums); [EOL]     assertEquals(3, output.nums.size()); [EOL]     assertEquals(Long.valueOf(1L), output.nums.get(0)); [EOL]     assertEquals(Integer.valueOf(2), output.nums.get(1)); [EOL]     assertEquals(Double.valueOf(3.0), output.nums.get(2)); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \"root\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \"leaf\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\"{\\"id\\":1,\\"name\\":\\"root\\",\\"parent\\":null,\\"child\\":\" + \"{\\"id\\":2,\\"name\\":\\"leaf\\",\\"parent\\":1,\\"child\\":null}}\", json); [EOL] }
public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \"{\\"id\\": 5, \\"defaultValue\\": { \\"value\\": \\"123\\" } }\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\"should have raised exception instead value was set to \" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"not numeric\"); [EOL]     } [EOL] }
public void testCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(ArrayList.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     t = tf.constructType(new TypeReference<ArrayList<String>>() { [EOL]     }); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     JavaType elemType = ((CollectionType) t).getContentType(); [EOL]     assertNotNull(elemType); [EOL]     assertSame(SimpleType.class, elemType.getClass()); [EOL]     assertSame(String.class, elemType.getRawClass()); [EOL]     t = tf.constructCollectionType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(String.class, ((CollectionType) t).getContentType().getRawClass()); [EOL] }
public void testWithCreator() throws IOException { [EOL]     final String MSG = \"the message\"; [EOL]     String json = MAPPER.writeValueAsString(new MyException(MSG, 3)); [EOL]     MyException result = MAPPER.readValue(json, MyException.class); [EOL]     assertEquals(MSG, result.getMessage()); [EOL]     assertEquals(3, result.value); [EOL]     assertEquals(1, result.stuff.size()); [EOL]     assertEquals(result.getFoo(), result.stuff.get(\"foo\")); [EOL] }
public void testDataBindingUsage() throws Exception { [EOL]     ObjectMapper objectMapper = createObjectMapper(null); [EOL]     String result = serializeWithObjectMapper(new ComplexTestData(), Views.View.class, objectMapper); [EOL]     assertEquals(-1, result.indexOf(\"nameHidden\")); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree(\"{ \\"name\\" : \\"Tatu\\", \n\" + \"\\"magicNumber\\" : 42,\" + \"\\"kids\\" : [ \\"Leo\\", \\"Lila\\", \\"Leia\\" ] \n\" + \"}\"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals(\"Tatu\", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals(\"Leo\", tatu.kids.get(0)); [EOL]     assertEquals(\"Lila\", tatu.kids.get(1)); [EOL]     assertEquals(\"Leia\", tatu.kids.get(2)); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\"c3VyZS4=\", byte[].class); [EOL]     byte[] exp = \"sure.\".getBytes(\"Ascii\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testTypedMaps() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     Map<String, Issue822Interface> map = new HashMap<String, Issue822Interface>(); [EOL]     map.put(\"a\", new Issue822Impl()); [EOL]     String listJson = mapper.writerWithType(new TypeReference<Map<String, Issue822Interface>>() { [EOL]     }).writeValueAsString(map); [EOL]     assertEquals(\"{\\"a\\":{\\"a\\":3}}\", listJson); [EOL] }
public void testIssue476() throws Exception { [EOL]     final String JSON = \"{\\"value1\\" : {\\"name\\" : \\"fruit\\", \\"value\\" : \\"apple\\"}, \\"value2\\" : {\\"name\\" : \\"color\\", \\"value\\" : \\"red\\"}}\"; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new Issue476Module()); [EOL]     mapper.readValue(JSON, Issue476Bean.class); [EOL]     assertEquals(2, Issue476Deserializer.propCount); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testMixinMethodInheritance() throws IOException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class); [EOL]     Map<String, Object> result; [EOL]     result = writeAndMap(mapper, new Beano2()); [EOL]     assertEquals(2, result.size()); [EOL]     assertTrue(result.containsKey(\"id\")); [EOL]     assertTrue(result.containsKey(\"name\")); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO(\"foobar\"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, \"xxx\"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAlwaysIdForTree() throws Exception { [EOL]     TreeNode root = new TreeNode(null, 1, \"root\"); [EOL]     TreeNode leaf = new TreeNode(root, 2, \"leaf\"); [EOL]     root.child = leaf; [EOL]     String json = MAPPER.writeValueAsString(root); [EOL]     assertEquals(\"{\\"id\\":1,\\"name\\":\\"root\\",\\"parent\\":null,\\"child\\":\" + \"{\\"id\\":2,\\"name\\":\\"leaf\\",\\"parent\\":1,\\"child\\":null}}\", json); [EOL] }
public void testIOException() throws IOException { [EOL]     IOException ioe = new IOException(\"TEST\"); [EOL]     String json = MAPPER.writeValueAsString(ioe); [EOL]     IOException result = MAPPER.readValue(json, IOException.class); [EOL]     assertEquals(ioe.getMessage(), result.getMessage()); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals(\"uri\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"url\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testNull\")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals(\"testString\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testBoolean\")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals(\"testEnum\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testInteger\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals(\"testLong\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals(\"testBigInteger\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals(\"testBigDecimal\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals(\"testCharacter\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testShort\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals(\"testByte\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals(\"testFloat\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals(\"testDouble\")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals(\"testStringBuffer\")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals(\"testError\")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals(\"cause\")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals(\"message\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals(\"localizedMessage\")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals(\"stackTrace\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue(\"Probably run away loop in test. StackTrack Array was not properly closed.\", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals(\"suppressed\")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail(\"Unexpected field name '\" + name + \"'\"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail(\"Unexpected field, name '\" + name + \"'\"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { \"me\", \"you\", \"him\" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \"you\"); [EOL]     Assert.assertArrayEquals(new String[] { \"you\", \"me\", \"him\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \"me\"); [EOL]     Assert.assertArrayEquals(new String[] { \"me\", \"you\", \"him\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \"him\"); [EOL]     Assert.assertArrayEquals(new String[] { \"him\", \"me\", \"you\" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, \"foobar\"); [EOL]     Assert.assertArrayEquals(new String[] { \"foobar\", \"me\", \"you\", \"him\" }, newarr); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals(\"[1,2,3,4]\", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testJackson667() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); [EOL]     String json = mapper.writeValueAsString(new SetBean(\"abc\")); [EOL]     SetBean bean = mapper.readValue(json, SetBean.class); [EOL]     assertNotNull(bean); [EOL]     assertTrue(bean.names instanceof HashSet); [EOL] }
public void testSimpleBuilder() throws Exception { [EOL]     ValueClassXY value = MAPPER.readValue(\"[1,2]\", ValueClassXY.class); [EOL]     assertEquals(2, value._x); [EOL]     assertEquals(3, value._y); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\"B\"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\"B\"), Alpha.class)); [EOL] }
public void testPropertyRemoval() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\"))); [EOL]     Bean bean = mapper.readValue(\"{\\"b\\":\\"2\\"}\", Bean.class); [EOL]     assertEquals(\"2\", bean.b); [EOL]     assertEquals(\"a\", bean.a); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals(\"java.util.Calendar\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\"java.util.ArrayList<java.lang.Object>\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testDeepUnwrapping() throws Exception { [EOL]     DeepUnwrapping bean = mapper.readValue(\"{\\"x\\":3,\\"name\\":\\"Bob\\",\\"y\\":27}\", DeepUnwrapping.class); [EOL]     Unwrapping uw = bean.unwrapped; [EOL]     assertNotNull(uw); [EOL]     assertEquals(\"Bob\", uw.name); [EOL]     Location loc = uw.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(3, loc.x); [EOL]     assertEquals(27, loc.y); [EOL] }
public void testImmutable() throws Exception { [EOL]     final String json = \"{\\"value\\":13}\"; [EOL]     ValueImmutable value = mapper.readValue(json, ValueImmutable.class); [EOL]     assertEquals(13, value.value); [EOL] }
public void testDouble() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     double value = 3.04; [EOL]     JsonNode result = mapper.readTree(String.valueOf(value)); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isNull()); [EOL]     assertType(result, DoubleNode.class); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isDouble()); [EOL]     assertFalse(result.isInt()); [EOL]     assertFalse(result.isLong()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.doubleValue()); [EOL]     assertEquals(value, result.numberValue().doubleValue()); [EOL]     assertEquals((int) value, result.intValue()); [EOL]     assertEquals((long) value, result.longValue()); [EOL]     assertEquals(String.valueOf(value), result.asText()); [EOL]     assertEquals(result, DoubleNode.valueOf(value)); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testBeanAsObject() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String str = m.writeValueAsString(new Object[] { new StringBean(\"abc\") }); [EOL]     _verifySerializationAsMap(str); [EOL]     Object ob = m.readValue(str, Object[].class); [EOL]     assertNotNull(ob); [EOL]     Object[] result = (Object[]) ob; [EOL]     assertNotNull(result[0]); [EOL]     assertEquals(StringBean.class, result[0].getClass()); [EOL]     assertEquals(\"abc\", ((StringBean) result[0]).name); [EOL] }
@SuppressWarnings(\"unchecked\") [EOL] public void testDefaultExclusion() throws IOException { [EOL]     MixedBean bean = new MixedBean(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.writerWithView(ViewA.class).writeValue(sw, bean); [EOL]     Map<String, Object> map = mapper.readValue(sw.toString(), Map.class); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertEquals(\"2\", map.get(\"b\")); [EOL]     mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false); [EOL]     String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean); [EOL]     map = mapper.readValue(json, Map.class); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(\"1\", map.get(\"a\")); [EOL]     assertNull(map.get(\"b\")); [EOL] }
public void testSimpleClass() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType baseType = tf.constructType(BaseType.class); [EOL]     assertSame(BaseType.class, baseType.getRawClass()); [EOL]     assertTrue(baseType.hasRawClass(BaseType.class)); [EOL]     assertFalse(baseType.isArrayType()); [EOL]     assertFalse(baseType.isContainerType()); [EOL]     assertFalse(baseType.isEnumType()); [EOL]     assertFalse(baseType.isInterface()); [EOL]     assertFalse(baseType.isPrimitive()); [EOL]     assertNull(baseType.getContentType()); [EOL]     assertNull(baseType.getValueHandler()); [EOL]     assertSame(baseType, baseType.narrowBy(BaseType.class)); [EOL]     assertSame(baseType, baseType.widenBy(BaseType.class)); [EOL]     try { [EOL]         baseType.narrowBy(SubType.class); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, \"should never be called\"); [EOL]     } [EOL] }
public void testUpdatingWithViews() throws Exception { [EOL]     Updateable bean = new Updateable(); [EOL]     bean.num = 100; [EOL]     bean.str = \"test\"; [EOL]     Updateable result = MAPPER.readerForUpdating(bean).withView(TextView.class).readValue(\"{\\"num\\": 10, \\"str\\":\\"foobar\\"}\"); [EOL]     assertSame(bean, result); [EOL]     assertEquals(100, bean.num); [EOL]     assertEquals(\"foobar\", bean.str); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testScalarsWithTyping() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     DynamicWrapper result; [EOL]     json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(\"abc\")); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new DynamicWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, DynamicWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testScalarsViaAbstractType() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String json; [EOL]     AbstractWrapper result; [EOL]     json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Integer.valueOf(3), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(\"abc\")); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(\"abc\", result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Boolean.TRUE, result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L))); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(Long.valueOf(7), result.value); [EOL]     json = m.writeValueAsString(new AbstractWrapper(TestEnum.B)); [EOL]     result = m.readValue(json, AbstractWrapper.class); [EOL]     assertEquals(TestEnum.B, result.value); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testEnumHandling() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setAnnotationIntrospector(new LcEnumIntrospector()); [EOL]     assertEquals(\"\\"value1\\"\", mapper.writeValueAsString(EnumExample.VALUE1)); [EOL]     EnumExample result = mapper.readValue(quote(\"value1\"), EnumExample.class); [EOL]     assertEquals(EnumExample.VALUE1, result); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert(\"c3VyZS4=\", byte[].class); [EOL]     byte[] exp = \"sure.\".getBytes(\"Ascii\"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testTokenBuffer() throws Exception { [EOL]     JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC); [EOL]     TokenBuffer tb = new TokenBuffer(null); [EOL]     while (jp.nextToken() != null) { [EOL]         tb.copyCurrentEvent(jp); [EOL]     } [EOL]     String str = serializeAsString(tb); [EOL]     verifyJsonSpecSampleDoc(createParserUsingReader(str), true); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = \"{ \\"petType\\": \\"dog\\",\n\" + \"\\"pet\\": { \\"name\\": \\"Pluto\\" }\n}\"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals(\"dog\", result.petType); [EOL] }
public void testCustomMapInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator())); [EOL]     MyMap result = mapper.readValue(\"{ \\"a\\":\\"b\\" }\", MyMap.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(MyMap.class, result.getClass()); [EOL]     assertEquals(1, result.size()); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue(\"{\\"a\\":true }\", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals(\"a\", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals(\"{\\"a\\":\\"a\\",\\"b\\":\\"b\\"}\", mapper.writeValueAsString(bean)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\"B\"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote(\"B\"), Alpha.class)); [EOL] }
public void testJackson703() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class)); [EOL]     assertNotNull(beanDesc); [EOL]     Jackson703 bean = new Jackson703(); [EOL]     String json = mapper.writeValueAsString(bean); [EOL]     assertNotNull(json); [EOL] }
public void testSimpleUUIDForClassRoundTrip() throws Exception { [EOL]     UUIDNode root = new UUIDNode(1); [EOL]     UUIDNode child1 = new UUIDNode(2); [EOL]     UUIDNode child2 = new UUIDNode(3); [EOL]     root.first = child1; [EOL]     root.second = child2; [EOL]     child1.parent = root; [EOL]     child2.parent = root; [EOL]     child1.first = child2; [EOL]     String json = mapper.writeValueAsString(root); [EOL]     UUIDNode result = mapper.readValue(json, UUIDNode.class); [EOL]     assertEquals(1, result.value); [EOL]     UUIDNode result2 = result.first; [EOL]     UUIDNode result3 = result.second; [EOL]     assertNotNull(result2); [EOL]     assertNotNull(result3); [EOL]     assertEquals(2, result2.value); [EOL]     assertEquals(3, result3.value); [EOL]     assertSame(result, result2.parent); [EOL]     assertSame(result, result3.parent); [EOL]     assertSame(result3, result2.first); [EOL] }
public void testTextAsBinary() throws Exception { [EOL]     TextNode n = new TextNode(\"   APs=\n\"); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(new byte[] { 0, -5 }, data); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL]     n = new TextNode(\"?!??\"); [EOL]     jp = n.traverse(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBinaryValue(); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"Illegal character\"); [EOL]     } [EOL] }
public void testHandlingOfUnrecognized() throws Exception { [EOL]     UnrecognizedPropertyException exc = null; [EOL]     try { [EOL]         new ObjectMapper().readValue(\"{\\"bar\\":3}\", Bean.class); [EOL]     } catch (UnrecognizedPropertyException e) { [EOL]         exc = e; [EOL]     } [EOL]     if (exc == null) { [EOL]         fail(\"Should have failed binding\"); [EOL]     } [EOL]     assertEquals(\"bar\", exc.getUnrecognizedPropertyName()); [EOL]     assertEquals(Bean.class, exc.getReferringClass()); [EOL]     verifyException(exc, \"propX\"); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, \"   17\"); [EOL]     map.put(AB.B, \" -1\"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(\" -1\", bean.B); [EOL] }
public void testIntArray() throws Exception { [EOL]     assertEquals(\"[0,-3]\", serializeAsString(MAPPER, new int[] { 0, -3 })); [EOL]     assertEquals(\"[13,9]\", serializeAsString(MAPPER, new Integer[] { 13, 9 })); [EOL] }
public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = \"{\\"id\\": 5, \\"defaultValue\\": { \\"value\\": \\"123\\" } }\"; [EOL]     try { [EOL]         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class); [EOL]         fail(\"should have raised exception instead value was set to \" + result.defaultValue.value.decimal.toString()); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, \"not numeric\"); [EOL]     } [EOL] }
public void testParse() { [EOL]     Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\"); [EOL]     assertEquals(date, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\"); [EOL]     assertEquals(dateZeroMillis, d); [EOL]     d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\"); [EOL]     assertEquals(date, d); [EOL] }
public void testIterator() throws IOException { [EOL]     StringWriter sw = new StringWriter(); [EOL]     ArrayList<Integer> l = new ArrayList<Integer>(); [EOL]     l.add(1); [EOL]     l.add(-9); [EOL]     l.add(0); [EOL]     MAPPER.writeValue(sw, l.iterator()); [EOL]     assertEquals(\"[1,-9,0]\", sw.toString().trim()); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject(\"inner\").put(\"value\", \"test\"); [EOL]     n.putObject(\"unknown\").putNull(\"inner\"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals(\"test\", obj.inner.value); [EOL] }
public void testUnknownHandlingDefault() throws Exception { [EOL]     try { [EOL]         MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, \"Unrecognized field \\"foo\\"\"); [EOL]     } [EOL] }
public void testIntPrimitive() throws Exception { [EOL]     IntBean result = MAPPER.readValue(new StringReader(\"{\\"v\\":3}\"), IntBean.class); [EOL]     assertEquals(3, result._v); [EOL]     result = MAPPER.readValue(new StringReader(\"{\\"v\\":null}\"), IntBean.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(0, result._v); [EOL]     int[] array = MAPPER.readValue(new StringReader(\"[ null ]\"), int[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(0, array[0]); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = \"mouse\"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = \"mickey\"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testEnumWithCreatorMaps() throws Exception { [EOL]     java.util.HashMap<EnumWithCreator, String> value = MAPPER.readValue(\"{\\"enumA\\":\\"value\\"}\", new TypeReference<java.util.HashMap<EnumWithCreator, String>>() { [EOL]     }); [EOL]     assertEquals(\"value\", value.get(EnumWithCreator.A)); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals(\"a\", props.get(0).getName()); [EOL]     assertEquals(\"b\", props.get(1).getName()); [EOL]     assertEquals(\"c\", props.get(2).getName()); [EOL]     assertEquals(\"d\", props.get(3).getName()); [EOL] }
public void testNonNullByClass() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new NoNullsBean()); [EOL]     assertEquals(1, result.size()); [EOL]     assertFalse(result.containsKey(\"a\")); [EOL]     assertNull(result.get(\"a\")); [EOL]     assertTrue(result.containsKey(\"b\")); [EOL]     assertNull(result.get(\"b\")); [EOL] }
public void testSerializeAsArrayWithSingleProperty() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     String json = mapper.writeValueAsString(new SingleBean()); [EOL]     assertEquals(\"\\"foo\\"\", json); [EOL] }
public void testSimpleArray() throws IOException { [EOL]     TokenBuffer buf = new TokenBuffer(null); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     buf.writeStartArray(); [EOL]     assertTrue(buf.getOutputContext().inArray()); [EOL]     buf.writeEndArray(); [EOL]     assertTrue(buf.getOutputContext().inRoot()); [EOL]     JsonParser jp = buf.asParser(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inArray()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertTrue(jp.getParsingContext().inRoot()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBoolean(true); [EOL]     buf.writeNull(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL]     buf = new TokenBuffer(null); [EOL]     buf.writeStartArray(); [EOL]     buf.writeStartArray(); [EOL]     buf.writeBinary(new byte[3]); [EOL]     buf.writeEndArray(); [EOL]     buf.writeEndArray(); [EOL]     jp = buf.asParser(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     Object ob = jp.getEmbeddedObject(); [EOL]     assertNotNull(ob); [EOL]     assertTrue(ob instanceof byte[]); [EOL]     assertEquals(3, ((byte[]) ob).length); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     buf.close(); [EOL] }