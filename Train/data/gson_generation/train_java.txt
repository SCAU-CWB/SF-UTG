public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testDefaultJavaSqlDateSerialization() { [EOL]     java.sql.Date instant = new java.sql.Date(1259875082000L); [EOL]     String json = gson.toJson(instant); [EOL]     assertEquals("\"Dec 3, 2009\"", json); [EOL] }
public void testInnerClassExclusion() throws Exception { [EOL]     Gson gson = new GsonBuilder().disableInnerClassSerialization().create(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals("", result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNullsInArraySerialization() { [EOL]     String[] array = { "foo", null, "bar" }; [EOL]     String expected = "[\"foo\",null,\"bar\"]"; [EOL]     String json = gson.toJson(array); [EOL]     assertEquals(expected, json); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue"); [EOL]     assertEquals("\"Some\\nEscaped\\nValue\"", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal("1.333")); [EOL]     assertEquals("1.333", json.toString()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testAddingBooleanProperties() throws Exception { [EOL]     String propertyName = "property"; [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     jsonObj.addProperty(propertyName, true); [EOL]     assertTrue(jsonObj.has(propertyName)); [EOL]     JsonElement jsonElement = jsonObj.get(propertyName); [EOL]     assertNotNull(jsonElement); [EOL]     assertTrue(jsonElement.getAsBoolean()); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyExposedField"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testNumberDeserialization() { [EOL]     String json = "1"; [EOL]     Number expected = new Integer(json); [EOL]     Number actual = gson.fromJson(json, Number.class); [EOL]     assertEquals(expected.intValue(), actual.intValue()); [EOL]     json = String.valueOf(Long.MAX_VALUE); [EOL]     expected = new Long(json); [EOL]     actual = gson.fromJson(json, Number.class); [EOL]     assertEquals(expected.longValue(), actual.longValue()); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testEmptyStringDeserialization() throws Exception { [EOL]     Object object = gson.fromJson("", Object.class); [EOL]     assertNull(object); [EOL] }
public void testCallingNextBeyondAvailableInput() { [EOL]     parser.next(); [EOL]     parser.next(); [EOL]     try { [EOL]         parser.next(); [EOL]         fail("Parser should not go beyond available input"); [EOL]     } catch (NoSuchElementException expected) { [EOL]     } [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSkipExplicitlySkippedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyHiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testNonFiniteBoxedDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NaN)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NEGATIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.POSITIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testPrematurelyClosed() throws IOException { [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}")); [EOL]         reader.beginObject(); [EOL]         reader.close(); [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}")); [EOL]         reader.close(); [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]         reader.beginObject(); [EOL]         reader.nextName(); [EOL]         reader.peek(); [EOL]         reader.close(); [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testLocaleDeserializationWithLanguageCountry() { [EOL]     String json = "\"fr_CA\""; [EOL]     Locale locale = gson.fromJson(json, Locale.class); [EOL]     assertEquals(Locale.CANADA_FRENCH, locale); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testStrictComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testStringLongSerialization() throws Exception { [EOL]     JsonElement element = LongSerializationPolicy.STRING.serialize(1556L); [EOL]     assertTrue(element.isJsonPrimitive()); [EOL]     JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive(); [EOL]     assertFalse(jsonPrimitive.isNumber()); [EOL]     assertTrue(jsonPrimitive.isString()); [EOL]     assertEquals("1556", element.getAsString()); [EOL] }
public void testStringLongSerialization() throws Exception { [EOL]     JsonElement element = LongSerializationPolicy.STRING.serialize(1556L); [EOL]     assertTrue(element.isJsonPrimitive()); [EOL]     JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive(); [EOL]     assertFalse(jsonPrimitive.isNumber()); [EOL]     assertTrue(jsonPrimitive.isString()); [EOL]     assertEquals("1556", element.getAsString()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testSkipNonAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("hiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testDefaultJavaSqlTimeSerialization() { [EOL]     Time now = new Time(1259875082000L); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"01:18:02 PM\"", json); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testStrictNameValueSeparator() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("{\"a\"=>true}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testMixedCaseLiterals() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[True,TruE,False,FALSE,NULL,nulL]")); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(false, reader.nextBoolean()); [EOL]     assertEquals(false, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNulls() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.nullValue(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[null]", stringWriter.toString()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testTypeOverridding() throws Exception { [EOL]     String handler1 = "blah1"; [EOL]     String handler2 = "blah2"; [EOL]     paramMap.register(String.class, handler1); [EOL]     paramMap.register(String.class, handler2); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertEquals(handler2, paramMap.getHandlerFor(String.class)); [EOL] }
public void testNullField() throws Exception { [EOL]     try { [EOL]         new FieldAttributes(Foo.class, null); [EOL]         fail("Field parameter can not be null"); [EOL]     } catch (NullPointerException expected) { [EOL]     } [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testNeverSkipsField() throws Exception { [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(String.class, String.class.getFields()[0]))); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testMapDeserializationWithWildcardValues() { [EOL]     Type typeOfMap = new TypeToken<Map<String, ? extends Long>>() { [EOL]     }.getType(); [EOL]     Map<String, ? extends Long> map = gson.fromJson("{\"test\":123}", typeOfMap); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(new Long(123L), map.get("test")); [EOL] }
public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base>() { [EOL]  [EOL]         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) { [EOL]             JsonObject json = new JsonObject(); [EOL]             json.addProperty("value", src.baseValue); [EOL]             return json; [EOL]         } [EOL]     }).create(); [EOL]     Base b = new Base(); [EOL]     String json = gson.toJson(b); [EOL]     assertTrue(json.contains("value")); [EOL]     b = new Derived(); [EOL]     json = gson.toJson(b, Base.class); [EOL]     assertTrue(json.contains("value")); [EOL]     assertFalse(json.contains("derivedValue")); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testWriteHtmlSafe() { [EOL]     List<String> contents = Arrays.asList("<", ">", "&", "=", "'"); [EOL]     Type type = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     StringWriter writer = new StringWriter(); [EOL]     new Gson().toJson(contents, type, new JsonWriter(writer)); [EOL]     assertEquals("[\"\\u003c\",\"\\u003e\",\"\\u0026\",\"\\u003d\",\"\\u0027\"]", writer.toString()); [EOL]     writer = new StringWriter(); [EOL]     new GsonBuilder().disableHtmlEscaping().create().toJson(contents, type, new JsonWriter(writer)); [EOL]     assertEquals("[\"<\",\">\",\"&\",\"=\",\"'\"]", writer.toString()); [EOL] }
public void testBigIntegerInASingleElementArrayDeserialization() { [EOL]     BigInteger expected = new BigInteger("34343434343424242423432323243243242"); [EOL]     BigInteger actual = gson.fromJson("[34343434343424242423432323243243242]", BigInteger.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testToJsonTreeObjectType() { [EOL]     SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, "foo", 1.4F); [EOL]     JsonElement json = gson.toJsonTree(bag, BagOfPrimitives.class); [EOL]     assertTrue(json.isJsonObject()); [EOL]     JsonObject obj = json.getAsJsonObject(); [EOL]     Set<Entry<String, JsonElement>> children = obj.entrySet(); [EOL]     assertEquals(4, children.size()); [EOL]     assertContains(obj, new JsonPrimitive(10L)); [EOL]     assertContains(obj, new JsonPrimitive(5)); [EOL]     assertContains(obj, new JsonPrimitive(false)); [EOL]     assertContains(obj, new JsonPrimitive("foo")); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGetActualTypeForFirstTypeVariable() { [EOL]     assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE)); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testVersionedUntilSerialization() { [EOL]     Version1 target = new Version1(); [EOL]     Gson gson = builder.setVersion(1.29).create(); [EOL]     String json = gson.toJson(target); [EOL]     assertTrue(json.contains("\"a\":" + A)); [EOL]     gson = builder.setVersion(1.3).create(); [EOL]     json = gson.toJson(target); [EOL]     assertFalse(json.contains("\"a\":" + A)); [EOL] }
public void testNullField() throws Exception { [EOL]     try { [EOL]         new FieldAttributes(Foo.class, null); [EOL]         fail("Field parameter can not be null"); [EOL]     } catch (NullPointerException expected) { [EOL]     } [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testMakeUnmodifiable() throws Exception { [EOL]     paramMap.makeUnmodifiable(); [EOL]     try { [EOL]         paramMap.register(String.class, "blah"); [EOL]         fail("Can not register handlers when map is unmodifiable"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testNumbers() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value(new BigInteger("0")); [EOL]     jsonWriter.value(new BigInteger("9223372036854775808")); [EOL]     jsonWriter.value(new BigInteger("-9223372036854775809")); [EOL]     jsonWriter.value(new BigDecimal("3.141592653589793238462643383")); [EOL]     jsonWriter.endArray(); [EOL]     jsonWriter.close(); [EOL]     assertEquals("[0," + "9223372036854775808," + "-9223372036854775809," + "3.141592653589793238462643383]", stringWriter.toString()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testRethrowJsonParseException() throws Exception { [EOL]     String errorMsg = "please rethrow me"; [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(new JsonParseException(errorMsg))); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertNull(expected.getCause()); [EOL]         assertEquals(errorMsg, expected.getMessage()); [EOL]     } [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testIsArrayForArrayClasses() { [EOL]     assertTrue(TypeUtils.isArray(String[].class)); [EOL]     assertTrue(TypeUtils.isArray(Integer[][].class)); [EOL]     assertTrue(TypeUtils.isArray(Collection[].class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testStrictComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultTypeAdapterThrowsParseException() throws Exception { [EOL]     try { [EOL]         gson.fromJson("{\"abc\":123}", BigInteger.class); [EOL]         fail("Should have thrown a JsonParseException"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testValueWithoutName() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     try { [EOL]         jsonWriter.value(true); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testEmptyObject() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.endObject(); [EOL]     assertEquals("{}", stringWriter.toString()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testHidingExistingTypeHierarchyHandlerIsDisallowed() { [EOL]     paramMap.registerForTypeHierarchy(Sub.class, "subHandler"); [EOL]     try { [EOL]         paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]         fail("A handler that hides an existing type hierarchy handler is not allowed"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() { [EOL]     double expected = -122.08; [EOL]     double actual = gson.fromJson("[-122.08]", double.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[-122.08]", Double.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = "'Dec 3, 2009'"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyExposedField"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testToJsonTreeObjectType() { [EOL]     SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, "foo", 1.4F); [EOL]     JsonElement json = gson.toJsonTree(bag, BagOfPrimitives.class); [EOL]     assertTrue(json.isJsonObject()); [EOL]     JsonObject obj = json.getAsJsonObject(); [EOL]     Set<Entry<String, JsonElement>> children = obj.entrySet(); [EOL]     assertEquals(4, children.size()); [EOL]     assertContains(obj, new JsonPrimitive(10L)); [EOL]     assertContains(obj, new JsonPrimitive(5)); [EOL]     assertContains(obj, new JsonPrimitive(false)); [EOL]     assertContains(obj, new JsonPrimitive("foo")); [EOL] }
public void testTabEscaping() throws Exception { [EOL]     String containsTab = "123\t456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsTab); [EOL]     assertEquals("123\\t456", escapedString); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTopLevelEnumInASingleElementArrayDeserialization() { [EOL]     String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]"; [EOL]     MyEnum target = gson.fromJson(json, MyEnum.class); [EOL]     assertEquals(json, "[" + target.getExpectedJson() + "]"); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNulls() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.nullValue(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[null]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPrimitive() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(boolean.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertTrue(typeInfo.isPrimitive()); [EOL]     assertEquals(boolean.class, typeInfo.getRawClass()); [EOL]     assertEquals(Boolean.class, typeInfo.getWrappedClass()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrictSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testNeverSkipsField() throws Exception { [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(String.class, String.class.getFields()[0]))); [EOL] }
public void testMakeUnmodifiable() throws Exception { [EOL]     paramMap.makeUnmodifiable(); [EOL]     try { [EOL]         paramMap.register(String.class, "blah"); [EOL]         fail("Can not register handlers when map is unmodifiable"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testBagOfPrimitiveWrappersDeserialization() throws Exception { [EOL]     BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false); [EOL]     String jsonString = target.getExpectedJson(); [EOL]     target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class); [EOL]     assertEquals(jsonString, target.getExpectedJson()); [EOL] }
public void testLenientUnquotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[a]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testBigIntegerFieldDeserialization() { [EOL]     ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697"); [EOL]     String json = expected.getExpectedJson(); [EOL]     ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class); [EOL]     assertEquals(expected.value, actual.value); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testBagOfPrimitiveWrappersDeserialization() throws Exception { [EOL]     BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false); [EOL]     String jsonString = target.getExpectedJson(); [EOL]     target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class); [EOL]     assertEquals(jsonString, target.getExpectedJson()); [EOL] }
public void testPeekEmptyStack() throws Exception { [EOL]     try { [EOL]         stack.peek(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = "'Dec 3, 2009'"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testIgnoreLaterVersionClassSerialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     assertEquals("", gson.toJson(new Version1_2())); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testLenientMultipleTopLevelValues() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[] true {}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.endArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.beginObject(); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testAllLowerCase() throws Exception { [EOL]     assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_LOWER, String.class, null)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSlashEscaping() throws Exception { [EOL]     String containsSlash = "123\\456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsSlash); [EOL]     assertEquals("123\\\\456", escapedString); [EOL] }
public void testNumbers() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value(new BigInteger("0")); [EOL]     jsonWriter.value(new BigInteger("9223372036854775808")); [EOL]     jsonWriter.value(new BigInteger("-9223372036854775809")); [EOL]     jsonWriter.value(new BigDecimal("3.141592653589793238462643383")); [EOL]     jsonWriter.endArray(); [EOL]     jsonWriter.close(); [EOL]     assertEquals("[0," + "9223372036854775808," + "-9223372036854775809," + "3.141592653589793238462643383]", stringWriter.toString()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testSlashEscaping() throws Exception { [EOL]     String containsSlash = "123\\456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsSlash); [EOL]     assertEquals("123\\\\456", escapedString); [EOL] }
public void testVersionedGsonWithUnversionedClassesDeserialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}"; [EOL]     BagOfPrimitives expected = new BagOfPrimitives(); [EOL]     expected.longValue = 10; [EOL]     expected.intValue = 20; [EOL]     expected.booleanValue = false; [EOL]     BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testBigIntegerFieldDeserialization() { [EOL]     ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697"); [EOL]     String json = expected.getExpectedJson(); [EOL]     ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class); [EOL]     assertEquals(expected.value, actual.value); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSkipNonAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("hiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testGetActualTypeForFirstTypeVariable() { [EOL]     assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE)); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testFieldWithoutAnnotation() throws Exception { [EOL]     String fieldName = "fieldWithoutAnnotation"; [EOL]     FieldAttributes f = new FieldAttributes(SomeObject.class, SomeObject.class.getField(fieldName)); [EOL]     assertEquals(fieldName, policy.translateName(f)); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testBigDecimalNaNDeserializationNotSupported() { [EOL]     try { [EOL]         gson.fromJson("NaN", BigDecimal.class); [EOL]         fail("Gson should not accept NaN for deserialization by default."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testHasGenericButNotSpecific() throws Exception { [EOL]     Type specificType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     String handler = "blah"; [EOL]     paramMap.register(List.class, handler); [EOL]     assertFalse(paramMap.hasSpecificHandlerFor(specificType)); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(List.class)); [EOL]     assertNotNull(paramMap.getHandlerFor(specificType)); [EOL]     assertNotNull(paramMap.getHandlerFor(List.class)); [EOL]     assertEquals(handler, paramMap.getHandlerFor(specificType)); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testSkipFieldsWithMixedTrueAndFalse() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     strategies.add(TRUE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertTrue(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertTrue(strategy.shouldSkipField(FIELD)); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLenientUnquotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[a]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testDoubleQuoteEscaping() throws Exception { [EOL]     String containsQuote = "123\"456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsQuote); [EOL]     assertEquals("123\\\"456", escapedString); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNumbers() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value(new BigInteger("0")); [EOL]     jsonWriter.value(new BigInteger("9223372036854775808")); [EOL]     jsonWriter.value(new BigInteger("-9223372036854775809")); [EOL]     jsonWriter.value(new BigDecimal("3.141592653589793238462643383")); [EOL]     jsonWriter.endArray(); [EOL]     jsonWriter.close(); [EOL]     assertEquals("[0," + "9223372036854775808," + "-9223372036854775809," + "3.141592653589793238462643383]", stringWriter.toString()); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue"); [EOL]     assertEquals("\"Some\\nEscaped\\nValue\"", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal("1.333")); [EOL]     assertEquals("1.333", json.toString()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testNullStringValue() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     jsonWriter.value((String) null); [EOL]     jsonWriter.endObject(); [EOL]     assertEquals("{\"a\":null}", stringWriter.toString()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testHidingExistingTypeHierarchyHandlerIsDisallowed() { [EOL]     paramMap.registerForTypeHierarchy(Sub.class, "subHandler"); [EOL]     try { [EOL]         paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]         fail("A handler that hides an existing type hierarchy handler is not allowed"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testWrappedExceptionPropagation() throws Exception { [EOL]     IllegalArgumentException exceptionToThrow = new IllegalArgumentException(); [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(exceptionToThrow)); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertEquals(exceptionToThrow, expected.getCause()); [EOL]     } [EOL] }
public void testNewlineEscaping() throws Exception { [EOL]     String containsNewline = "123\n456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsNewline); [EOL]     assertEquals("123\\n456", escapedString); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testVersionedGsonWithUnversionedClassesDeserialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}"; [EOL]     BagOfPrimitives expected = new BagOfPrimitives(); [EOL]     expected.longValue = 10; [EOL]     expected.intValue = 20; [EOL]     expected.booleanValue = false; [EOL]     BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base>() { [EOL]  [EOL]         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) { [EOL]             JsonObject json = new JsonObject(); [EOL]             json.addProperty("value", src.baseValue); [EOL]             return json; [EOL]         } [EOL]     }).create(); [EOL]     Base b = new Base(); [EOL]     String json = gson.toJson(b); [EOL]     assertTrue(json.contains("value")); [EOL]     b = new Derived(); [EOL]     json = gson.toJson(b, Base.class); [EOL]     assertTrue(json.contains("value")); [EOL]     assertFalse(json.contains("derivedValue")); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSerializeMaps() { [EOL]     Map<String, Object> map = new LinkedHashMap<String, Object>(); [EOL]     map.put("a", 12); [EOL]     map.put("b", null); [EOL]     map.put("c", new HashMap<String, Object>()); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSlashEscaping() throws Exception { [EOL]     String containsSlash = "123\\456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsSlash); [EOL]     assertEquals("123\\\\456", escapedString); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testStrictNameValueSeparator() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("{\"a\"=>true}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testNullsInListDeserialization() { [EOL]     List<String> expected = new ArrayList<String>(); [EOL]     expected.add("foo"); [EOL]     expected.add(null); [EOL]     expected.add("bar"); [EOL]     String json = "[\"foo\",null,\"bar\"]"; [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     List<String> target = gson.fromJson(json, expectedType); [EOL]     for (int i = 0; i < expected.size(); ++i) { [EOL]         assertEquals(expected.get(i), target.get(i)); [EOL]     } [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testVersionedGsonWithUnversionedClassesDeserialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}"; [EOL]     BagOfPrimitives expected = new BagOfPrimitives(); [EOL]     expected.longValue = 10; [EOL]     expected.intValue = 20; [EOL]     expected.booleanValue = false; [EOL]     BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testToJsonTreeObjectType() { [EOL]     SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, "foo", 1.4F); [EOL]     JsonElement json = gson.toJsonTree(bag, BagOfPrimitives.class); [EOL]     assertTrue(json.isJsonObject()); [EOL]     JsonObject obj = json.getAsJsonObject(); [EOL]     Set<Entry<String, JsonElement>> children = obj.entrySet(); [EOL]     assertEquals(4, children.size()); [EOL]     assertContains(obj, new JsonPrimitive(10L)); [EOL]     assertContains(obj, new JsonPrimitive(5)); [EOL]     assertContains(obj, new JsonPrimitive(false)); [EOL]     assertContains(obj, new JsonPrimitive("foo")); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testObjectArrayWithNonPrimitivesSerialization() throws Exception { [EOL]     ClassWithObjects classWithObjects = new ClassWithObjects(); [EOL]     BagOfPrimitives bagOfPrimitives = new BagOfPrimitives(); [EOL]     String classWithObjectsJson = gson.toJson(classWithObjects); [EOL]     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives); [EOL]     Object[] objects = new Object[] { classWithObjects, bagOfPrimitives }; [EOL]     String json = gson.toJson(objects); [EOL]     assertTrue(json.contains(classWithObjectsJson)); [EOL]     assertTrue(json.contains(bagOfPrimitivesJson)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = "'Dec 3, 2009'"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testIsArrayForArrayClasses() { [EOL]     assertTrue(TypeUtils.isArray(String[].class)); [EOL]     assertTrue(TypeUtils.isArray(Integer[][].class)); [EOL]     assertTrue(TypeUtils.isArray(Collection[].class)); [EOL] }
public void testTypeOverridding() throws Exception { [EOL]     String handler1 = "blah1"; [EOL]     String handler2 = "blah2"; [EOL]     paramMap.register(String.class, handler1); [EOL]     paramMap.register(String.class, handler2); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertEquals(handler2, paramMap.getHandlerFor(String.class)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testFieldStartsWithUnderscore() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("_Blah", policy.translateName("_blah", String.class, null)); [EOL]     assertEquals("_Blah", policy.translateName("_Blah", String.class, null)); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testUserDefinedExclusionPolicies() throws Exception { [EOL]     Gson gson = new GsonBuilder().setExclusionStrategies(new UserDefinedExclusionStrategy(String.class)).create(); [EOL]     String json = gson.toJson(new TestTypes.StringWrapper("someValue")); [EOL]     assertEquals("{}", json); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testHidingExistingTypeHierarchyHandlerIsDisallowed() { [EOL]     paramMap.registerForTypeHierarchy(Sub.class, "subHandler"); [EOL]     try { [EOL]         paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]         fail("A handler that hides an existing type hierarchy handler is not allowed"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testNonFiniteDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(Double.NaN); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(Double.NEGATIVE_INFINITY); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(Double.POSITIVE_INFINITY); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testRethrowJsonParseException() throws Exception { [EOL]     String errorMsg = "please rethrow me"; [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(new JsonParseException(errorMsg))); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertNull(expected.getCause()); [EOL]         assertEquals(errorMsg, expected.getMessage()); [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testMakeUnmodifiable() throws Exception { [EOL]     paramMap.makeUnmodifiable(); [EOL]     try { [EOL]         paramMap.register(String.class, "blah"); [EOL]         fail("Can not register handlers when map is unmodifiable"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testNonMapConstruction() throws Exception { [EOL]     try { [EOL]         Type parameterizedMapType = new TypeToken<List<String>>() { [EOL]         }.getType(); [EOL]         new TypeInfoMap(parameterizedMapType); [EOL]         fail("The raw type must be a Map"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testFieldStartsWithUnderscore() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("_Blah", policy.translateName("_blah", String.class, null)); [EOL]     assertEquals("_Blah", policy.translateName("_Blah", String.class, null)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testStrictNonFiniteDoubles() throws IOException { [EOL]     String json = "[NaN]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testFieldWithoutAnnotation() throws Exception { [EOL]     String fieldName = "fieldWithoutAnnotation"; [EOL]     FieldAttributes f = new FieldAttributes(SomeObject.class, SomeObject.class.getField(fieldName)); [EOL]     assertEquals(fieldName, policy.translateName(f)); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testVersionedUntilSerialization() { [EOL]     Version1 target = new Version1(); [EOL]     Gson gson = builder.setVersion(1.29).create(); [EOL]     String json = gson.toJson(target); [EOL]     assertTrue(json.contains("\"a\":" + A)); [EOL]     gson = builder.setVersion(1.3).create(); [EOL]     json = gson.toJson(target); [EOL]     assertFalse(json.contains("\"a\":" + A)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testLocaleDeserializationWithLanguageCountry() { [EOL]     String json = "\"fr_CA\""; [EOL]     Locale locale = gson.fromJson(json, Locale.class); [EOL]     assertEquals(Locale.CANADA_FRENCH, locale); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testUriDeserialization() { [EOL]     String uriValue = "http://google.com/"; [EOL]     String json = '"' + uriValue + '"'; [EOL]     URI target = gson.fromJson(json, URI.class); [EOL]     assertEquals(uriValue, target.toASCIIString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testTopLevelEnumInASingleElementArrayDeserialization() { [EOL]     String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]"; [EOL]     MyEnum target = gson.fromJson(json, MyEnum.class); [EOL]     assertEquals(json, "[" + target.getExpectedJson() + "]"); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testIsSynthetic() throws Exception { [EOL]     assertFalse(fieldAttributes.isSynthetic()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientUnquotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[a]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testNonMapConstruction() throws Exception { [EOL]     try { [EOL]         Type parameterizedMapType = new TypeToken<List<String>>() { [EOL]         }.getType(); [EOL]         new TypeInfoMap(parameterizedMapType); [EOL]         fail("The raw type must be a Map"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testStringLongSerialization() throws Exception { [EOL]     JsonElement element = LongSerializationPolicy.STRING.serialize(1556L); [EOL]     assertTrue(element.isJsonPrimitive()); [EOL]     JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive(); [EOL]     assertFalse(jsonPrimitive.isNumber()); [EOL]     assertTrue(jsonPrimitive.isString()); [EOL]     assertEquals("1556", element.getAsString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testAllLowerCase() throws Exception { [EOL]     assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_LOWER, String.class, null)); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testBigDecimalFieldSerialization() { [EOL]     ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21"); [EOL]     String json = gson.toJson(target); [EOL]     String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}')); [EOL]     assertEquals(target.value, new BigDecimal(actual)); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testUriDeserialization() { [EOL]     String uriValue = "http://google.com/"; [EOL]     String json = '"' + uriValue + '"'; [EOL]     URI target = gson.fromJson(json, URI.class); [EOL]     assertEquals(uriValue, target.toASCIIString()); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testObjectArrayWithNonPrimitivesSerialization() throws Exception { [EOL]     ClassWithObjects classWithObjects = new ClassWithObjects(); [EOL]     BagOfPrimitives bagOfPrimitives = new BagOfPrimitives(); [EOL]     String classWithObjectsJson = gson.toJson(classWithObjects); [EOL]     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives); [EOL]     Object[] objects = new Object[] { classWithObjects, bagOfPrimitives }; [EOL]     String json = gson.toJson(objects); [EOL]     assertTrue(json.contains(classWithObjectsJson)); [EOL]     assertTrue(json.contains(bagOfPrimitivesJson)); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testDoubleQuoteEscaping() throws Exception { [EOL]     String containsQuote = "123\"456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsQuote); [EOL]     assertEquals("123\\\"456", escapedString); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testSubInterfacesOfCollectionSerialization() throws Exception { [EOL]     List<Integer> list = new LinkedList<Integer>(); [EOL]     list.add(0); [EOL]     list.add(1); [EOL]     list.add(2); [EOL]     list.add(3); [EOL]     Queue<Long> queue = new LinkedList<Long>(); [EOL]     queue.add(0L); [EOL]     queue.add(1L); [EOL]     queue.add(2L); [EOL]     queue.add(3L); [EOL]     Set<Float> set = new TreeSet<Float>(); [EOL]     set.add(0.1F); [EOL]     set.add(0.2F); [EOL]     set.add(0.3F); [EOL]     set.add(0.4F); [EOL]     SortedSet<Character> sortedSet = new TreeSet<Character>(); [EOL]     sortedSet.add('a'); [EOL]     sortedSet.add('b'); [EOL]     sortedSet.add('c'); [EOL]     sortedSet.add('d'); [EOL]     ClassWithSubInterfacesOfCollection target = new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet); [EOL]     assertEquals(target.getExpectedJson(), gson.toJson(target)); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testFieldNamingPolicy() throws Exception { [EOL]     FieldAttributes f = new FieldAttributes(String.class, String.class.getFields()[0]); [EOL]     assertEquals(f.getName(), namingPolicy.translateName(f)); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testDefaultJavaSqlTimeSerialization() { [EOL]     Time now = new Time(1259875082000L); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"01:18:02 PM\"", json); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue"); [EOL]     assertEquals("\"Some\\nEscaped\\nValue\"", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal("1.333")); [EOL]     assertEquals("1.333", json.toString()); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testNonFiniteBoxedDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NaN)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NEGATIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.POSITIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testBigDecimalNaNDeserializationNotSupported() { [EOL]     try { [EOL]         gson.fromJson("NaN", BigDecimal.class); [EOL]         fail("Gson should not accept NaN for deserialization by default."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testIntegersWithFractionalPartSpecified() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[1.0,1.0,1.0]")); [EOL]     reader.beginArray(); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL] }
public void testDefaultJavaSqlDateSerialization() { [EOL]     java.sql.Date instant = new java.sql.Date(1259875082000L); [EOL]     String json = gson.toJson(instant); [EOL]     assertEquals("\"Dec 3, 2009\"", json); [EOL] }
public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() { [EOL]     double expected = -122.08; [EOL]     double actual = gson.fromJson("[-122.08]", double.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[-122.08]", Double.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testAddingBooleanProperties() throws Exception { [EOL]     String propertyName = "property"; [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     jsonObj.addProperty(propertyName, true); [EOL]     assertTrue(jsonObj.has(propertyName)); [EOL]     JsonElement jsonElement = jsonObj.get(propertyName); [EOL]     assertNotNull(jsonElement); [EOL]     assertTrue(jsonElement.getAsBoolean()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testMapDeserializationWithWildcardValues() { [EOL]     Type typeOfMap = new TypeToken<Map<String, ? extends Long>>() { [EOL]     }.getType(); [EOL]     Map<String, ? extends Long> map = gson.fromJson("{\"test\":123}", typeOfMap); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(new Long(123L), map.get("test")); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testParseMixedArray() { [EOL]     String json = "[{},13,\"stringValue\"]"; [EOL]     JsonElement e = parser.parse(json); [EOL]     assertTrue(e.isJsonArray()); [EOL]     JsonArray array = e.getAsJsonArray(); [EOL]     assertEquals("{}", array.get(0).toString()); [EOL]     assertEquals(13, array.get(1).getAsInt()); [EOL]     assertEquals("stringValue", array.get(2).getAsString()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testStringLongSerialization() throws Exception { [EOL]     JsonElement element = LongSerializationPolicy.STRING.serialize(1556L); [EOL]     assertTrue(element.isJsonPrimitive()); [EOL]     JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive(); [EOL]     assertFalse(jsonPrimitive.isNumber()); [EOL]     assertTrue(jsonPrimitive.isString()); [EOL]     assertEquals("1556", element.getAsString()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testBigDecimalFieldDeserialization() { [EOL]     ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21"); [EOL]     String json = expected.getExpectedJson(); [EOL]     ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class); [EOL]     assertEquals(expected.value, actual.value); [EOL] }
public void testAllLowerCase() throws Exception { [EOL]     assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_LOWER, String.class, null)); [EOL] }
public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = "'Dec 3, 2009'"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }
public void testVersionedGsonWithUnversionedClassesDeserialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}"; [EOL]     BagOfPrimitives expected = new BagOfPrimitives(); [EOL]     expected.longValue = 10; [EOL]     expected.intValue = 20; [EOL]     expected.booleanValue = false; [EOL]     BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testOurTypeFunctionality() throws Exception { [EOL]     assertEquals(parameterizedType, ourType.getGenericComponentType()); [EOL]     assertEquals(genericArrayType, ourType); [EOL]     assertEquals(genericArrayType.hashCode(), ourType.hashCode()); [EOL] }
public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() { [EOL]     assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class)); [EOL]     assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class)); [EOL]     boolean value = gson.fromJson("[false]", boolean.class); [EOL]     assertEquals(false, value); [EOL]     value = gson.fromJson("[true]", boolean.class); [EOL]     assertEquals(true, value); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTopLevelEnumInASingleElementArrayDeserialization() { [EOL]     String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]"; [EOL]     MyEnum target = gson.fromJson(json, MyEnum.class); [EOL]     assertEquals(json, "[" + target.getExpectedJson() + "]"); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testUserDefinedExclusionPolicies() throws Exception { [EOL]     Gson gson = new GsonBuilder().setExclusionStrategies(new UserDefinedExclusionStrategy(String.class)).create(); [EOL]     String json = gson.toJson(new TestTypes.StringWrapper("someValue")); [EOL]     assertEquals("{}", json); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testSkipNonAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("hiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testIntegersWithFractionalPartSpecified() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[1.0,1.0,1.0]")); [EOL]     reader.beginArray(); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testMultipleTopLevelValues() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray().endArray(); [EOL]     try { [EOL]         jsonWriter.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testInnerClassExclusion() throws Exception { [EOL]     Gson gson = new GsonBuilder().disableInnerClassSerialization().create(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals("", result); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testVersionedGsonWithUnversionedClassesDeserialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}"; [EOL]     BagOfPrimitives expected = new BagOfPrimitives(); [EOL]     expected.longValue = 10; [EOL]     expected.intValue = 20; [EOL]     expected.booleanValue = false; [EOL]     BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testSkipNonAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("hiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testCarrageReturnEscaping() throws Exception { [EOL]     String containsCarrageReturn = "123\r456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsCarrageReturn); [EOL]     assertEquals("123\\r456", escapedString); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testDefaultJavaSqlTimeSerialization() { [EOL]     Time now = new Time(1259875082000L); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"01:18:02 PM\"", json); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testNewlineEscaping() throws Exception { [EOL]     String containsNewline = "123\n456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsNewline); [EOL]     assertEquals("123\\n456", escapedString); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientNameValueSeparator() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("{\"a\"=>true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testNulls() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.nullValue(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[null]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testValueWithoutName() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     try { [EOL]         jsonWriter.value(true); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() { [EOL]     int expected = 1; [EOL]     int actual = gson.fromJson("[1]", int.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[1]", Integer.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testOurTypeFunctionality() throws Exception { [EOL]     assertEquals(parameterizedType, ourType.getGenericComponentType()); [EOL]     assertEquals(genericArrayType, ourType); [EOL]     assertEquals(genericArrayType.hashCode(), ourType.hashCode()); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testReaderDoesNotMutateState() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     JsonReader jsonReader = new JsonReader(new StringReader(CARS_JSON)); [EOL]     jsonReader.beginArray(); [EOL]     jsonReader.setLenient(false); [EOL]     gson.fromJson(jsonReader, Car.class); [EOL]     assertFalse(jsonReader.isLenient()); [EOL]     jsonReader.setLenient(true); [EOL]     gson.fromJson(jsonReader, Car.class); [EOL]     assertTrue(jsonReader.isLenient()); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testBigIntegerFieldSerialization() { [EOL]     ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324"); [EOL]     String json = gson.toJson(target); [EOL]     assertEquals(target.getExpectedJson(), json); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSkipFieldsWithMixedTrueAndFalse() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     strategies.add(TRUE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertTrue(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertTrue(strategy.shouldSkipField(FIELD)); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testDeclaringClass() throws Exception { [EOL]     assertEquals(Foo.class, fieldAttributes.getDeclaringClass()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testCollectionOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     Type collectionType = new TypeToken<Collection<String>>() { [EOL]     }.getType(); [EOL]     Collection<String> target = gson.fromJson(json, collectionType); [EOL]     assertTrue(target.contains("Hello")); [EOL]     assertTrue(target.contains("World")); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testTypesWithMultipleParametersDeserialization() throws Exception { [EOL]     Type typeOfTarget = new TypeToken<MultiParameters<Integer, Float, Double, String, BagOfPrimitives>>() { [EOL]     }.getType(); [EOL]     String json = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\"," + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}"; [EOL]     MultiParameters<Integer, Float, Double, String, BagOfPrimitives> target = gson.fromJson(json, typeOfTarget); [EOL]     MultiParameters<Integer, Float, Double, String, BagOfPrimitives> expected = new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D, "abc", new BagOfPrimitives()); [EOL]     assertEquals(expected, target); [EOL] }
public void testBigDecimalFieldSerialization() { [EOL]     ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21"); [EOL]     String json = gson.toJson(target); [EOL]     String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}')); [EOL]     assertEquals(target.value, new BigDecimal(actual)); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testBadFieldTypeForCustomDeserializerCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     obj.add("longValue", array); [EOL]     try { [EOL]         gson.fromJson(obj, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testRawCollectionDeserializationNotAlllowed() { [EOL]     String json = "[0,1,2,3,4,5,6,7,8,9]"; [EOL]     try { [EOL]         gson.fromJson(json, Collection.class); [EOL]         fail("Can not deserialize a non-genericized collection."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL]     json = "[\"Hello\", \"World\"]"; [EOL]     try { [EOL]         gson.fromJson(json, Collection.class); [EOL]         fail("Can not deserialize a non-genericized collection."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testParseMixedArray() { [EOL]     String json = "[{},13,\"stringValue\"]"; [EOL]     JsonElement e = parser.parse(json); [EOL]     assertTrue(e.isJsonArray()); [EOL]     JsonArray array = e.getAsJsonArray(); [EOL]     assertEquals("{}", array.get(0).toString()); [EOL]     assertEquals(13, array.get(1).getAsInt()); [EOL]     assertEquals("stringValue", array.get(2).getAsString()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization() { [EOL]     Gson gson = gsonBuilder.generateNonExecutableJson().create(); [EOL]     String json = JSON_NON_EXECUTABLE_PREFIX + "{intValue:2,stringValue:')]}\\u0027\\n'}"; [EOL]     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class); [EOL]     assertEquals(")]}'\n", target.stringValue); [EOL]     assertEquals(2, target.intValue); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientUnquotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[a]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testNonFiniteBoxedDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NaN)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NEGATIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.POSITIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testLocaleSerializationWithLanguageCountry() { [EOL]     Locale target = Locale.CANADA_FRENCH; [EOL]     assertEquals("\"fr_CA\"", gson.toJson(target)); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testFieldWithoutAnnotation() throws Exception { [EOL]     String fieldName = "fieldWithoutAnnotation"; [EOL]     FieldAttributes f = new FieldAttributes(SomeObject.class, SomeObject.class.getField(fieldName)); [EOL]     assertEquals(fieldName, policy.translateName(f)); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testFloatInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     float infinity = Float.POSITIVE_INFINITY; [EOL]     assertEquals("Infinity", gson.toJson(infinity)); [EOL]     assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY)); [EOL] }
public void testFieldWithoutAnnotation() throws Exception { [EOL]     String fieldName = "fieldWithoutAnnotation"; [EOL]     FieldAttributes f = new FieldAttributes(SomeObject.class, SomeObject.class.getField(fieldName)); [EOL]     assertEquals(fieldName, policy.translateName(f)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDefaultJavaSqlDateDeserialization() { [EOL]     String json = "'Dec 3, 2009'"; [EOL]     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class); [EOL]     assertEqualsDate(extracted, 2009, 11, 3); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testSerializeMaps() { [EOL]     Map<String, Object> map = new LinkedHashMap<String, Object>(); [EOL]     map.put("a", 12); [EOL]     map.put("b", null); [EOL]     map.put("c", new HashMap<String, Object>()); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL] }
public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() { [EOL]     int expected = 1; [EOL]     int actual = gson.fromJson("[1]", int.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[1]", Integer.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testDefaultTypeAdapterThrowsParseException() throws Exception { [EOL]     try { [EOL]         gson.fromJson("{\"abc\":123}", BigInteger.class); [EOL]         fail("Should have thrown a JsonParseException"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testPrintPrintingObjectWithNulls() throws Exception { [EOL]     gsonBuilder = new GsonBuilder(); [EOL]     Gson gson = gsonBuilder.create(); [EOL]     String result = gson.toJson(new ClassWithMembers()); [EOL]     assertEquals("{}", result); [EOL]     gson = gsonBuilder.serializeNulls().create(); [EOL]     result = gson.toJson(new ClassWithMembers()); [EOL]     assertTrue(result.contains("\"str\":null")); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSkipExplicitlySkippedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyHiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testParameterizedTypeGenericArraysSerialization() throws Exception { [EOL]     List<Integer> list = new ArrayList<Integer>(); [EOL]     list.add(1); [EOL]     list.add(2); [EOL]     List<Integer>[] arrayOfLists = new List[] { list, list }; [EOL]     Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() { [EOL]     }.getType(); [EOL]     ObjectWithTypeVariables<Integer> objToSerialize = new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null); [EOL]     String json = gson.toJson(objToSerialize, typeOfSrc); [EOL]     assertEquals("{\"arrayOfListOfTypeParameters\":[[1,2],[1,2]]}", json); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testFloatInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     float infinity = Float.POSITIVE_INFINITY; [EOL]     assertEquals("Infinity", gson.toJson(infinity)); [EOL]     assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY)); [EOL] }
public void testLenientNameValueSeparator() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\"=true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("{\"a\"=>true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testEmptyObject() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.endObject(); [EOL]     assertEquals("{}", stringWriter.toString()); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testNoTopLevelObject() throws IOException { [EOL]     try { [EOL]         new JsonReader(new StringReader("true")).nextBoolean(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base>() { [EOL]  [EOL]         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) { [EOL]             JsonObject json = new JsonObject(); [EOL]             json.addProperty("value", src.baseValue); [EOL]             return json; [EOL]         } [EOL]     }).create(); [EOL]     Base b = new Base(); [EOL]     String json = gson.toJson(b); [EOL]     assertTrue(json.contains("value")); [EOL]     b = new Derived(); [EOL]     json = gson.toJson(b, Base.class); [EOL]     assertTrue(json.contains("value")); [EOL]     assertFalse(json.contains("derivedValue")); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testInvalidConstruction() throws Exception { [EOL]     try { [EOL]         new TypeInfoMap(String.class); [EOL]         fail("Must be a ParameterizedType"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testBadTypeForDeserializingCustomTree() { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(obj); [EOL]     try { [EOL]         gson.fromJson(array, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testNulls() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.nullValue(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[null]", stringWriter.toString()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDeclaringClass() throws Exception { [EOL]     assertEquals(Foo.class, fieldAttributes.getDeclaringClass()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testAllLowerCase() throws Exception { [EOL]     assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_LOWER, String.class, null)); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrictMultipleTopLevelValues() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[] []")); [EOL]     reader.beginArray(); [EOL]     reader.endArray(); [EOL]     try { [EOL]         reader.peek(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testTabEscaping() throws Exception { [EOL]     String containsTab = "123\t456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsTab); [EOL]     assertEquals("123\\t456", escapedString); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testObjectType() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(String.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isPrimitive()); [EOL]     assertEquals(String.class, typeInfo.getRawClass()); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyExposedField"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testNeverSkipsClass() throws Exception { [EOL]     assertFalse(strategy.shouldSkipClass(String.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testBigDecimalNaNDeserializationNotSupported() { [EOL]     try { [EOL]         gson.fromJson("NaN", BigDecimal.class); [EOL]         fail("Gson should not accept NaN for deserialization by default."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTabEscaping() throws Exception { [EOL]     String containsTab = "123\t456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsTab); [EOL]     assertEquals("123\\t456", escapedString); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testStrictNonExecutePrefix() { [EOL]     JsonReader reader = new JsonReader(new StringReader(")]}'\n []")); [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testSetDeserialization() { [EOL]     String json = "[{value:1},{value:2}]"; [EOL]     Type type = new TypeToken<Set<Entry>>() { [EOL]     }.getType(); [EOL]     Set<Entry> set = gson.fromJson(json, type); [EOL]     assertEquals(2, set.size()); [EOL]     for (Entry entry : set) { [EOL]         assertTrue(entry.value == 1 || entry.value == 2); [EOL]     } [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testStrangeTypeParameters() throws Exception { [EOL]     try { [EOL]         new TypeInfo(new Type() { [EOL]         }); [EOL]         fail("Should not be able to determine this unknown type"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testStrictSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testFloatNaNSerializationNotSupportedByDefault() { [EOL]     try { [EOL]         float nan = Float.NaN; [EOL]         gson.toJson(nan); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         gson.toJson(Float.NaN); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testBigIntegerInASingleElementArrayDeserialization() { [EOL]     BigInteger expected = new BigInteger("34343434343424242423432323243243242"); [EOL]     BigInteger actual = gson.fromJson("[34343434343424242423432323243243242]", BigInteger.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testReadWriteTwoObjects() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonReader parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     JsonElement element1 = Streams.parse(parser); [EOL]     JsonElement element2 = Streams.parse(parser); [EOL]     BagOfPrimitives actualOne = gson.fromJson(element1, BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(element2, BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testBadValueForBigIntegerDeserialization() { [EOL]     try { [EOL]         gson.fromJson("15.099", BigInteger.class); [EOL]         fail("BigInteger can not be decimal values."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testBaseSerializedAsSub() { [EOL]     Base base = new Sub(); [EOL]     JsonObject json = gson.toJsonTree(base).getAsJsonObject(); [EOL]     assertEquals(Sub.SUB_NAME, json.get(Sub.SUB_FIELD_KEY).getAsString()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() { [EOL]     assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class)); [EOL]     assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class)); [EOL]     boolean value = gson.fromJson("[false]", boolean.class); [EOL]     assertEquals(false, value); [EOL]     value = gson.fromJson("[true]", boolean.class); [EOL]     assertEquals(true, value); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testNeverSkipsClass() throws Exception { [EOL]     assertFalse(strategy.shouldSkipClass(String.class)); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNoTopLevelObject() throws IOException { [EOL]     try { [EOL]         new JsonReader(new StringReader("true")).nextBoolean(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testUrlSerialization() throws Exception { [EOL]     String urlValue = "http://google.com/"; [EOL]     URL url = new URL(urlValue); [EOL]     assertEquals("\"http://google.com/\"", gson.toJson(url)); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testBadFieldTypeForCustomDeserializerCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     obj.add("longValue", array); [EOL]     try { [EOL]         gson.fromJson(obj, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testCollectionOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     Type collectionType = new TypeToken<Collection<String>>() { [EOL]     }.getType(); [EOL]     Collection<String> target = gson.fromJson(json, collectionType); [EOL]     assertTrue(target.contains("Hello")); [EOL]     assertTrue(target.contains("World")); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testVariableTypeArrayDeserialization() throws Exception { [EOL]     Integer[] array = { 1, 2, 3 }; [EOL]     Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() { [EOL]     }.getType(); [EOL]     ObjectWithTypeVariables<Integer> objToSerialize = new ObjectWithTypeVariables<Integer>(null, array, null, null, null, null); [EOL]     String json = gson.toJson(objToSerialize, typeOfSrc); [EOL]     ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc); [EOL]     assertEquals(objAfterDeserialization.getExpectedJson(), json); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testObjectArrayWithNonPrimitivesSerialization() throws Exception { [EOL]     ClassWithObjects classWithObjects = new ClassWithObjects(); [EOL]     BagOfPrimitives bagOfPrimitives = new BagOfPrimitives(); [EOL]     String classWithObjectsJson = gson.toJson(classWithObjects); [EOL]     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives); [EOL]     Object[] objects = new Object[] { classWithObjects, bagOfPrimitives }; [EOL]     String json = gson.toJson(objects); [EOL]     assertTrue(json.contains(classWithObjectsJson)); [EOL]     assertTrue(json.contains(bagOfPrimitivesJson)); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testIntegersWithFractionalPartSpecified() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[1.0,1.0,1.0]")); [EOL]     reader.beginArray(); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL] }
public void testUriSerialization() throws Exception { [EOL]     String uriValue = "http://google.com/"; [EOL]     URI uri = new URI(uriValue); [EOL]     assertEquals("\"http://google.com/\"", gson.toJson(uri)); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testBadFieldTypeForCustomDeserializerCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     obj.add("longValue", array); [EOL]     try { [EOL]         gson.fromJson(obj, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testIsSynthetic() throws Exception { [EOL]     assertFalse(fieldAttributes.isSynthetic()); [EOL] }
public void testCarrageReturnEscaping() throws Exception { [EOL]     String containsCarrageReturn = "123\r456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsCarrageReturn); [EOL]     assertEquals("123\\r456", escapedString); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNumberDeserialization() { [EOL]     String json = "1"; [EOL]     Number expected = new Integer(json); [EOL]     Number actual = gson.fromJson(json, Number.class); [EOL]     assertEquals(expected.intValue(), actual.intValue()); [EOL]     json = String.valueOf(Long.MAX_VALUE); [EOL]     expected = new Long(json); [EOL]     actual = gson.fromJson(json, Number.class); [EOL]     assertEquals(expected.longValue(), actual.longValue()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testNonFiniteBoxedDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NaN)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NEGATIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.POSITIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testName() throws Exception { [EOL]     assertEquals("bar", fieldAttributes.getName()); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testMultipleTopLevelValues() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray().endArray(); [EOL]     try { [EOL]         jsonWriter.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testBadValueForBigDecimalDeserialization() { [EOL]     try { [EOL]         gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class); [EOL]         fail("Exponent of a BigDecimal must be an integer value."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testUriSerialization() throws Exception { [EOL]     String uriValue = "http://google.com/"; [EOL]     URI uri = new URI(uriValue); [EOL]     assertEquals("\"http://google.com/\"", gson.toJson(uri)); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testBigIntegerFieldSerialization() { [EOL]     ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324"); [EOL]     String json = gson.toJson(target); [EOL]     assertEquals(target.getExpectedJson(), json); [EOL] }
public void testWriteDoesNotMutateState() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.setHtmlSafe(true); [EOL]     jsonWriter.setLenient(true); [EOL]     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter); [EOL]     assertTrue(jsonWriter.isHtmlSafe()); [EOL]     assertTrue(jsonWriter.isLenient()); [EOL]     jsonWriter.setHtmlSafe(false); [EOL]     jsonWriter.setLenient(false); [EOL]     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter); [EOL]     assertFalse(jsonWriter.isHtmlSafe()); [EOL]     assertFalse(jsonWriter.isLenient()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testAddingNullPropertyValue() throws Exception { [EOL]     String propertyName = "property"; [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     jsonObj.add(propertyName, null); [EOL]     assertTrue(jsonObj.has(propertyName)); [EOL]     JsonElement jsonElement = jsonObj.get(propertyName); [EOL]     assertNotNull(jsonElement); [EOL]     assertTrue(jsonElement.isJsonNull()); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() { [EOL]     assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class)); [EOL]     assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class)); [EOL]     boolean value = gson.fromJson("[false]", boolean.class); [EOL]     assertEquals(false, value); [EOL]     value = gson.fromJson("[true]", boolean.class); [EOL]     assertEquals(true, value); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testFloatNaNSerializationNotSupportedByDefault() { [EOL]     try { [EOL]         float nan = Float.NaN; [EOL]         gson.toJson(nan); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         gson.toJson(Float.NaN); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testStrictComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testObject() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(Object.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isPrimitive()); [EOL]     assertEquals(Object.class, typeInfo.getRawClass()); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDoubleNaNSerializationNotSupportedByDefault() { [EOL]     try { [EOL]         double nan = Double.NaN; [EOL]         gson.toJson(nan); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         gson.toJson(Double.NaN); [EOL]         fail("Gson should not accept NaN for serialization"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testBadValueForBigIntegerDeserialization() { [EOL]     try { [EOL]         gson.fromJson("15.099", BigInteger.class); [EOL]         fail("BigInteger can not be decimal values."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testNoTopLevelObject() throws IOException { [EOL]     try { [EOL]         new JsonReader(new StringReader("true")).nextBoolean(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testReadWriteTwoObjects() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonReader parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     JsonElement element1 = Streams.parse(parser); [EOL]     JsonElement element2 = Streams.parse(parser); [EOL]     BagOfPrimitives actualOne = gson.fromJson(element1, BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(element2, BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testLowerCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER); [EOL]     assertEquals("blah", policy.translateName("Blah", String.class, null)); [EOL]     assertEquals("blah", policy.translateName("blah", String.class, null)); [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testUrlSerialization() throws Exception { [EOL]     String urlValue = "http://google.com/"; [EOL]     URL url = new URL(urlValue); [EOL]     assertEquals("\"http://google.com/\"", gson.toJson(url)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSerializeMaps() { [EOL]     Map<String, Object> map = new LinkedHashMap<String, Object>(); [EOL]     map.put("a", 12); [EOL]     map.put("b", null); [EOL]     map.put("c", new HashMap<String, Object>()); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"b\":null,\"c\":{}}", new GsonBuilder().serializeNulls().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL]     assertEquals("{\"a\":12,\"c\":{}}", new GsonBuilder().create().toJson(map)); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testTypesWithMultipleParametersDeserialization() throws Exception { [EOL]     Type typeOfTarget = new TypeToken<MultiParameters<Integer, Float, Double, String, BagOfPrimitives>>() { [EOL]     }.getType(); [EOL]     String json = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\"," + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}"; [EOL]     MultiParameters<Integer, Float, Double, String, BagOfPrimitives> target = gson.fromJson(json, typeOfTarget); [EOL]     MultiParameters<Integer, Float, Double, String, BagOfPrimitives> expected = new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D, "abc", new BagOfPrimitives()); [EOL]     assertEquals(expected, target); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testEmptyStringDeserialization() throws Exception { [EOL]     Object object = gson.fromJson("", Object.class); [EOL]     assertNull(object); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testIncludeStaticNestedClassObject() throws Exception { [EOL]     Class<?> clazz = staticNestedClass.getClass(); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testNullMap() throws Exception { [EOL]     assertFalse(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertNull(paramMap.getHandlerFor(String.class)); [EOL]     assertNull(paramMap.getHandlerFor(String.class)); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testStringNullIsNotNull() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[\"null\"]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextNull(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testPrettyPrintArrayOfObjects() { [EOL]     ArrayOfObjects target = new ArrayOfObjects(); [EOL]     String json = gson.toJson(target); [EOL]     print(json); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testSetDeserialization() { [EOL]     String json = "[{value:1},{value:2}]"; [EOL]     Type type = new TypeToken<Set<Entry>>() { [EOL]     }.getType(); [EOL]     Set<Entry> set = gson.fromJson(json, type); [EOL]     assertEquals(2, set.size()); [EOL]     for (Entry entry : set) { [EOL]         assertTrue(entry.value == 1 || entry.value == 2); [EOL]     } [EOL] }
public void testSkipExplicitlySkippedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyHiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testMapDeserializationWithWildcardValues() { [EOL]     Type typeOfMap = new TypeToken<Map<String, ? extends Long>>() { [EOL]     }.getType(); [EOL]     Map<String, ? extends Long> map = gson.fromJson("{\"test\":123}", typeOfMap); [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(new Long(123L), map.get("test")); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDefaultJavaSqlTimeSerialization() { [EOL]     Time now = new Time(1259875082000L); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"01:18:02 PM\"", json); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testParseMixedArray() { [EOL]     String json = "[{},13,\"stringValue\"]"; [EOL]     JsonElement e = parser.parse(json); [EOL]     assertTrue(e.isJsonArray()); [EOL]     JsonArray array = e.getAsJsonArray(); [EOL]     assertEquals("{}", array.get(0).toString()); [EOL]     assertEquals(13, array.get(1).getAsInt()); [EOL]     assertEquals("stringValue", array.get(2).getAsString()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGetActualTypeForFirstTypeVariable() { [EOL]     assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE)); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testBigIntegerInASingleElementArrayDeserialization() { [EOL]     BigInteger expected = new BigInteger("34343434343424242423432323243243242"); [EOL]     BigInteger actual = gson.fromJson("[34343434343424242423432323243243242]", BigInteger.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testDefaultJavaSqlDateSerialization() { [EOL]     java.sql.Date instant = new java.sql.Date(1259875082000L); [EOL]     String json = gson.toJson(instant); [EOL]     assertEquals("\"Dec 3, 2009\"", json); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testBadTypeForDeserializingCustomTree() { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(obj); [EOL]     try { [EOL]         gson.fromJson(array, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testPrimitive() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(boolean.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertTrue(typeInfo.isPrimitive()); [EOL]     assertEquals(boolean.class, typeInfo.getRawClass()); [EOL]     assertEquals(Boolean.class, typeInfo.getWrappedClass()); [EOL] }
public void testExplicitSerializationOfNulls() { [EOL]     Gson gson = gsonBuilder.create(); [EOL]     ClassWithObjects target = new ClassWithObjects(null); [EOL]     String actual = gson.toJson(target); [EOL]     String expected = "{\"bag\":null}"; [EOL]     assertEquals(expected, actual); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testHidingExistingTypeHierarchyHandlerIsDisallowed() { [EOL]     paramMap.registerForTypeHierarchy(Sub.class, "subHandler"); [EOL]     try { [EOL]         paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]         fail("A handler that hides an existing type hierarchy handler is not allowed"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testNonMapConstruction() throws Exception { [EOL]     try { [EOL]         Type parameterizedMapType = new TypeToken<List<String>>() { [EOL]         }.getType(); [EOL]         new TypeInfoMap(parameterizedMapType); [EOL]         fail("The raw type must be a Map"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testLenientUnquotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[a]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testObject() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(Object.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isPrimitive()); [EOL]     assertEquals(Object.class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testMakeUnmodifiable() throws Exception { [EOL]     paramMap.makeUnmodifiable(); [EOL]     try { [EOL]         paramMap.register(String.class, "blah"); [EOL]         fail("Can not register handlers when map is unmodifiable"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testProperSerialization() throws Exception { [EOL]     DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL]     JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<Date>(dateSerializer); [EOL]     Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null); [EOL]     assertEquals(expected, actual); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testObjectArrayWithNonPrimitivesSerialization() throws Exception { [EOL]     ClassWithObjects classWithObjects = new ClassWithObjects(); [EOL]     BagOfPrimitives bagOfPrimitives = new BagOfPrimitives(); [EOL]     String classWithObjectsJson = gson.toJson(classWithObjects); [EOL]     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives); [EOL]     Object[] objects = new Object[] { classWithObjects, bagOfPrimitives }; [EOL]     String json = gson.toJson(objects); [EOL]     assertTrue(json.contains(classWithObjectsJson)); [EOL]     assertTrue(json.contains(bagOfPrimitivesJson)); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testSingleQuoteInStringSerialization() throws Exception { [EOL]     String valueWithQuotes = "beforeQuote'afterQuote"; [EOL]     String jsonRepresentation = gson.toJson(valueWithQuotes); [EOL]     assertEquals(valueWithQuotes, gson.fromJson(jsonRepresentation, String.class)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNullField() throws Exception { [EOL]     try { [EOL]         new FieldAttributes(Foo.class, null); [EOL]         fail("Field parameter can not be null"); [EOL]     } catch (NullPointerException expected) { [EOL]     } [EOL] }
public void testExplicitSerializationOfNulls() { [EOL]     Gson gson = gsonBuilder.create(); [EOL]     ClassWithObjects target = new ClassWithObjects(null); [EOL]     String actual = gson.toJson(target); [EOL]     String expected = "{\"bag\":null}"; [EOL]     assertEquals(expected, actual); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testDeclaredTypeAndClass() throws Exception { [EOL]     Type expectedType = new TypeToken<List<String>>() { [EOL]     }.getType(); [EOL]     assertEquals(expectedType, fieldAttributes.getDeclaredType()); [EOL]     assertEquals(List.class, fieldAttributes.getDeclaredClass()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testNumberSerialization() { [EOL]     Number expected = 1L; [EOL]     String json = gson.toJson(expected); [EOL]     assertEquals(expected.toString(), json); [EOL]     json = gson.toJson(expected, Number.class); [EOL]     assertEquals(expected.toString(), json); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testTypeOverridding() throws Exception { [EOL]     String handler1 = "blah1"; [EOL]     String handler2 = "blah2"; [EOL]     paramMap.register(String.class, handler1); [EOL]     paramMap.register(String.class, handler2); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertEquals(handler2, paramMap.getHandlerFor(String.class)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLongs() throws IOException { [EOL]     String json = "[0,0,0," + "1,1,1," + "-1,-1,-1," + "-9223372036854775808," + "9223372036854775807]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(0L, reader.nextLong()); [EOL]     assertEquals(0, reader.nextInt()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(1L, reader.nextLong()); [EOL]     assertEquals(1, reader.nextInt()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(-1L, reader.nextLong()); [EOL]     assertEquals(-1, reader.nextInt()); [EOL]     assertEquals(-1.0, reader.nextDouble()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MIN_VALUE, reader.nextLong()); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals(Long.MAX_VALUE, reader.nextLong()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testObjectsInArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a").value(5); [EOL]     jsonWriter.name("b").value(false); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("c").value(6); [EOL]     jsonWriter.name("d").value(true); [EOL]     jsonWriter.endObject(); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[{\"a\":5,\"b\":false}," + "{\"c\":6,\"d\":true}]", stringWriter.toString()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',{a:1},5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testGetActualTypeForFirstTypeVariable() { [EOL]     assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE)); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testLocaleSerializationWithLanguageCountry() { [EOL]     Locale target = Locale.CANADA_FRENCH; [EOL]     assertEquals("\"fr_CA\"", gson.toJson(target)); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testEscapingObjectFields() throws Exception { [EOL]     BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>"); [EOL]     String jsonRepresentation = gson.toJson(objWithPrimitives); [EOL]     assertFalse(jsonRepresentation.contains("<")); [EOL]     assertFalse(jsonRepresentation.contains(">")); [EOL]     assertTrue(jsonRepresentation.contains("\\\"")); [EOL]     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class); [EOL]     assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testRequiredEscapingUnicodeCharacter() throws Exception { [EOL]     char unicodeChar = '\u2028'; [EOL]     String unicodeString = "Testing" + unicodeChar; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertFalse(unicodeString.equals(escapedString)); [EOL]     assertEquals("Testing\\u2028", escapedString); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testInvalidConstruction() throws Exception { [EOL]     try { [EOL]         new TypeInfoMap(String.class); [EOL]         fail("Must be a ParameterizedType"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testMissingValue() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testBagOfPrimitiveWrappersDeserialization() throws Exception { [EOL]     BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false); [EOL]     String jsonString = target.getExpectedJson(); [EOL]     target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class); [EOL]     assertEquals(jsonString, target.getExpectedJson()); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testWrappedExceptionPropagation() throws Exception { [EOL]     IllegalArgumentException exceptionToThrow = new IllegalArgumentException(); [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(exceptionToThrow)); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertEquals(exceptionToThrow, expected.getCause()); [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testInvalidArrayDeserialization() { [EOL]     String json = "[1, 2 3, 4, 5]"; [EOL]     try { [EOL]         gson.fromJson(json, int[].class); [EOL]         fail("Gson should not deserialize array elements with missing ,"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testDefaultConstructorNotCalledOnField() throws Exception { [EOL]     DataHolderWrapper dataWrapper = new DataHolderWrapper(new DataHolder(DEFAULT_VALUE)); [EOL]     String json = gson.toJson(dataWrapper); [EOL]     DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class); [EOL]     assertEquals(DEFAULT_VALUE + SUFFIX, actual.getWrappedData().getData()); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testPrematurelyClosed() throws IOException { [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}")); [EOL]         reader.beginObject(); [EOL]         reader.close(); [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":[]}")); [EOL]         reader.close(); [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]         reader.beginObject(); [EOL]         reader.nextName(); [EOL]         reader.peek(); [EOL]         reader.close(); [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testCircularSerialization() throws Exception { [EOL]     ContainsReferenceToSelfType a = new ContainsReferenceToSelfType(); [EOL]     ContainsReferenceToSelfType b = new ContainsReferenceToSelfType(); [EOL]     a.children.add(b); [EOL]     b.children.add(a); [EOL]     try { [EOL]         gson.toJson(a); [EOL]         fail("Circular types should not get printed!"); [EOL]     } catch (IllegalStateException expected) { [EOL]         assertTrue(expected.getMessage().contains("children")); [EOL]     } [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNullField() throws Exception { [EOL]     try { [EOL]         new FieldAttributes(Foo.class, null); [EOL]         fail("Field parameter can not be null"); [EOL]     } catch (NullPointerException expected) { [EOL]     } [EOL] }
public void testTypeOverridding() throws Exception { [EOL]     String handler1 = "blah1"; [EOL]     String handler2 = "blah2"; [EOL]     paramMap.register(String.class, handler1); [EOL]     paramMap.register(String.class, handler2); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertEquals(handler2, paramMap.getHandlerFor(String.class)); [EOL] }
public void testMissingValue() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":}")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testAllUpperCaseExceptFirst() throws Exception { [EOL]     assertEquals("U R L", namingPolicy.translateName("uRL", String.class, null)); [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyExposedField"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testBadFieldTypeForCustomDeserializerCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     obj.add("longValue", array); [EOL]     try { [EOL]         gson.fromJson(obj, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testInnerClassExclusion() throws Exception { [EOL]     Gson gson = new GsonBuilder().disableInnerClassSerialization().create(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals("", result); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testObjectType() throws Exception { [EOL]     TypeInfo typeInfo = new TypeInfo(String.class); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isPrimitive()); [EOL]     assertEquals(String.class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSkipExplicitlySkippedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyHiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testBoolean() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE); [EOL]     assertTrue(json.isBoolean()); [EOL]     assertTrue(json.getAsBoolean()); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testIterator() { [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("one", parser.next().getAsString()); [EOL]     assertTrue(parser.hasNext()); [EOL]     assertEquals("two", parser.next().getAsString()); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() { [EOL]     Gson gson = builder.create(); [EOL]     ClassWithDuplicateFields target = new ClassWithDuplicateFields(10); [EOL]     String actual = gson.toJson(target); [EOL]     assertEquals("{\"a\":10}", actual); [EOL]     target = new ClassWithDuplicateFields(3.0D); [EOL]     actual = gson.toJson(target); [EOL]     assertEquals("{\"a\":3.0}", actual); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testRethrowJsonParseException() throws Exception { [EOL]     String errorMsg = "please rethrow me"; [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(new JsonParseException(errorMsg))); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertNull(expected.getCause()); [EOL]         assertEquals(errorMsg, expected.getMessage()); [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testParseMixedArray() { [EOL]     String json = "[{},13,\"stringValue\"]"; [EOL]     JsonElement e = parser.parse(json); [EOL]     assertTrue(e.isJsonArray()); [EOL]     JsonArray array = e.getAsJsonArray(); [EOL]     assertEquals("{}", array.get(0).toString()); [EOL]     assertEquals(13, array.get(1).getAsInt()); [EOL]     assertEquals("stringValue", array.get(2).getAsString()); [EOL] }
public void testIgnoreLaterVersionClassSerialization() { [EOL]     Gson gson = builder.setVersion(1.0).create(); [EOL]     assertEquals("", gson.toJson(new Version1_2())); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testParameterizedTypeVariableArrayField() throws Exception { [EOL]     Type listType = new TypeToken<List<Integer>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("listOfTypeVariablesArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testUriDeserialization() { [EOL]     String uriValue = "http://google.com/"; [EOL]     String json = '"' + uriValue + '"'; [EOL]     URI target = gson.fromJson(json, URI.class); [EOL]     assertEquals(uriValue, target.toASCIIString()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() { [EOL]     double expected = -122.08; [EOL]     double actual = gson.fromJson("[-122.08]", double.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[-122.08]", Double.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testValidFieldBeginsWithDollarSign() throws Exception { [EOL]     String fieldName = "$abc"; [EOL]     assertEquals(fieldName, validator.validate(fieldName)); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLocaleDeserializationWithLanguageCountry() { [EOL]     String json = "\"fr_CA\""; [EOL]     Locale locale = gson.fromJson(json, Locale.class); [EOL]     assertEquals(Locale.CANADA_FRENCH, locale); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testVersionedUntilSerialization() { [EOL]     Version1 target = new Version1(); [EOL]     Gson gson = builder.setVersion(1.29).create(); [EOL]     String json = gson.toJson(target); [EOL]     assertTrue(json.contains("\"a\":" + A)); [EOL]     gson = builder.setVersion(1.3).create(); [EOL]     json = gson.toJson(target); [EOL]     assertFalse(json.contains("\"a\":" + A)); [EOL] }
public void testNullDeserialization() throws Exception { [EOL]     String myNullObject = null; [EOL]     Object object = gson.fromJson(myNullObject, Object.class); [EOL]     assertNull(object); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testFieldNamingPolicy() throws Exception { [EOL]     FieldAttributes f = new FieldAttributes(String.class, String.class.getFields()[0]); [EOL]     assertEquals(f.getName(), namingPolicy.translateName(f)); [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testInnerClassExclusion() throws Exception { [EOL]     Gson gson = new GsonBuilder().disableInnerClassSerialization().create(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals("", result); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testReadWriteTwoObjects() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonReader parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     JsonElement element1 = Streams.parse(parser); [EOL]     JsonElement element2 = Streams.parse(parser); [EOL]     BagOfPrimitives actualOne = gson.fromJson(element1, BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(element2, BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testAddingBooleanProperties() throws Exception { [EOL]     String propertyName = "property"; [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     jsonObj.addProperty(propertyName, true); [EOL]     assertTrue(jsonObj.has(propertyName)); [EOL]     JsonElement jsonElement = jsonObj.get(propertyName); [EOL]     assertNotNull(jsonElement); [EOL]     assertTrue(jsonElement.getAsBoolean()); [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testStrictComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testTopLevelNullObjectSerialization() { [EOL]     Gson gson = gsonBuilder.create(); [EOL]     String actual = gson.toJson(null); [EOL]     assertEquals("null", actual); [EOL]     actual = gson.toJson(null, String.class); [EOL]     assertEquals("null", actual); [EOL] }
public void testLenientUnnecessaryArraySeparators() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true,,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[true,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     reader = new JsonReader(new StringReader("[,]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testCircularSerialization() throws Exception { [EOL]     ContainsReferenceToSelfType a = new ContainsReferenceToSelfType(); [EOL]     ContainsReferenceToSelfType b = new ContainsReferenceToSelfType(); [EOL]     a.children.add(b); [EOL]     b.children.add(a); [EOL]     try { [EOL]         gson.toJson(a); [EOL]         fail("Circular types should not get printed!"); [EOL]     } catch (IllegalStateException expected) { [EOL]         assertTrue(expected.getMessage().contains("children")); [EOL]     } [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testUsingDashesInstead() throws Exception { [EOL]     namingPolicy = new LowerCamelCaseSeparatorNamingPolicy("-"); [EOL]     String translatedName = namingPolicy.translateName("testUsingDashesInstead", CLASS, null); [EOL]     assertEquals("test-using-dashes-instead", translatedName); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testNulls() { [EOL]     try { [EOL]         new JsonReader(null); [EOL]         fail(); [EOL]     } catch (NullPointerException expected) { [EOL]     } [EOL] }
public void testInvalidFieldStartingDollarUnderscore() throws Exception { [EOL]     try { [EOL]         validator.validate("$_abc"); [EOL]         fail("Json field name can not start with two non-alphabet characters"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testNewlineEscaping() throws Exception { [EOL]     String containsNewline = "123\n456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsNewline); [EOL]     assertEquals("123\\n456", escapedString); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testUserDefinedExclusionPolicies() throws Exception { [EOL]     Gson gson = new GsonBuilder().setExclusionStrategies(new UserDefinedExclusionStrategy(String.class)).create(); [EOL]     String json = gson.toJson(new TestTypes.StringWrapper("someValue")); [EOL]     assertEquals("{}", json); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateDeserializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     Date extracted = gson.fromJson(json, Date.class); [EOL]     assertEquals(now.getYear(), extracted.getYear()); [EOL]     assertEquals(now.getMonth(), extracted.getMonth()); [EOL]     assertEquals(now.getDay(), extracted.getDay()); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testBadFieldTypeForDeserializingCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject primitive1 = new JsonObject(); [EOL]     primitive1.addProperty("string", "foo"); [EOL]     primitive1.addProperty("intValue", 11); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.add("primitive1", primitive1); [EOL]     obj.add("primitive2", array); [EOL]     try { [EOL]         gson.fromJson(obj, Nested.class); [EOL]         fail("Nested has field BagOfPrimitives which is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("explicitlyExposedField"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testTypeVariableField() throws Exception { [EOL]     Field f = obj.getClass().getField("typeVariableObj"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertFalse(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(Integer.class, typeInfo.getActualType()); [EOL]     assertEquals(Integer.class, typeInfo.getRawClass()); [EOL] }
public void testStringsAndChar() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("abc"); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('a', json.getAsCharacter()); [EOL]     assertEquals("abc", json.getAsString()); [EOL]     json = new JsonPrimitive('z'); [EOL]     assertTrue(json.isString()); [EOL]     assertEquals('z', json.getAsCharacter()); [EOL]     assertEquals("z", json.getAsString()); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testDoubleQuoteEscaping() throws Exception { [EOL]     String containsQuote = "123\"456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsQuote); [EOL]     assertEquals("123\\\"456", escapedString); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue"); [EOL]     assertEquals("\"Some\\nEscaped\\nValue\"", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal("1.333")); [EOL]     assertEquals("1.333", json.toString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testWrappedExceptionPropagation() throws Exception { [EOL]     IllegalArgumentException exceptionToThrow = new IllegalArgumentException(); [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(exceptionToThrow)); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertEquals(exceptionToThrow, expected.getCause()); [EOL]     } [EOL] }
public void testSelfReferenceArrayFieldSerialization() throws Exception { [EOL]     ClassWithSelfReferenceArray objA = new ClassWithSelfReferenceArray(); [EOL]     objA.children = new ClassWithSelfReferenceArray[] { objA }; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]         assertTrue(expected.getMessage().contains("children")); [EOL]     } [EOL] }
public void testCharacterUnescaping() throws IOException { [EOL]     String json = "[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"," + "\"\\u20AC\"" + "]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals("a", reader.nextString()); [EOL]     assertEquals("a\"", reader.nextString()); [EOL]     assertEquals("\"", reader.nextString()); [EOL]     assertEquals(":", reader.nextString()); [EOL]     assertEquals(",", reader.nextString()); [EOL]     assertEquals("\b", reader.nextString()); [EOL]     assertEquals("\f", reader.nextString()); [EOL]     assertEquals("\n", reader.nextString()); [EOL]     assertEquals("\r", reader.nextString()); [EOL]     assertEquals("\t", reader.nextString()); [EOL]     assertEquals(" ", reader.nextString()); [EOL]     assertEquals("\\", reader.nextString()); [EOL]     assertEquals("{", reader.nextString()); [EOL]     assertEquals("}", reader.nextString()); [EOL]     assertEquals("[", reader.nextString()); [EOL]     assertEquals("]", reader.nextString()); [EOL]     assertEquals("\0", reader.nextString()); [EOL]     assertEquals("\u0019", reader.nextString()); [EOL]     assertEquals("\u20AC", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testDateSerializationWithPattern() throws Exception { [EOL]     String pattern = "yyyy-MM-dd"; [EOL]     DateFormat formatter = new SimpleDateFormat(pattern); [EOL]     Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create(); [EOL]     Date now = new Date(); [EOL]     String json = gson.toJson(now); [EOL]     assertEquals("\"" + formatter.format(now) + "\"", json); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testInvalidConstruction() throws Exception { [EOL]     try { [EOL]         new TypeInfoMap(String.class); [EOL]         fail("Must be a ParameterizedType"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testStrictMultipleTopLevelValues() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[] []")); [EOL]     reader.beginArray(); [EOL]     reader.endArray(); [EOL]     try { [EOL]         reader.peek(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testUuidDeserialization() { [EOL]     String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0"; [EOL]     String json = '"' + uuidValue + '"'; [EOL]     UUID target = gson.fromJson(json, UUID.class); [EOL]     assertEquals(uuidValue, target.toString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testArrayOfCollectionDeserialization() throws Exception { [EOL]     String json = "[[1,2],[3,4]]"; [EOL]     Type type = new TypeToken<Collection<Integer>[]>() { [EOL]     }.getType(); [EOL]     Collection<Integer>[] target = gson.fromJson(json, type); [EOL]     assertEquals(2, target.length); [EOL]     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0])); [EOL]     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0])); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testSkipFieldsWithFalseOnly() throws Exception { [EOL]     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>(); [EOL]     strategies.add(FALSE_STRATEGY); [EOL]     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies); [EOL]     assertFalse(strategy.shouldSkipClass(CLAZZ)); [EOL]     assertFalse(strategy.shouldSkipField(FIELD)); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testStrings() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.value("a"); [EOL]     jsonWriter.value("a\""); [EOL]     jsonWriter.value("\""); [EOL]     jsonWriter.value(":"); [EOL]     jsonWriter.value(","); [EOL]     jsonWriter.value("\b"); [EOL]     jsonWriter.value("\f"); [EOL]     jsonWriter.value("\n"); [EOL]     jsonWriter.value("\r"); [EOL]     jsonWriter.value("\t"); [EOL]     jsonWriter.value(" "); [EOL]     jsonWriter.value("\\"); [EOL]     jsonWriter.value("{"); [EOL]     jsonWriter.value("}"); [EOL]     jsonWriter.value("["); [EOL]     jsonWriter.value("]"); [EOL]     jsonWriter.value("\0"); [EOL]     jsonWriter.value("\u0019"); [EOL]     jsonWriter.endArray(); [EOL]     assertEquals("[\"a\"," + "\"a\\\"\"," + "\"\\\"\"," + "\":\"," + "\",\"," + "\"\\b\"," + "\"\\f\"," + "\"\\n\"," + "\"\\r\"," + "\"\\t\"," + "\" \"," + "\"\\\\\"," + "\"{\"," + "\"}\"," + "\"[\"," + "\"]\"," + "\"\\u0000\"," + "\"\\u0019\"]", stringWriter.toString()); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testReplaceExistingTypeHierarchyHandler() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     paramMap.registerForTypeHierarchy(Base.class, "base2Handler"); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("base2Handler", handler); [EOL] }
public void testLowerCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER); [EOL]     assertEquals("blah", policy.translateName("Blah", String.class, null)); [EOL]     assertEquals("blah", policy.translateName("blah", String.class, null)); [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testDefaultCalendarDeserialization() throws Exception { [EOL]     Gson gson = new GsonBuilder().create(); [EOL]     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}"; [EOL]     Calendar cal = gson.fromJson(json, Calendar.class); [EOL]     assertEquals(2009, cal.get(Calendar.YEAR)); [EOL]     assertEquals(2, cal.get(Calendar.MONTH)); [EOL]     assertEquals(11, cal.get(Calendar.DAY_OF_MONTH)); [EOL]     assertEquals(14, cal.get(Calendar.HOUR_OF_DAY)); [EOL]     assertEquals(29, cal.get(Calendar.MINUTE)); [EOL]     assertEquals(23, cal.get(Calendar.SECOND)); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testInvalidConstruction() throws Exception { [EOL]     try { [EOL]         new TypeInfoMap(String.class); [EOL]         fail("Must be a ParameterizedType"); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testObjectArrayWithNonPrimitivesSerialization() throws Exception { [EOL]     ClassWithObjects classWithObjects = new ClassWithObjects(); [EOL]     BagOfPrimitives bagOfPrimitives = new BagOfPrimitives(); [EOL]     String classWithObjectsJson = gson.toJson(classWithObjects); [EOL]     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives); [EOL]     Object[] objects = new Object[] { classWithObjects, bagOfPrimitives }; [EOL]     String json = gson.toJson(objects); [EOL]     assertTrue(json.contains(classWithObjectsJson)); [EOL]     assertTrue(json.contains(bagOfPrimitivesJson)); [EOL] }
public void testLenientComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testIncludeStaticNestedClassObject() throws Exception { [EOL]     Class<?> clazz = staticNestedClass.getClass(); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL] }
public void testFloatInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     float infinity = Float.POSITIVE_INFINITY; [EOL]     assertEquals("Infinity", gson.toJson(infinity)); [EOL]     assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY)); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testArrayOfObjectsDeserialization() throws Exception { [EOL]     String json = new ArrayOfObjects().getExpectedJson(); [EOL]     ArrayOfObjects target = gson.fromJson(json, ArrayOfObjects.class); [EOL]     assertEquals(json, target.getExpectedJson()); [EOL] }
public void testHtmlCharacterSerialization() throws Exception { [EOL]     String target = "<script>var a = 12;</script>"; [EOL]     String result = gson.toJson(target); [EOL]     assertFalse(result.equals('"' + target + '"')); [EOL]     gson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     result = gson.toJson(target); [EOL]     assertTrue(result.equals('"' + target + '"')); [EOL] }
public void testFloatEqualsDouble() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testUserDefinedExclusionPolicies() throws Exception { [EOL]     Gson gson = new GsonBuilder().setExclusionStrategies(new UserDefinedExclusionStrategy(String.class)).create(); [EOL]     String json = gson.toJson(new TestTypes.StringWrapper("someValue")); [EOL]     assertEquals("{}", json); [EOL] }
public void testDefaultJavaSqlDateSerialization() { [EOL]     java.sql.Date instant = new java.sql.Date(1259875082000L); [EOL]     String json = gson.toJson(instant); [EOL]     assertEquals("\"Dec 3, 2009\"", json); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testExplicitNullSetsFieldToNullDuringDeserialization() { [EOL]     Gson gson = new Gson(); [EOL]     String json = "{value:null}"; [EOL]     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class); [EOL]     assertNull(obj.value); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testNotEquals() throws Exception { [EOL]     Type differentParameterizedType = new TypeToken<List<Integer>>() { [EOL]     }.getType(); [EOL]     assertFalse(differentParameterizedType.equals(ourType)); [EOL]     assertFalse(ourType.equals(differentParameterizedType)); [EOL] }
public void testDefaultConstructorNotCalledOnField() throws Exception { [EOL]     DataHolderWrapper dataWrapper = new DataHolderWrapper(new DataHolder(DEFAULT_VALUE)); [EOL]     String json = gson.toJson(dataWrapper); [EOL]     DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class); [EOL]     assertEquals(DEFAULT_VALUE + SUFFIX, actual.getWrappedData().getData()); [EOL] }
public void testAddingAndRemovingObjectProperties() throws Exception { [EOL]     JsonObject jsonObj = new JsonObject(); [EOL]     String propertyName = "property"; [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL]     assertNull(jsonObj.get(propertyName)); [EOL]     JsonPrimitive value = new JsonPrimitive("blah"); [EOL]     jsonObj.add(propertyName, value); [EOL]     assertEquals(value, jsonObj.get(propertyName)); [EOL]     JsonElement removedElement = jsonObj.remove(propertyName); [EOL]     assertEquals(value, removedElement); [EOL]     assertFalse(jsonObj.has(propertyName)); [EOL] }
public void testIncludeStaticNestedClassField() throws Exception { [EOL]     Field f = getClass().getField("staticNestedClass"); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f))); [EOL] }
public void testVariableTypeArrayDeserialization() throws Exception { [EOL]     Integer[] array = { 1, 2, 3 }; [EOL]     Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() { [EOL]     }.getType(); [EOL]     ObjectWithTypeVariables<Integer> objToSerialize = new ObjectWithTypeVariables<Integer>(null, array, null, null, null, null); [EOL]     String json = gson.toJson(objToSerialize, typeOfSrc); [EOL]     ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc); [EOL]     assertEquals(objAfterDeserialization.getExpectedJson(), json); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testBadFieldTypeForCustomDeserializerCustomTree() { [EOL]     JsonArray array = new JsonArray(); [EOL]     array.add(new JsonPrimitive("blah")); [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty("stringValue", "foo"); [EOL]     obj.addProperty("intValue", 11); [EOL]     obj.add("longValue", array); [EOL]     try { [EOL]         gson.fromJson(obj, BagOfPrimitives.class); [EOL]         fail("BagOfPrimitives is not an array"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testStringArray() throws Exception { [EOL]     TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class); [EOL]     assertTrue(arrayTypeInfo.isArray()); [EOL]     assertEquals(String.class, arrayTypeInfo.getSecondLevelType()); [EOL]     assertEquals(String[].class, arrayTypeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testParseMixedArray() { [EOL]     String json = "[{},13,\"stringValue\"]"; [EOL]     JsonElement e = parser.parse(json); [EOL]     assertTrue(e.isJsonArray()); [EOL]     JsonArray array = e.getAsJsonArray(); [EOL]     assertEquals("{}", array.get(0).toString()); [EOL]     assertEquals(13, array.get(1).getAsInt()); [EOL]     assertEquals("stringValue", array.get(2).getAsString()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testEmptyObject() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.endObject(); [EOL]     assertEquals("{}", stringWriter.toString()); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testTypeOverridding() throws Exception { [EOL]     String handler1 = "blah1"; [EOL]     String handler2 = "blah2"; [EOL]     paramMap.register(String.class, handler1); [EOL]     paramMap.register(String.class, handler2); [EOL]     assertTrue(paramMap.hasSpecificHandlerFor(String.class)); [EOL]     assertEquals(handler2, paramMap.getHandlerFor(String.class)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testUuidDeserialization() { [EOL]     String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0"; [EOL]     String json = '"' + uuidValue + '"'; [EOL]     UUID target = gson.fromJson(json, UUID.class); [EOL]     assertEquals(uuidValue, target.toString()); [EOL] }
public void testSetSerialization() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     HashSet<String> s = new HashSet<String>(); [EOL]     s.add("blah"); [EOL]     String json = gson.toJson(s); [EOL]     assertEquals("[\"blah\"]", json); [EOL]     json = gson.toJson(s, Set.class); [EOL]     assertEquals("[\"blah\"]", json); [EOL] }
public void testEmptyObject() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.endObject(); [EOL]     assertEquals("{}", stringWriter.toString()); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testStrictComments() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[// comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[# comment \n true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL]     reader = new JsonReader(new StringReader("[/* comment */ true]")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextBoolean(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testToRawClassForGenericClasses() { [EOL]     assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE)); [EOL] }
public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() { [EOL]     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create(); [EOL]     String target = "{\"Some Constant String Instance Field\":\"someValue\"}"; [EOL]     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class); [EOL]     assertEquals("someValue", deserializedObject.someConstantStringInstanceField); [EOL] }
public void testPropertiesDeserialization() { [EOL]     String json = "{foo:'bar'}"; [EOL]     Properties props = gson.fromJson(json, Properties.class); [EOL]     assertEquals("bar", props.getProperty("foo")); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testValidJsonOnToString() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue"); [EOL]     assertEquals("\"Some\\nEscaped\\nValue\"", json.toString()); [EOL]     json = new JsonPrimitive(new BigDecimal("1.333")); [EOL]     assertEquals("1.333", json.toString()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testIsArrayForArrayClasses() { [EOL]     assertTrue(TypeUtils.isArray(String[].class)); [EOL]     assertTrue(TypeUtils.isArray(Integer[][].class)); [EOL]     assertTrue(TypeUtils.isArray(Collection[].class)); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testDoubles() throws IOException { [EOL]     String json = "[-0.0," + "1.0," + "1.7976931348623157E308," + "4.9E-324," + "0.0," + "-0.5," + "2.2250738585072014E-308," + "3.141592653589793," + "2.718281828459045]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     assertEquals(-0.0, reader.nextDouble()); [EOL]     assertEquals(1.0, reader.nextDouble()); [EOL]     assertEquals(1.7976931348623157E308, reader.nextDouble()); [EOL]     assertEquals(4.9E-324, reader.nextDouble()); [EOL]     assertEquals(0.0, reader.nextDouble()); [EOL]     assertEquals(-0.5, reader.nextDouble()); [EOL]     assertEquals(2.2250738585072014E-308, reader.nextDouble()); [EOL]     assertEquals(3.141592653589793, reader.nextDouble()); [EOL]     assertEquals(2.718281828459045, reader.nextDouble()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception { [EOL]     Gson escapeHtmlGson = new GsonBuilder().create(); [EOL]     Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create(); [EOL]     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>"); [EOL]     String escapedJsonForm = escapeHtmlGson.toJson(target); [EOL]     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target); [EOL]     assertFalse(escapedJsonForm.equals(nonEscapedJsonForm)); [EOL]     assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)); [EOL]     assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testCustomAdapterInvokedForMapElementSerialization() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create(); [EOL]     StringHolder holder = new StringHolder("Jacob", "Tomaw"); [EOL]     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>(); [EOL]     mapOfHolders.put("foo", holder); [EOL]     String json = gson.toJson(mapOfHolders); [EOL]     assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\"")); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testLenientSemicolonDelimitedArray() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[true;true]")); [EOL]     reader.setLenient(true); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL] }
public void testMixedCaseLiterals() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("[True,TruE,False,FALSE,NULL,nulL]")); [EOL]     reader.beginArray(); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     assertEquals(false, reader.nextBoolean()); [EOL]     assertEquals(false, reader.nextBoolean()); [EOL]     reader.nextNull(); [EOL]     reader.nextNull(); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() { [EOL]     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base>() { [EOL]  [EOL]         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) { [EOL]             JsonObject json = new JsonObject(); [EOL]             json.addProperty("value", src.baseValue); [EOL]             return json; [EOL]         } [EOL]     }).create(); [EOL]     Base b = new Base(); [EOL]     String json = gson.toJson(b); [EOL]     assertTrue(json.contains("value")); [EOL]     b = new Derived(); [EOL]     json = gson.toJson(b, Base.class); [EOL]     assertTrue(json.contains("value")); [EOL]     assertFalse(json.contains("derivedValue")); [EOL] }
public void testUnicodeCharacterStringNoEscaping() throws Exception { [EOL]     String unicodeString = "\u0065\u0066"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(unicodeString); [EOL]     assertEquals(unicodeString, escapedString); [EOL] }
public void testTwoNames() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginObject(); [EOL]     jsonWriter.name("a"); [EOL]     try { [EOL]         jsonWriter.name("a"); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testSkipNonAnnotatedFields() throws Exception { [EOL]     Field f = MockObject.class.getField("hiddenField"); [EOL]     assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f))); [EOL] }
public void testPrematureEndOfInput() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true,")); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testNumberWithOctalPrefix() throws IOException { [EOL]     String json = "[01]"; [EOL]     JsonReader reader = new JsonReader(new StringReader(json)); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextInt(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextLong(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextDouble(); [EOL]         fail(); [EOL]     } catch (NumberFormatException expected) { [EOL]     } [EOL]     assertEquals("01", reader.nextString()); [EOL]     reader.endArray(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testParseEmptyWhitespaceInput() { [EOL]     JsonElement e = parser.parse("     "); [EOL]     assertTrue(e.isJsonNull()); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testArrayOfStringsDeserialization() { [EOL]     String json = "[\"Hello\",\"World\"]"; [EOL]     String[] target = gson.fromJson(json, String[].class); [EOL]     assertEquals("Hello", target[0]); [EOL]     assertEquals("World", target[1]); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testInnerClassExclusion() throws Exception { [EOL]     Gson gson = new GsonBuilder().disableInnerClassSerialization().create(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals("", result); [EOL] }
public void testNonFiniteBoxedDoubles() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     jsonWriter.beginArray(); [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NaN)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.NEGATIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL]     try { [EOL]         jsonWriter.value(new Double(Double.POSITIVE_INFINITY)); [EOL]         fail(); [EOL]     } catch (IllegalArgumentException expected) { [EOL]     } [EOL] }
public void testMakeUnmodifiable() throws Exception { [EOL]     paramMap.makeUnmodifiable(); [EOL]     try { [EOL]         paramMap.register(String.class, "blah"); [EOL]         fail("Can not register handlers when map is unmodifiable"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testDeepNestingArrays() throws IOException { [EOL]     StringWriter stringWriter = new StringWriter(); [EOL]     JsonWriter jsonWriter = new JsonWriter(stringWriter); [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.beginArray(); [EOL]     } [EOL]     for (int i = 0; i < 20; i++) { [EOL]         jsonWriter.endArray(); [EOL]     } [EOL]     assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString()); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testSerializingInterfaceObjectField() throws Exception { [EOL]     TestObjectWrapper objWrapper = new TestObjectWrapper(obj); [EOL]     assertEquals("{\"obj\":" + OBJ_JSON + "}", gson.toJson(objWrapper)); [EOL] }
public void testClassAndFieldAreAtSameVersion() throws Exception { [EOL]     Class<MockObject> clazz = MockObject.class; [EOL]     Field f = clazz.getField("someField"); [EOL]     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION); [EOL]     assertFalse(strategy.shouldSkipClass(clazz)); [EOL]     assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f))); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testArrayWithoutTypeInfoDeserialization() throws Exception { [EOL]     String json = "[1,'abc',[1,2],5]"; [EOL]     try { [EOL]         gson.fromJson(json, Object[].class); [EOL]         fail("This is crazy....how did we deserialize it!!!"); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testJsonObjectSerialization() { [EOL]     Gson gson = new GsonBuilder().serializeNulls().create(); [EOL]     JsonObject obj = new JsonObject(); [EOL]     String json = gson.toJson(obj); [EOL]     assertEquals("{}", json); [EOL] }
public void testNegativeInfinitySerialization() { [EOL]     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL]     double negativeInfinity = Double.NEGATIVE_INFINITY; [EOL]     assertEquals("-Infinity", gson.toJson(negativeInfinity)); [EOL]     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY)); [EOL] }
public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() { [EOL]     int expected = 1; [EOL]     int actual = gson.fromJson("[1]", int.class); [EOL]     assertEquals(expected, actual); [EOL]     actual = gson.fromJson("[1]", Integer.class); [EOL]     assertEquals(expected, actual); [EOL] }
public void testReadWriteTwoObjects() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     CharArrayWriter writer = new CharArrayWriter(); [EOL]     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one"); [EOL]     writer.write(gson.toJson(expectedOne).toCharArray()); [EOL]     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two"); [EOL]     writer.write(gson.toJson(expectedTwo).toCharArray()); [EOL]     CharArrayReader reader = new CharArrayReader(writer.toCharArray()); [EOL]     JsonStreamParser parser = new JsonStreamParser(reader); [EOL]     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("one", actualOne.stringValue); [EOL]     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class); [EOL]     assertEquals("two", actualTwo.stringValue); [EOL]     assertFalse(parser.hasNext()); [EOL] }
public void testNonExecutableJsonSerialization() { [EOL]     Gson gson = gsonBuilder.generateNonExecutableJson().create(); [EOL]     String json = gson.toJson(new BagOfPrimitives()); [EOL]     assertTrue(json.startsWith(JSON_NON_EXECUTABLE_PREFIX)); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testWrappedExceptionPropagation() throws Exception { [EOL]     IllegalArgumentException exceptionToThrow = new IllegalArgumentException(); [EOL]     JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer = new JsonDeserializerExceptionWrapper<String>(new ExceptionJsonDeserializer(exceptionToThrow)); [EOL]     try { [EOL]         wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null); [EOL]         fail("JsonParseException should have been thrown"); [EOL]     } catch (JsonParseException expected) { [EOL]         assertEquals(exceptionToThrow, expected.getCause()); [EOL]     } [EOL] }
public void testSubInterfacesOfCollectionSerialization() throws Exception { [EOL]     List<Integer> list = new LinkedList<Integer>(); [EOL]     list.add(0); [EOL]     list.add(1); [EOL]     list.add(2); [EOL]     list.add(3); [EOL]     Queue<Long> queue = new LinkedList<Long>(); [EOL]     queue.add(0L); [EOL]     queue.add(1L); [EOL]     queue.add(2L); [EOL]     queue.add(3L); [EOL]     Set<Float> set = new TreeSet<Float>(); [EOL]     set.add(0.1F); [EOL]     set.add(0.2F); [EOL]     set.add(0.3F); [EOL]     set.add(0.4F); [EOL]     SortedSet<Character> sortedSet = new TreeSet<Character>(); [EOL]     sortedSet.add('a'); [EOL]     sortedSet.add('b'); [EOL]     sortedSet.add('c'); [EOL]     sortedSet.add('d'); [EOL]     ClassWithSubInterfacesOfCollection target = new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet); [EOL]     assertEquals(target.getExpectedJson(), gson.toJson(target)); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testNextFailuresDoNotAdvance() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{\"a\":true}")); [EOL]     reader.beginObject(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals("a", reader.nextName()); [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endObject(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     assertEquals(true, reader.nextBoolean()); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.nextName(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.beginArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     try { [EOL]         reader.endArray(); [EOL]         fail(); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL]     reader.close(); [EOL] }
public void testNoTopLevelObject() throws IOException { [EOL]     try { [EOL]         new JsonReader(new StringReader("true")).nextBoolean(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testContains() throws Exception { [EOL]     MockObject objA = new MockObject(); [EOL]     MockObject objB = new MockObject(); [EOL]     assertEquals(objA, objB); [EOL]     stack.push(new ObjectTypePair(objA, MockObject.class, true)); [EOL]     assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true))); [EOL]     assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true))); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testReadEmptyObject() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{}")); [EOL]     reader.beginObject(); [EOL]     assertFalse(reader.hasNext()); [EOL]     reader.endObject(); [EOL]     assertEquals(JsonToken.END_DOCUMENT, reader.peek()); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testUpperCaseFirstLetter() throws Exception { [EOL]     ModifyFirstLetterNamingPolicy policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER); [EOL]     assertEquals("Blah", policy.translateName("blah", String.class, null)); [EOL]     assertEquals("Blah", policy.translateName("Blah", String.class, null)); [EOL] }
public void testWriteDoesNotMutateState() throws IOException { [EOL]     Gson gson = new Gson(); [EOL]     JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL]     jsonWriter.beginArray(); [EOL]     jsonWriter.setHtmlSafe(true); [EOL]     jsonWriter.setLenient(true); [EOL]     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter); [EOL]     assertTrue(jsonWriter.isHtmlSafe()); [EOL]     assertTrue(jsonWriter.isLenient()); [EOL]     jsonWriter.setHtmlSafe(false); [EOL]     jsonWriter.setLenient(false); [EOL]     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter); [EOL]     assertFalse(jsonWriter.isHtmlSafe()); [EOL]     assertFalse(jsonWriter.isLenient()); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testSubInterfacesOfCollectionDeserialization() throws Exception { [EOL]     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4]," + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]" + "}"; [EOL]     ClassWithSubInterfacesOfCollection target = gson.fromJson(json, ClassWithSubInterfacesOfCollection.class); [EOL]     assertTrue(target.listContains(0, 1, 2, 3)); [EOL]     assertTrue(target.queueContains(0, 1, 2, 3)); [EOL]     assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)); [EOL]     assertTrue(target.sortedSetContains('a', 'b', 'c', 'd')); [EOL] }
public void testTypeHierarchyRegisterIfAbsent() { [EOL]     paramMap.registerForTypeHierarchy(Base.class, "baseHandler"); [EOL]     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>(); [EOL]     otherMap.registerForTypeHierarchy(Base.class, "baseHandler2"); [EOL]     paramMap.registerIfAbsent(otherMap); [EOL]     String handler = paramMap.getHandlerFor(Base.class); [EOL]     assertEquals("baseHandler", handler); [EOL] }
public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception { [EOL]     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter(); [EOL]     gson = new GsonBuilder().registerTypeAdapter(long.class, typeAdapter).registerTypeAdapter(Long.class, typeAdapter).create(); [EOL]     long[] value = { 1L }; [EOL]     String serializedValue = gson.toJson(value); [EOL]     String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]"; [EOL]     assertEquals(expected, serializedValue); [EOL]     long[] deserializedValue = gson.fromJson(serializedValue, long[].class); [EOL]     assertEquals(1, deserializedValue.length); [EOL]     assertEquals(value[0], deserializedValue[0]); [EOL] }
public void testPropertiesSerialization() { [EOL]     Properties props = new Properties(); [EOL]     props.setProperty("foo", "bar"); [EOL]     String json = gson.toJson(props); [EOL]     String expected = "{\"foo\":\"bar\"}"; [EOL]     assertEquals(expected, json); [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testQueueSerialization() { [EOL]     Queue<String> queue = new LinkedList<String>(); [EOL]     queue.add("a1"); [EOL]     queue.add("a2"); [EOL]     Type queueType = new TypeToken<Queue<String>>() { [EOL]     }.getType(); [EOL]     String json = gson.toJson(queue, queueType); [EOL]     assertTrue(json.contains("a1")); [EOL]     assertTrue(json.contains("a2")); [EOL] }
public void testPopTooMany() throws Exception { [EOL]     ObjectTypePair obj = new ObjectTypePair(this, getClass(), true); [EOL]     stack.push(obj); [EOL]     assertEquals(obj, stack.pop()); [EOL]     try { [EOL]         stack.pop(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testStrictSingleQuotedStrings() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("['a']")); [EOL]     reader.beginArray(); [EOL]     try { [EOL]         reader.nextString(); [EOL]         fail(); [EOL]     } catch (IOException expected) { [EOL]     } [EOL] }
public void testDefaultNestedStaticClassIncluded() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Outer.Inner target = outer.new Inner(VALUE); [EOL]     String result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL]     gson = new GsonBuilder().create(); [EOL]     target = outer.new Inner(VALUE); [EOL]     result = gson.toJson(target); [EOL]     assertEquals(target.toJson(), result); [EOL] }
public void testCarrageReturnEscaping() throws Exception { [EOL]     String containsCarrageReturn = "123\r456"; [EOL]     String escapedString = escapeHtmlChar.escapeJsonString(containsCarrageReturn); [EOL]     assertEquals("123\\r456", escapedString); [EOL] }
public void testPeekEmptyStack() throws Exception { [EOL]     try { [EOL]         stack.peek(); [EOL]     } catch (EmptyStackException expected) { [EOL]     } [EOL] }
public void testSingle() throws Exception { [EOL]     Gson gson = new Gson(); [EOL]     Bar bar1 = new Bar("someString", 1); [EOL]     ArrayList<Integer> arrayList = new ArrayList<Integer>(); [EOL]     arrayList.add(1); [EOL]     arrayList.add(2); [EOL]     bar1.map.put("key1", arrayList); [EOL]     bar1.map.put("key2", new ArrayList<Integer>()); [EOL]     String json = gson.toJson(bar1); [EOL]     System.out.println(json); [EOL]     Bar bar2 = gson.fromJson(json, Bar.class); [EOL]     assertEquals(bar1, bar2); [EOL] }
public void testNullsInArraySerialization() { [EOL]     String[] array = { "foo", null, "bar" }; [EOL]     String expected = "[\"foo\",null,\"bar\"]"; [EOL]     String json = gson.toJson(array); [EOL]     assertEquals(expected, json); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }
public void testBadValueForBigDecimalDeserialization() { [EOL]     try { [EOL]         gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class); [EOL]         fail("Exponent of a BigDecimal must be an integer value."); [EOL]     } catch (JsonParseException expected) { [EOL]     } [EOL] }
public void testSimpleAdapter() throws Exception { [EOL]     Field field = String.class.getFields()[0]; [EOL]     String expectedFieldName = field.getName().toUpperCase(); [EOL]     FieldNamingStrategy2 adapter = new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy()); [EOL]     assertEquals(expectedFieldName, adapter.translateName(new FieldAttributes(String.class, field))); [EOL] }
public void testSelfReferenceSerialization() throws Exception { [EOL]     ClassOverridingEquals objA = new ClassOverridingEquals(); [EOL]     objA.ref = objA; [EOL]     try { [EOL]         gson.toJson(objA); [EOL]         fail("Circular reference to self can not be serialized!"); [EOL]     } catch (IllegalStateException expected) { [EOL]     } [EOL] }
public void testGenericArrayTypeField() throws Exception { [EOL]     Type listType = new TypeToken<List<String>[]>() { [EOL]     }.getType(); [EOL]     Field f = obj.getClass().getField("simpleGenericArray"); [EOL]     TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE); [EOL]     assertTrue(typeInfo.isArray()); [EOL]     assertFalse(typeInfo.isEnum()); [EOL]     assertEquals(listType, typeInfo.getActualType()); [EOL]     assertEquals(List[].class, typeInfo.getRawClass()); [EOL] }
public void testNullsInArrayDeserialization() { [EOL]     String json = "[\"foo\",null,\"bar\"]"; [EOL]     String[] expected = { "foo", null, "bar" }; [EOL]     String[] target = gson.fromJson(json, expected.getClass()); [EOL]     for (int i = 0; i < expected.length; ++i) { [EOL]         assertEquals(expected[i], target[i]); [EOL]     } [EOL] }
public void testDefaultJavaSqlTimeDeserialization() { [EOL]     String json = "'1:18:02 PM'"; [EOL]     Time extracted = gson.fromJson(json, Time.class); [EOL]     assertEqualsTime(extracted, 13, 18, 02); [EOL] }
public void testLenientUnquotedNames() throws IOException { [EOL]     JsonReader reader = new JsonReader(new StringReader("{a:true}")); [EOL]     reader.setLenient(true); [EOL]     reader.beginObject(); [EOL]     assertEquals("a", reader.nextName()); [EOL] }
public void testParsingStringAsNumber() throws Exception { [EOL]     JsonPrimitive json = new JsonPrimitive("1"); [EOL]     assertFalse(json.isNumber()); [EOL]     assertEquals(1D, json.getAsDouble(), 0.00001); [EOL]     assertEquals(1F, json.getAsFloat(), 0.00001); [EOL]     assertEquals(1, json.getAsInt()); [EOL]     assertEquals(1L, json.getAsLong()); [EOL]     assertEquals((short) 1, json.getAsShort()); [EOL]     assertEquals((byte) 1, json.getAsByte()); [EOL]     assertEquals(new BigInteger("1"), json.getAsBigInteger()); [EOL]     assertEquals(new BigDecimal("1"), json.getAsBigDecimal()); [EOL] }
public void testShortEqualsInteger() { [EOL]     JsonPrimitive p1 = new JsonPrimitive(new Short((short) 10)); [EOL]     JsonPrimitive p2 = new JsonPrimitive(new Integer(10)); [EOL]     assertEquals(p1, p2); [EOL]     assertEquals(p1.hashCode(), p2.hashCode()); [EOL] }
public void testCreatingMoreThanOnce() { [EOL]     GsonBuilder builder = new GsonBuilder(); [EOL]     builder.create(); [EOL]     builder.create(); [EOL] }